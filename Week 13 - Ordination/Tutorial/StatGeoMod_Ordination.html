<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />



<meta name="progressive" content="false" />
<meta name="allow-skip" content="false" />
<meta name="learnr-version-prerender" content="0.10.7.9000" />

<title>Spatial Interpolation</title>

<!-- header-includes START -->
<!-- HEAD_CONTENT -->
<!-- header-includes END -->
<!-- HEAD_CONTENT -->

<!-- highlightjs -->
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>


<!-- taken from https://github.com/rstudio/rmarkdown/blob/de8a9c38618903627ca509f5401d50a0876079f7/inst/rmd/h/default.html#L293-L343 -->
<!-- tabsets -->
<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>
<!-- end tabsets -->


</head>

<body>
<a class='sr-only sr-only-focusable visually-hidden-focusable' href='#learnr-tutorial-content'>Skip to Tutorial Content</a>



<div class="pageContent band">
<main class="bandContent page">

<article class="topics" id="learnr-tutorial-content">

<div id="section-before-you-start." class="section level2">
<h2>Before you start.</h2>
<p>Mac Nally (1989) evaluated the maximum abundance (across four
seasons) for 102 species of birds for 37 sites [<code>SITE</code>] in
south-eastern Australia. The data in <code>macnally.csv</code> represent
the densities of each of the 102-bird species [<code>V1.</code> through
<code>V102.</code>], rather than absolute counts so that no
transformation will be necessary. As a result, species with high
densities will dominate the dissimilarities between sites.</p>
</div>
<div id="section-distances" class="section level2">
<h2>Distances</h2>
<p>You are working with community data. Therefore you need to use
relevant distance metrics when estimating the difference between sites.
Remember that the objective of clustering is to recognise discontinuous
subsets in an environment that is sometimes discrete (as in taxonomy)
but most often perceived as continuous in ecology.</p>
<p>Note that most clustering methods are computed from association
matrices, which stresses the importance of choosing an appropriate
association coefficient. This means the type of data you use will define
the best distance/association coefficient to be used. When dealing with
community data, you can use some of the dissimilarity metrics commonly
used in community ecology (e.g. Bray-Curtis, Jaccard, or Sorensen). As
the data here is not presence-absence but rather densities, it is not
recommended to use Jaccard or Sorensen dissimilarity. This makes
Bray-Curtis dissimilarities a better approach.</p>
<p>As you have community data, the best distance matrix to use is
Bray-Curtis dissimilarities. Also, with the housekeeping done, you can
now use the <code>vegdist()</code> function (from the <code>vegan</code>
package) to estimate the differences between sites. Remember that you
need to set the <code>method</code> argument to the correct distance
metric; in this case: <code>bray</code>. Here, you save the distance
matrix as an object called `macnally.Dist.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Estimate the Bray-Curtis dissimilarities between sampled sites.</p>
</div>
<div class="tutorial-exercise" data-label="BrayDist" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code># Estimate the  dissimilarities between sampled sites.
macnally.dist &lt;- vegdist(x = macnally.clean, # the Community data matrix 
                         method = &quot;_______&quot; # defie the Dissimilarity index to use.
                         )
# See the Output
head(_______)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="BrayDist-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Estimate the  dissimilarities between sampled sites.
macnally.dist &lt;- vegdist(x = macnally.clean, # the Community data matrix 
                         method = &quot;bray&quot; # defie the Dissimilarity index to use.
                         )
# See the Output
head(macnally.dist)</code></pre>
</div>
</div>
<div
id="section-hierarchical-clustering-based-on-links---single-linkages-complete-linkages-and-averages"
class="section level2">
<h2>Hierarchical Clustering Based on Links - Single Linkages, Complete
Linkages, and Averages</h2>
<p>Now that you have a distance matrix, you can explore different
clustering algorithms. Here, you start with some Hierarchical Clustering
Based on Links. you explore the three basic algorithms:</p>
<ol style="list-style-type: decimal">
<li>Single Linkage Agglomerative Clustering.<br />
</li>
<li>Complete Linkage Agglomerative Clustering.<br />
</li>
<li>Average Agglomerative Clustering.</li>
</ol>
<p>All these are implemented using the <code>hclust()</code> function by
changing the method argument for each. You may want to look at the
<code>hclust()</code> help file (using <code>?hclust</code>).</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Here, you will both build and plot a dendrogram based on a Single
Linkage approch.</p>
</div>
<div class="tutorial-exercise" data-label="Dend1a" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code># Single linkage
Hclus.1 &lt;- hclust(d = macnally.dist, # A dissimilarity structure.
                  method = &quot;_______&quot;) # Agglomeration method to be used.

# Plot the Hierarchical cluster (hclust) object.
plot(x = _______, # An object of the type produced by hclust.
     main = &quot;Bray Curtis\n Single linkage&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) </code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="Dend1a-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Single linkage
Hclus.1 &lt;- hclust(d = macnally.dist, # A dissimilarity structure.
                  method = &quot;single&quot;) # Agglomeration method to be used.

# Plot the Hierarchical cluster (hclust) object.
plot(x = Hclus.1, # An object of the type produced by hclust.
     main = &quot;Bray Curtis\n Single linkage&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) </code></pre>
</div>
<p>Based on the Single linkage clustering, it is possible to see a
consistent gradient of sites, particularly distinguishable on the
right-hand cluster. The reason for this is how clusters are put together
in a single linkage approach.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Here, you will both build and plot a dendrogram based on a Complete
Linkage approach.</p>
</div>
<div class="tutorial-exercise" data-label="Dend1b" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>## Complete linkage
Hclus.2 &lt;-  hclust(d = macnally.dist, # A dissimilarity structure.
                  method = &quot;_________&quot;) # Agglomeration method to be used.
# Plot the Hierarchical cluster (hclust) object.
plot(x = _________, # An object of the type produced by hclust.
     main = &quot;Bray Curtis\n Complete linkage&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) </code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="Dend1b-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>## Complete linkage
Hclus.2 &lt;-  hclust(d = macnally.dist, # A dissimilarity structure.
                  method = &quot;complete&quot;) # Agglomeration method to be used.
# Plot the Hierarchical cluster (hclust) object.
plot(x = Hclus.2, # An object of the type produced by hclust.
     main = &quot;Bray Curtis\n Complete linkage&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) </code></pre>
</div>
<p>The Complete linkage clustering tends to place sites within the same
habitat in the same groups. One way to look at those is to define the
argument <code>labels</code> to the plot function.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Here, you will both build and plot a dendrogram based on a UPGMA
Average Linkage approach.</p>
</div>
<div class="tutorial-exercise" data-label="Dend1c" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code>## Average (UPGMA) linkage  
Hclus.3 &lt;- hclust(d = macnally.dist, # A dissimilarity structure.
                  method = &quot;_______&quot;) # Agglomeration method to be used.
# Plot the Hierarchical cluster (hclust) object.
plot(x = _______, # An object of the type produced by hclust.
     main = &quot;Bray Curtis\n Average&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) </code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="Dend1c-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>## Average (UPGMA) linkage  
Hclus.3 &lt;- hclust(d = macnally.dist, # A dissimilarity structure.
                  method = &quot;average&quot;) # Agglomeration method to be used.
# Plot the Hierarchical cluster (hclust) object.
plot(x = Hclus.2, # An object of the type produced by hclust.
     main = &quot;Bray Curtis\n Average&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) </code></pre>
</div>
</div>
<div id="section-hierarchical-clustering-changing-the-tip-names"
class="section level2">
<h2>Hierarchical Clustering changing the tip names</h2>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Add the habitat type to the Complete Linkage dendrogram by defining
the argument <code>labels</code> to the plot function.</p>
</div>
<div class="tutorial-exercise" data-label="DenPltLab"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Plot the Complete Linkage Hierarchical cluster (hclust) object.
plot(x = _______, # An object of the type produced by hclust().
     labels = macnally$_______, # A character vector of labels for the leaves of the tree.
     main = &quot;Bray Curtis\n Complete&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) </code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="DenPltLab-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Plot the Complete Linkage Hierarchical cluster (hclust) object.
plot(x = Hclus.2, # An object of the type produced by hclust().
     labels = macnally$HABITAT, # A character vector of labels for the leaves of the tree.
     main = &quot;Bray Curtis\n Complete&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) </code></pre>
</div>
<p>Here, you see that while the well-defined groups are clustered
together, the mixed habitats are scattered across all groups.</p>
<p>The emerging question is <strong>How can three perfectly valid
clustering methods produce such different results when applied to the
same data?</strong></p>
<p>These three different clustering approaches show different patterns
that reflect the difference in the philosophy of the methods. First, the
dendrogram resulting from a single linkage clustering shows chaining of
objects, which indicates a gradient of composition changes. By
comparison, the complete linkage and UPGMA clustering approaches
indicate “groups” of composition similarity. However, the result of a
UPGMA approach is somehow intermediate to a single and complete
linkage.</p>
</div>
<div
id="section-hierarchical-clustering-based-on-links---wards-minimum-variance"
class="section level2">
<h2>Hierarchical Clustering Based on Links - Ward’s Minimum
Variance</h2>
<p>The three options above are the traditional ways to build
dendrograms. You can also use a method based on the linear model
criterion of least squares (Ward’s Minimum Variance Clustering). Here
the goal is to build groups that minimise the within-group sum of
squares (the sum of the squared distances among members of a cluster
divided by the number of objects). This is the same procedure used to
estimate the squared error in an ANOVA.</p>
<p>Like the three methods described above, Ward’s method is implemented
in <code>hclust()</code>. Still, there are two different
implementations:(1) <code>method = "ward.D2"</code>, and (2)
<code>method = "ward"</code>.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Using <code>method = "ward.D2"</code> and a Bray Curtis
dissimilarity, you will now plot the dendrogram resulting from
implementing Ward’s clustering to the data.</p>
<p>Also, plot the dendrogram adding the habitat type to the tips of the
dendrogram.</p>
</div>
<div class="tutorial-exercise" data-label="WardDend" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="20">
<pre class="text"><code>## Ward’s clustering.  
Hclus.4 &lt;- hclust(d = macnally.dist, # A dissimilarity structure.
                  method = &quot;_______&quot;) # Agglomeration method to be used.

# Plot the Hierarchical cluster (hclust) object.
plot(x = _______, # An object of the type produced by hclust.
     main = &quot;Bray Curtis\n Ward’s method &quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) 

# Plot the Hierarchical cluster (hclust) object, adding the habitat-type 
plot(x = _______, # An object of the type produced by hclust.
     labels = macnally$_______, # A character vector of labels for the leaves of the tree.
     main = &quot;Bray Curtis\n Ward’s method&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) </code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="WardDend-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>## Ward’s clustering.  
Hclus.4 &lt;- hclust(d = macnally.dist, # A dissimilarity structure.
                  method = &quot;ward.D2&quot;) # Agglomeration method to be used.

# Plot the Hierarchical cluster (hclust) object.
plot(x = Hclus.4, # An object of the type produced by hclust.
     main = &quot;Bray Curtis\n Ward’s method &quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) 

# Plot the Hierarchical cluster (hclust) object, adding the habitat-type 
plot(x = Hclus.4, # An object of the type produced by hclust.
     labels = macnally$HABITAT, # A character vector of labels for the leaves of the tree.
     main = &quot;Bray Curtis\n Ward’s method&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) </code></pre>
</div>
<p>Overall, the results above show that the approach you used reflects a
conceptual distinction between it and other methods. Specifically,
Ward’s approach focuses on showing the grouping of sites based on
minimising the variance in the distance between elements in a cluster.
In contrast, complete/UPGMA is focused on the average distances.</p>
</div>
<div
id="section-cophenetic-correlation---how-good-is-the-clustering-of-observations"
class="section level2">
<h2>Cophenetic Correlation - How good is the clustering of
observations?</h2>
<p>Up until now, you have created a bunch of dendrograms and compared
these among each other. But to define how good they are, you need to
consider how good they are at capturing the original differences between
sites. For this, you will establish the correlation between the original
distances and the cophenetic distances (distance between two objects in
a dendrogram).</p>
<p>For this, you estimate the Pearson’s correlation (r) between the
original and <strong>cophenetic distances</strong>. This is what you
call the <strong>cophenetic correlation</strong>. The method with the
highest cophenetic correlation may be seen as producing the clustering
model that retains most of the information contained in the
dissimilarity matrix. However, this does not necessarily mean that this
clustering model is the most adequate for the researcher’s goal.</p>
<p>You can plot their relation between the cophenetic distances and
original distance (these plots are called <strong>Shepard-like
diagrams</strong>) to check how good is the cluster. You can also
estimate the correlation between the original and each of the cophenetic
distances. Then you can use these as a measurement of “how good is the
clustering?”.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Plot the cophenetic vs. original distances for the single linkage
approache.</p>
<p>Also, estimate the correlation between the original and the
cophenetic distances calculated above for the single linkage, complete
linkage, UPGMA, and Ward’s clustering approaches. Add these as insert
text in each panel.</p>
</div>
<div class="tutorial-exercise" data-label="ShepDiag1"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="30">
<pre class="text"><code># Calculate the cophenetic distance for the single linkage clustering.
SingLin.dist &lt;- cophenetic(_______)
# Print the object class of the cophenetic distance
class(_______)

## Plot the original vs cophenetic for the Single Linkage dendrogram.
plot(x = _______, # Cophenetic distances.
     y = macnally.dist, # Original distances.
     main = &#39;Cophenetic Correlation\n Single linkage&#39;,# Figure main title.
     pch = 19, col = &quot;lightgrey&quot;, cex=1.2 # Define Point type, colour, and size arguments.
     )
# Add a 1:1 line
abline(a = 0, b = 1, # Set the intercept (a) and slope (b).
       lty = 1, lwd = 2,
       xpd = F) # Define the line width and type attributes.

# Add a line representing the smoothed relation between the original vs cophenetic distances
# A Loess model
SmothMod &lt;- lowess(macnally.dist ~ _______)
# Add a line with the Loess model
lines(_______, # The Loess model 
      lty = 2, col = &quot;red&quot;, lwd = 2) # Define the line colour, width, and type attributes.

# Estimate the correlations between original vs cophenetic distances.
cor.SingLin &lt;- cor(_______, macnally.dist)

# Add the correlation to the figure as a text box
legend(&quot;topleft&quot;, # Position the legend?
       legend = paste(&quot;Pearson = &quot;, round(cor.SingLin, 3)), # Legend Text.
       bty = &quot;n&quot; # Type of box to be drawn around the legend.
       )</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="ShepDiag1-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Calculate the cophenetic distance for the single linkage clustering.
SingLin.dist &lt;- cophenetic(Hclus.1)
# Print the object class of the cophenetic distance
class(SingLin.dist)

## Plot the original vs cophenetic for the Single Linkage dendrogram.
plot(x = SingLin.dist, # Cophenetic distances.
     y = macnally.dist, # Original distances.
     main = &#39;Cophenetic Correlation\n Single linkage&#39;,# Figure main title.
     pch = 19, col = &quot;lightgrey&quot;, cex=1.2 # Define Point type, colour, and size arguments.
     )
# Add a 1:1 line
abline(a = 0, b = 1, # Set the intercept (a) and slope (b).
       lty = 1, lwd = 2,
       xpd = F) # Define the line width and type attributes.

# Add a line representing the smoothed relation between the original vs cophenetic distances
# A Loess model
SmothMod &lt;- lowess(macnally.dist ~ SingLin.dist)
# Add a line with the Loess model
lines(SmothMod, # The Loess model 
      lty = 2, col = &quot;red&quot;, lwd = 2) # Define the line colour, width, and type attributes.

# Estimate the correlations between original vs cophenetic distances.
cor.SingLin &lt;- cor(SingLin.dist, macnally.dist)

# Add the correlation to the figure as a text box
legend(&quot;topleft&quot;, # Position the legend?
       legend = paste(&quot;Pearson = &quot;, round(cor.SingLin, 3)), # Legend Text.
       bty = &quot;n&quot; # Type of box to be drawn around the legend.
       )</code></pre>
</div>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Plot the cophenetic vs. original distances for the complete linkage
approache.</p>
<p>Also, estimate the correlation between the original and the
cophenetic distances calculated above for the single linkage, complete
linkage, UPGMA, and Ward’s clustering approaches. Add these as insert
text in each panel.</p>
</div>
<div class="tutorial-exercise" data-label="ShepDiag2"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="30">
<pre class="text"><code># Calculate the cophenetic distance for the complete linkage clustering.
CompLin.dist &lt;- cophenetic(______)
# Print the object class of the cophenetic distance
class(CompLin.dist)

# Plot the original vs cophenetic for the Complete Linkage dendrogram.
  plot(x = ______, # Cophenetic distances.
       y = macnally.dist, # Original distances.
       main = &#39;Cophenetic Correlation\n Complete linkage&#39;# Figure main title.
  )
# Add a 1:1 line
abline(a = 0, b = 1, # Set the intercept (a) and slope (b).
       lty = 1, lwd = 2) # Define the line width and type attributes.

# Add a line representing the smoothed relation between the original vs cophenetic distances
# A Loess model
SmothMod &lt;- lowess(macnally.dist ~ ______)
# Add a line with the Loess model
lines(______, # The Loess model 
      lty = 2, col = &quot;red&quot;, lwd = 2) # Define the line colour, width, and type attributes.

# Estimate the correlations between original vs cophenetic distances.
cor.CompLin &lt;- cor(______, macnally.dist)

# Add the correlation to the figure as a text box
legend(&quot;topleft&quot;, # Where to place the legend box.
       legend = paste(&quot;Pearson = &quot;, round(cor.CompLin, 3)), # Legend Text.
       bty = &quot;n&quot; # Type of box to be drawn around the legend.
)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="ShepDiag2-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Calculate the cophenetic distance for the complete linkage clustering.
CompLin.dist &lt;- cophenetic(Hclus.2)
# Print the object class of the cophenetic distance
class(CompLin.dist)

# Plot the original vs cophenetic for the Complete Linkage dendrogram.
  plot(x = CompLin.dist, # Cophenetic distances.
       y = macnally.dist, # Original distances.
       main = &#39;Cophenetic Correlation\n Complete linkage&#39;# Figure main title.
  )
# Add a 1:1 line
abline(a = 0, b = 1, # Set the intercept (a) and slope (b).
       lty = 1, lwd = 2) # Define the line width and type attributes.

# Add a line representing the smoothed relation between the original vs cophenetic distances
# A Loess model
SmothMod &lt;- lowess(macnally.dist ~ CompLin.dist)
# Add a line with the Loess model
lines(SmothMod, # The Loess model 
      lty = 2, col = &quot;red&quot;, lwd = 2) # Define the line colour, width, and type attributes.

# Estimate the correlations between original vs cophenetic distances.
cor.CompLin &lt;- cor(CompLin.dist, macnally.dist)

# Add the correlation to the figure as a text box
legend(&quot;topleft&quot;, # Where to place the legend box.
       legend = paste(&quot;Pearson = &quot;, round(cor.CompLin, 3)), # Legend Text.
       bty = &quot;n&quot; # Type of box to be drawn around the legend.
)</code></pre>
</div>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Plot the cophenetic vs. original distances for the UPGMA
approache.</p>
<p>Also, estimate the correlation between the original and the
cophenetic distances calculated above for the single linkage, complete
linkage, UPGMA, and Ward’s clustering approaches. Add these as insert
text in each panel.</p>
</div>
<div class="tutorial-exercise" data-label="ShepDiag3"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="30">
<pre class="text"><code># Calculate the cophenetic distance for the average/UPGMA clustering.
UPGMA.dist &lt;- cophenetic(______)
# Print the object class of the cophenetic distance
class(UPGMA.dist)

# Plot the original vs cophenetic for the UPGMA dendrogram.
  plot(x = ______, # Cophenetic distances.
       y = macnally.dist, # Original distances.
       main = &#39;Cophenetic Correlation\n UPGMA&#39;# Figure main title.
  )
# Add a 1:1 line
abline(a = 0, b = 1, # Set the intercept (a) and slope (b).
       lty = 1, lwd = 2) # Define the line width and type attributes.

# Add a line representing the smoothed relation between the original vs cophenetic distances
# A Loess model
SmothMod &lt;- lowess(macnally.dist ~ ______)
# Add a line with the Loess model
lines(______, # The Loess model 
      lty = 2, col = &quot;red&quot;, lwd = 2) # Define the line colour, width, and type attributes.

# Estimate the correlations between original vs cophenetic distances.
cor.CompLin &lt;- cor(______, macnally.dist)

# Add the correlation to the figure as a text box
legend(&quot;topleft&quot;, # Where to place the legend box.
       legend = paste(&quot;Pearson = &quot;, round(cor.CompLin, 3)), # Legend Text.
       bty = &quot;n&quot; # Type of box to be drawn around the legend.
)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="ShepDiag3-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Calculate the cophenetic distance for the average/UPGMA clustering.
UPGMA.dist &lt;- cophenetic(Hclus.3)
# Print the object class of the cophenetic distance
class(UPGMA.dist)

# Plot the original vs cophenetic for the UPGMA dendrogram.
  plot(x = UPGMA.dist, # Cophenetic distances.
       y = macnally.dist, # Original distances.
       main = &#39;Cophenetic Correlation\n UPGMA&#39;# Figure main title.
  )
# Add a 1:1 line
abline(a = 0, b = 1, # Set the intercept (a) and slope (b).
       lty = 1, lwd = 2) # Define the line width and type attributes.

# Add a line representing the smoothed relation between the original vs cophenetic distances
# A Loess model
SmothMod &lt;- lowess(macnally.dist ~ UPGMA.dist)
# Add a line with the Loess model
lines(SmothMod, # The Loess model 
      lty = 2, col = &quot;red&quot;, lwd = 2) # Define the line colour, width, and type attributes.

# Estimate the correlations between original vs cophenetic distances.
cor.CompLin &lt;- cor(UPGMA.dist, macnally.dist)

# Add the correlation to the figure as a text box
legend(&quot;topleft&quot;, # Where to place the legend box.
       legend = paste(&quot;Pearson = &quot;, round(cor.CompLin, 3)), # Legend Text.
       bty = &quot;n&quot; # Type of box to be drawn around the legend.
)</code></pre>
</div>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Plot the cophenetic vs. original distances for the Ward’s clustering
approache.</p>
<p>Also, estimate the correlation between the original and the
cophenetic distances calculated above for the single linkage, complete
linkage, UPGMA, and Ward’s clustering approaches. Add these as insert
text in each panel.</p>
</div>
<div class="tutorial-exercise" data-label="ShepDiag4"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="30">
<pre class="text"><code># Calculate the cophenetic distance for the Ward clustering.
Ward.dist &lt;- cophenetic(______)
# Print the object class of the cophenetic distance
class(Ward.dist)
# Plot the original vs cophenetic for the Ward dendrogram.
  plot(x = ______, # Cophenetic distances.
       y = macnally.dist, # Original distances.
       main = &#39;Cophenetic Correlation\n Ward&#39;# Figure main title.
  )
# Add a 1:1 line
abline(a = 0, b = 1, # Set the intercept (a) and slope (b).
       lty = 1, lwd = 2) # Define the line width and type attributes.

# Add a line representing the smoothed relation between the original vs cophenetic distances
# A Loess model
SmothMod &lt;- lowess(macnally.dist ~ ______)
# Add a line with the Loess model
lines(______, # The Loess model 
      lty = 2, col = &quot;red&quot;, lwd = 2) # Define the line colour, width, and type attributes.

# Estimate the correlations between original vs cophenetic distances.
cor.CompLin &lt;- cor(______, macnally.dist)

# Add the correlation to the figure as a text box
legend(&quot;topleft&quot;, # Where to place the legend box.
       legend = paste(&quot;Pearson = &quot;, round(cor.CompLin, 3)), # Legend Text.
       bty = &quot;n&quot; # Type of box to be drawn around the legend.
)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="ShepDiag4-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Calculate the cophenetic distance for the Ward clustering.
Ward.dist &lt;- cophenetic(Hclus.4)
# Print the object class of the cophenetic distance
class(Ward.dist)
# Plot the original vs cophenetic for the Ward dendrogram.
  plot(x = Ward.dist, # Cophenetic distances.
       y = macnally.dist, # Original distances.
       main = &#39;Cophenetic Correlation\n Ward&#39;# Figure main title.
  )
# Add a 1:1 line
abline(a = 0, b = 1, # Set the intercept (a) and slope (b).
       lty = 1, lwd = 2) # Define the line width and type attributes.

# Add a line representing the smoothed relation between the original vs cophenetic distances
# A Loess model
SmothMod &lt;- lowess(macnally.dist ~ Ward.dist)
# Add a line with the Loess model
lines(SmothMod, # The Loess model 
      lty = 2, col = &quot;red&quot;, lwd = 2) # Define the line colour, width, and type attributes.

# Estimate the correlations between original vs cophenetic distances.
cor.CompLin &lt;- cor(Ward.dist, macnally.dist)

# Add the correlation to the figure as a text box
legend(&quot;topleft&quot;, # Where to place the legend box.
       legend = paste(&quot;Pearson = &quot;, round(cor.CompLin, 3)), # Legend Text.
       bty = &quot;n&quot; # Type of box to be drawn around the legend.
)</code></pre>
</div>
<p>Based on these plots, it becomes clear that the UPGMA approach is the
one that produces cophenetic distances that are both strongly and
linearly related to the original distances. You see that this is the
signal of the best clustering approach as it accurately represents the
original dissimilarities between observations.</p>
</div>
<div
id="section-gower-distance---how-good-is-the-clustering-of-observations"
class="section level2">
<h2>Gower Distance - How good is the clustering of observations?</h2>
<p>Another possible statistic for comparing clustering results is the
<strong>Gower distance</strong>, computed as the sum of squared
differences between the original dissimilarities and cophenetic
distances (<span class="math inline">\(\sum(OrgDist -
CophDist)^2\)</span>). The clustering method that produces the smallest
Gower distance may be seen as the one that provides the best clustering
model of the dissimilarity matrix.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Now you will estimate the <strong>Gower distance</strong> for each of
the four linkage methods (e.g., Single linkage, Complete linkage, UPGMA,
and Ward).</p>
<p>Assess if the cophenetic correlation and Gower distance criteria
designate the same clustering result as the best.</p>
</div>
<div class="tutorial-exercise" data-label="DistCor" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="20">
<pre class="text"><code># Gower distance for the Single linkage clustering
gow.dist.single &lt;- sum((macnally.dist - ______) ^ 2)
gow.dist.single

# Gower distance for the Complete linkage clustering
gow.dist.comp &lt;- sum((macnally.dist - ______) ^ 2)
gow.dist.comp

# Gower distance for the UPGMA clustering
gow.dist.UPGMA &lt;- sum((macnally.dist - ______) ^ 2)
gow.dist.UPGMA

# Gower distance for the Ward clustering
gow.dist.ward &lt;- sum((macnally.dist - ______) ^ 2)
gow.dist.ward</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="DistCor-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Gower distance for the Single linkage clustering
gow.dist.single &lt;- sum((macnally.dist - SingLin.dist) ^ 2)
gow.dist.single

# Gower distance for the Complete linkage clustering
gow.dist.comp &lt;- sum((macnally.dist - CompLin.dist) ^ 2)
gow.dist.comp

# Gower distance for the UPGMA clustering
gow.dist.UPGMA &lt;- sum((macnally.dist - UPGMA.dist) ^ 2)
gow.dist.UPGMA

# Gower distance for the Ward clustering
gow.dist.ward &lt;- sum((macnally.dist - Ward.dist) ^ 2)
gow.dist.ward</code></pre>
</div>
<p>In this case, the cophenetic correlation and Gower distance criteria
designate the UPGMA approach as the best linkage method!</p>
</div>
<div id="section-pruning-a-dendrogramtree" class="section level2">
<h2>Pruning a Dendrogram/Tree</h2>
<p>Now that you have a good candidate for the best linkage algorithm, it
is time to start looking for “interpretable clusters”. This means you
must decide at what level the dendrogram should be cut (it is often
practical to find a level where interpretations are made).</p>
<p>These levels can be defined subjectively by visual examination of the
dendrogram, or you can choose them to fulfil some criteria. In any case,
adding information on the dendrograms or plotting additional details on
the clustering results can be very useful to decide where to “prune”
(i.e. “cut”) the best tree.</p>
<p>To begin, you can use different predefined cut-offs based on a
typical number of groups. For this, you use the <code>cutree()</code>
function, which gives a vector of group memberships. One way to explore
the consequence of alternative “pruning” points is to cut the “best”
dendrogram into a different number of groups.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Using the best clustering algorithm and the splits done above, add
the corresponding group number for tree splits into two (2), three (3),
four (4), and five (5) groups.</p>
<p>Do this by defining the argument <code>labels</code> to the plot
function.</p>
</div>
<div class="tutorial-exercise" data-label="SplitPLot"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="25">
<pre class="text"><code># Plot the best clustering approach (hclust) object, adding the two groups classification as labels.
plot(x = _____, # An object of the type produced by hclust.
     labels = cutree(_____, 2), # A character vector of labels for the tree&#39;s leaves.
     main = &quot;Two groups\n UPGMA&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) 

# Plot the best clustering approach (hclust) object, adding the three groups classification as labels.
plot(x = _____, # An object of the type produced by hclust.
     labels = cutree(_____, 3), # A character vector of labels for the tree&#39;s leaves.
     main = &quot;Three groups\n UPGMA&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) 

# Plot the best clustering approach (hclust) object, adding the four groups classification as labels.
plot(x = _____, # An object of the type produced by hclust.
     labels = cutree(_____, 4), # A character vector of labels for the tree&#39;s leaves.
     main = &quot;Four groups\n UPGMA&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) 

# Plot the best clustering approach (hclust) object, adding the five groups classification as labels.
plot(x = _____, # An object of the type produced by hclust.
     labels = cutree(_____, 5), # A character vector of labels for the tree&#39;s leaves.
     main = &quot;Five groups\n UPGMA&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) </code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="SplitPLot-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Plot the best clustering approach (hclust) object, adding the two groups classification as labels.
plot(x = Hclus.3, # An object of the type produced by hclust.
     labels = cutree(Hclus.3, 2), # A character vector of labels for the tree&#39;s leaves.
     main = &quot;Two groups\n UPGMA&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) 

# Plot the best clustering approach (hclust) object, adding the three groups classification as labels.
plot(x = Hclus.3, # An object of the type produced by hclust.
     labels = cutree(Hclus.3, 3), # A character vector of labels for the tree&#39;s leaves.
     main = &quot;Three groups\n UPGMA&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) 

# Plot the best clustering approach (hclust) object, adding the four groups classification as labels.
plot(x = Hclus.3, # An object of the type produced by hclust.
     labels = cutree(Hclus.3, 4), # A character vector of labels for the tree&#39;s leaves.
     main = &quot;Four groups\n UPGMA&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) 

# Plot the best clustering approach (hclust) object, adding the five groups classification as labels.
plot(x = Hclus.3, # An object of the type produced by hclust.
     labels = cutree(Hclus.3, 5), # A character vector of labels for the tree&#39;s leaves.
     main = &quot;Five groups\n UPGMA&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) </code></pre>
</div>
<p>Although it is practical to see where each group is, the plots shown
above do not tell you how many groups make sense to have. For this, you
will need to use more “quantitative” approaches.</p>
</div>
<div id="section-fusion-level-plots" class="section level2">
<h2>Fusion Level plots</h2>
<p>One of these quantitative approaches to determine how many groups
make sense is to graph the Fusion Level Values. Fusion Level Values show
the dissimilarity values where the fusion between two branches of a
dendrogram occurs. This means plotting the node height (that you can
extract from the <code>height</code> slot on a <code>hclust()</code>
created object) and the number of clusters.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Plot the fusion level values of the best clustering approach.</p>
</div>
<div class="tutorial-exercise" data-label="FusionPlt"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="20">
<pre class="text"><code># Plot the fusion level values of the best clustering approach
plot(x = ______$______, # The clustering height: that is, the value of the criterion associated with the clustering method for the particular agglomeration.
     y = nrow(______):2, # Fusion Node.
     type = &quot;S&quot;, # type of plot desired? = stair steps.
     main = &quot;Fusion levels - UPGMA&quot;, # Main title.
     ylab = &quot;k (number of clusters)&quot;, # Y-lab label.
     xlab = &quot;h (node height)&quot;, # x-lab label.
     col = &quot;grey&quot;, lwd = 2 # Line piloting arguments. 
     )

# Use the text() function to define the Fusions level of each brake
text(x = ______$______, # The clustering height: that is, the value of the criterion associated with the clustering method for the particular agglomeration.
     y = nrow(macnally):2, # Fusion Node.
     labels = nrow(macnally):2, # Fusion Node.
     col = &quot;red&quot;, cex = 0.8 # Text colour and size?
     )</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="FusionPlt-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Plot the fusion level values of the best clustering approach
plot(x = Hclus.3$height, # The clustering height: that is, the value of the criterion associated with the clustering method for the particular agglomeration.
     y = nrow(macnally):2, # Fusion Node.
     type = &quot;S&quot;, # type of plot desired? = stair steps.
     main = &quot;Fusion levels - UPGMA&quot;, # Main title.
     ylab = &quot;k (number of clusters)&quot;, # Y-lab label.
     xlab = &quot;h (node height)&quot;, # x-lab label.
     col = &quot;grey&quot;, lwd = 2 # Line piloting arguments. 
     )

# Use the text() function to define the Fusions level of each brake
text(x = Hclus.3$height, # The clustering height: that is, the value of the criterion associated with the clustering method for the particular agglomeration.
     y = nrow(macnally):2, # Fusion Node.
     labels = nrow(macnally):2, # Fusion Node.
     col = &quot;red&quot;, cex = 0.8 # Text colour and size?
     )</code></pre>
</div>
<p>Based on the Fusion Level Values, you should cut the dendrogram at
four (4) groups - the point where the plot starts to show a steep and
increasing slope.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Plot the best clustering algorithm defining the corresponding group
number based on the number of groups defined above.</p>
<p>Do this by defining the argument <code>labels</code> to the plot
function.</p>
</div>
<div class="tutorial-exercise" data-label="BstNbrGrp"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Plot the best clustering approach (hclust) object, adding the best-number of groups classification as labels.
plot(x = ______, # An object of the type produced by hclust.
     labels = cutree(______, 4), # A character vector of labels for the tree&#39;s leaves.
     main = &quot;Four groups\n UPGMA&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) </code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="BstNbrGrp-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Plot the best clustering approach (hclust) object, adding the best-number of groups classification as labels.
plot(x = Hclus.3, # An object of the type produced by hclust.
     labels = cutree(Hclus.3, 4), # A character vector of labels for the tree&#39;s leaves.
     main = &quot;Four groups\n UPGMA&quot;, # Main title.
     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.
     ) </code></pre>
</div>
</div>
<div id="section-choosing-the-number-of-clusters"
class="section level2">
<h2>Choosing the number of clusters</h2>
<p>For this practical, you will use six (6) clusters for the final group
diagnostic matching the original habitat types and the UPGMA linkage
approach.</p>
<p>With this criterion, you can examine if the group memberships are
appropriate (i.e. no or few objects misclassified). A silhouette plot is
useful here.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Define the optimal number of clusters according to matrix correlation
statistics and the <code>grpdist()</code> function.</p>
</div>
<div class="tutorial-exercise" data-label="FinNbClus"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="20">
<pre class="text"><code># Choose the number of clusters
k &lt;- _____
# Prune the UPGMA tree into six groups
UPGMA.6groups &lt;- cutree(tree = _____, # A tree as produced by hclust.
                        k = k # Desired number of groups.
                        )
# Compute silhouette information according to a given clustering in k clusters
sil &lt;- silhouette(x = _____, # Vector with k different integer cluster codes.
                  dist = macnally.dist # Original a dissimilarity object.
                  )
# give the names to sil based on of sites
rownames(sil) &lt;- row.names(macnally.clean)

# Silhouette plot of the final partition
plot(x = _____, # The silhouette object
     main = &quot;Silhouette plot - Bray Curtis - UPGMA&quot;, # Main tytle
     cex.names = 0.8, # Size of text
     col = 2:(k + 1) # Bar colours (one per group)
     )</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="FinNbClus-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Choose the number of clusters
k &lt;- 6
# Prune the UPGMA tree into six groups
UPGMA.6groups &lt;- cutree(tree = Hclus.3, # A tree as produced by hclust.
                        k = k # Desired number of groups.
                        )
# Compute silhouette information according to a given clustering in k clusters
sil &lt;- silhouette(x = UPGMA.6groups, # Vector with k different integer cluster codes.
                  dist = macnally.dist # Original a dissimilarity object.
                  )
# give the names to sil based on of sites
rownames(sil) &lt;- row.names(macnally.clean)

# Silhouette plot of the final partition
plot(x = sil, # The silhouette object
     main = &quot;Silhouette plot - Bray Curtis - UPGMA&quot;, # Main tytle
     cex.names = 0.8, # Size of text
     col = 2:(k + 1) # Bar colours (one per group)
     )</code></pre>
</div>
<p>The silhouette width plot of the UPGMA tree pruned into six groups
show that clusters 2, 4, and 6 are the most coherent. In contrast,
cluster 3 contains some misclassified objects.</p>
</div>
<div
id="section-non-metric-dimensional-scaling-of-the-variation-and-forest-bird-assemblages"
class="section level2">
<h2>(Non-)Metric Dimensional Scaling of the variation and forest bird
assemblages</h2>
<p>In this section, you will work on the ordination of observations
based on a distance matrix. There are two approaches for this; both
focus on organising the objects in a small number of axes. The first
approach is focused on preserving the exact dissimilarities among
objects is metric dimensional scaling. The second is focused on
representing (as well as possible) the ordering relationships in a
specified number of axes non-metric multidimensional scaling.</p>
</div>
<div id="section-metric-dimensional-scaling" class="section level2">
<h2>Metric Dimensional Scaling</h2>
<p>In the case of metric dimensional scaling, the objective is to
provide a Euclidean representation of a set of objects whose
relationships are measured by any dissimilarity measure chosen by the
user. Principal Coordinate Analysis (PCoA) represents the relationships
among the objects based upon the assessed variables and measured through
the defined distance. This would not be possible with ordination
approaches based on correlations/covariances (PCA) or the <span
class="math inline">\(\chi^2\)</span>-distance (CA).</p>
<p>Like PCA and CA, PCoA produces a set of orthogonal axes whose
importance is measured by eigenvalues. For representing the
relationships among objects, sites or variables, the used distance must
be “Euclidean”, as this avoids producing negative eigenvalues (you
cannot represent negative eigenvalues on real ordination axes since they
are complex).</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>The best first step when building a PCoA is to assess if the distance
is Euclidean. For this, you will use the <code>is.euclid()</code>
function from the <code>ade4</code> package.</p>
</div>
<div class="tutorial-exercise" data-label="iseuclid1"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Is macnally.dist Euclidean?
_______(macnally.dist)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="iseuclid1-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Is macnally.dist Euclidean?
is.euclid(macnally.dist)</code></pre>
</div>
<p>The test confirms that <code>macnally.dist</code> is
<strong>NOT</strong> Euclidean, which is expected as it is built based
on the “Bray-Curtis” distance that fails to satisfy the triangle
inequality.</p>
<p>To solve this, you can either use a <em>Lingoes</em> (adding a
constant value to the squared dissimilarities) or <em>Cailliez</em>
(adding a constant value to the dissimilarities) specification.
Alternately, you can use a square root transformation - this is the
approach you will use to build the PCoA later on.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Make the <code>macnally.dist</code> distance matrix Euclidean by
using a :</p>
<ul>
<li><p>Lingoes correction: Adding a constant value to the squared
dissimilarities.</p></li>
<li><p>Cailliez correction: Adding a constant value to the
dissimilarities.</p></li>
<li><p>Square root transformation: Square root the
dissimilarities.</p></li>
</ul>
<p>After you do these, assess if these transformed dissimilarity
matrices are Euclidean.</p>
</div>
<div class="tutorial-exercise" data-label="iseuclid2"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="20">
<pre class="text"><code>## Lingoes correction
macnally.dist.Ling &lt;- sqrt(_____)+1
# Is it euclidean?
_____(macnally.dist.Ling)

## Cailliez correction
macnally.dist.Cail &lt;- _____+1
# Is it euclidean?
_____(macnally.dist.Cail)

## Sqrt correction
macnally.dist.Sqrt &lt;- sqrt(_____)
# Is it euclidean?
_____(macnally.dist.Sqrt)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="iseuclid2-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>## Lingoes correction
macnally.dist.Ling &lt;- sqrt(macnally.dist)+1
# Is it euclidean?
is.euclid(macnally.dist.Ling)

## Cailliez correction
macnally.dist.Cail &lt;- macnally.dist+1
# Is it euclidean?
is.euclid(macnally.dist.Cail)

## Sqrt correction
macnally.dist.Sqrt &lt;- sqrt(macnally.dist)
# Is it euclidean?
is.euclid(macnally.dist.Sqrt)</code></pre>
</div>
<p>Now that <code>macnally.dist</code> has been made Euclidean, it is
possible to build a PCoA to define a series of ordination axes. For
this, you use the function <code>cmdscale()</code> from the
<code>vegan</code> package, or the function <code>pcoa()</code> from the
<code>ape</code> package. The axes of a PCoA can be interpreted as those
of a PCA or CA. Therefore, the proximity of objects in the ordination
represents their similarity in the sense of the association measure
used.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Build a PCoA to using your the Euclidean distances based on the Sqrt
correction (<code>macnally.dist.Sqrt</code>).</p>
<p>For this, use the function <code>pcoa()</code> from the
<code>ape</code> package.</p>
</div>
<div class="tutorial-exercise" data-label="PCoAV2" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code># PCoA using pcoa - see that the number of PCoA assess to be extracted is defined
macnally.pcoa.V2 &lt;- pcoa(__________,# An Euclidean distance matrix. 
                         correction = &quot;none&quot; # How to correct the distance matrix?
                         )

# Print the structure of the object created with the pcoa() function.
str(macnally.pcoa.V2)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="PCoAV2-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># PCoA using pcoa - see that the number of PCoA assess to be extracted is defined
macnally.pcoa.V2 &lt;- pcoa(macnally.dist.Sqrt,# An Euclidean distance matrix. 
                         correction = &quot;none&quot; # How to correct the distance matrix?
                         )

# Print the structure of the object created with the pcoa() function.
str(macnally.pcoa.V2)</code></pre>
</div>
<p>You built a PCoA with 36-PCoA axes. The question is now how many
ordination axes are meant to display and interpret. For this, you need
to examine the eigenvalues and decide how many axes are worth
representing and displaying based on the amount of variance
explained.</p>
</div>
<div id="section-meaningful-axes-in-a-pcoa" class="section level2">
<h2>Meaningful Axes in a PCoA</h2>
<p>The decision can be completely arbitrary (for instance, interpret the
number of axes necessary to represent 75% of the variance in the data)
or assisted by one of several procedures. One of these procedures
consists of computing a broken stick model, which randomly divides a
stick of unit length into the same number of pieces as there are PCoA
eigenvalues. The pieces are then put in order of decreasing lengths and
compared to the eigenvalues. One interprets only the axes whose sum of
eigenvalues are larger than the cumulative proportion predicted by the
broken stick model (or PCoA eigenvalues are larger than the length of
the corresponding piece of the stick).</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Plot the cumulative relative eigenvalues/variance of the PCoA (as a
barplot) and the respective Cumulative broken stick fractions (as an
added line).</p>
<p>Define the LAST PCoA axis where the observed cumulative variance is
larger than that of a broken stick model</p>
</div>
<div class="tutorial-exercise" data-label="CumeigeValPlt"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="30">
<pre class="text"><code># Extract the Cumulative relative eigenvalues/variance.
macnally.CumulEig &lt;- _________$ values$Cumul_eig

## Plot the cumulative eigenvalues/variance. 
macnally.barplot &lt;- barplot(_________) 

## Add the y-axes names
text(x = as.numeric(_________)-0.5, # X-axis location.
     y = rep(0, length(macnally.CumulEig)), # Y-axis location.
     labels = paste(1:length(macnally.CumulEig), &quot;PCoA&quot;, sep = &quot;_&quot;), # Text
     srt = 45, xpd = NA, cex = 0.5, # Text arguments: angle (srt), plot in the full area (xpd), size of the text
     pos = 1 # Position specifier for the text.
     )

# Add the Broken Stick expectation as a line

# Extract the Cumulative broken stick fractions
macnally.CumulBrStick &lt;-_________$ values$Cumul_br_stick

# Add the Cumulative broken stick fractions as a line
lines(x = macnally.barplot, # X-axis position.
      y = _________, # Y-axis = Cumulative broken stick fractions
      type = &quot;o&quot;, # type of plot desired = overplotted points and lines
      col = &quot;red&quot; # colour
      )

## Define the LAST PCoA axis where the observed cumulative variance is larger than that of a broken stick model
max(which(_________&gt;_________))</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support"
data-label="CumeigeValPlt-solution" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code># Extract the Cumulative relative eigenvalues/variance.
macnally.CumulEig &lt;- macnally.pcoa.V2$ values$Cumul_eig

## Plot the cumulative eigenvalues/variance. 
macnally.barplot &lt;- barplot(macnally.CumulEig) 

## Add the y-axes names
text(x = as.numeric(macnally.barplot)-0.5, # X-axis location.
     y = rep(0, length(macnally.CumulEig)), # Y-axis location.
     labels = paste(1:length(macnally.CumulEig), &quot;PCoA&quot;, sep = &quot;_&quot;), # Text
     srt = 45, xpd = NA, cex = 0.5, # Text arguments: angle (srt), plot in the full area (xpd), size of the text
     pos = 1 # Position specifier for the text.
     )

# Add the Broken Stick expectation as a line

# Extract the Cumulative broken stick fractions
macnally.CumulBrStick &lt;-macnally.pcoa.V2$ values$Cumul_br_stick

# Add the Cumulative broken stick fractions as a line
lines(x = macnally.barplot, # X-axis position.
      y = macnally.CumulBrStick, # Y-axis = Cumulative broken stick fractions
      type = &quot;o&quot;, # type of plot desired = overplotted points and lines
      col = &quot;red&quot; # colour
      )

## Define the LAST PCoA axis where the observed cumulative variance is larger than that of a broken stick model
max(which(macnally.CumulEig&gt;macnally.CumulBrStick))</code></pre>
</div>
<p>Based on the results above, it is clear that at least 10 PCoA-axes
are needed. These would represent ~63% of the variability in the
data.</p>
</div>
<div id="section-ploting-a-pcoa" class="section level2">
<h2>Ploting a PCoA</h2>
<p>Remember that ordinations are not statistical tests but heuristic
procedures with no hypothesis being tested. So, the goal here is to
describe the relative position of observations in a reduced space. With
that in mind, you now build biplots of sites and variables for the first
two PCoA axes. you can either use a PCoA built using the
<code>cmdscale()</code> or <code>pcoa()</code> functions.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Using <code>macnally.pcoa.V2</code> (that is the output of using the
<code>pcoa()</code> function), you will now create the biplot for the
PCoA using the function <code>biplot.pcoa()</code> from the
<code>ape</code> package.</p>
</div>
<div class="tutorial-exercise" data-label="PCoAV2plot"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Biplots based on pcoa
biplot.pcoa(x = ________, # Output object from pcoa
            Y = macnally.clean, # Variables to be projected onto the ordination plot
            main = &quot;PCoA Biplot\n Response variables Projected as in PCA&quot; # Main title
            )
# Add a vertical and horizontal doted line at 0.
abline(h = 0, v = 0, lty = 3)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="PCoAV2plot-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Biplots based on pcoa
biplot.pcoa(x = macnally.pcoa.V2, # Output object from pcoa
            Y = macnally.clean, # Variables to be projected onto the ordination plot
            main = &quot;PCoA Biplot\n Response variables Projected as in PCA&quot; # Main title
            )
# Add a vertical and horizontal doted line at 0.
abline(h = 0, v = 0, lty = 3)</code></pre>
</div>
<p>The plot above show how the different sites (in black) and species
(in red) are arranged in the PCoA space. Like with a PCA, the
interpretation of sites relative positions is based on the position in
the represented PCoA space. The farther left/right a site is, the more
the site is mainly composed of species aligned with that axis.</p>
</div>
<div id="section-merging-clustere-and-ordination-analyses"
class="section level2">
<h2>Merging clustere and ordination analyses</h2>
<p>You can also use the clustering results generated in the first
section to define the group composition with the PCoA
<code>biplot()</code> function. For this, you will also use the
<code>ordihull()</code> function from the <code>vegan</code> package to
view how the “clusters” defined using classification analyses match the
position of each site in a reduced space.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Using the PCoA object generated using either the
<code>cmdscale()</code> OR the <code>pcoa()</code> functions, group the
observations based on the six (6) clusters defined using an average
clustering.</p>
<p>For this, use the <code>ordihull()</code> function of the
<code>vegan</code> package to add polygons that enclose each
cluster.</p>
</div>
<div class="tutorial-exercise" data-label="ObsByClust2"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="20">
<pre class="text"><code># Plot the PCoA space generated using the pcoa() function. 
biplot(x = ________, # Output object from pcoa
       main = &quot;PCoA with species weighted averages&quot; # Main title
       )

# Add a vertical and horizontal doted line at 0.
abline(h = 0, v = 0, lty = 3)

# Plot polygons grouping observations by cluster.
macnally.pcoa.V1 &lt;- cmdscale(d = macnally.dist.Sqrt,
                             k = (nrow(macnally.clean) - 1), eig = TRUE)
ordihull(ord = ________, # A result from an ordination.
         choices = c(1, 2), # Axes shown.
         groups = cutree(________, 6), # Factor giving the groups for which the graphical item is drawn
         draw = &quot;polygon&quot;, # ow should objects be represented on the plot? (lines or polygon )
         col = 1:6 # Colour for each group.
         )</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="ObsByClust2-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Plot the PCoA space generated using the pcoa() function. 
biplot(x = macnally.pcoa.V2, # Output object from pcoa
       main = &quot;PCoA with species weighted averages&quot; # Main title
       )

# Add a vertical and horizontal doted line at 0.
abline(h = 0, v = 0, lty = 3)

# Plot polygons grouping observations by cluster.
macnally.pcoa.V1 &lt;- cmdscale(d = macnally.dist.Sqrt,
                             k = (nrow(macnally.clean) - 1), eig = TRUE)
ordihull(ord = macnally.pcoa.V1, # A result from an ordination.
         choices = c(1, 2), # Axes shown.
         groups = cutree(Hclus.3, 6), # Factor giving the groups for which the graphical item is drawn
         draw = &quot;polygon&quot;, # ow should objects be represented on the plot? (lines or polygon )
         col = 1:6 # Colour for each group.
         )</code></pre>
</div>
</div>
<div id="section-non-metric-dimensional-scaling" class="section level2">
<h2>Non-metric dimensional Scaling</h2>
<p>The goal of NMDS is to represent the original position of communities
in multidimensional space as accurately as possible using a reduced
number of dimensions that can be easily plotted and visualised.</p>
<p>Like PCoA, NMDS can produce ordinations of objects from any
dissimilarity matrix. However, NMDS is not an eigenvalue technique, and
it does not maximise the variability associated with individual axes of
the ordination. As a result, plots may arbitrarily be rotated or
inverted. This also means that the results have to be considered within
the context of the predefined number of axes. For a given and small
number of axes (e.g. m = 2 or 3), NMDS often achieves a less deformed
representation of the dissimilarity relationships among objects than a
PCoA in the same number of dimensions. However, NMDS is a
compute-intensive, iterative technique exposed to the risk of suboptimal
solutions. Indeed, the stress function often reaches a local minimum
larger than the global, true minimum.</p>
</div>
<div id="section-executing-nmds" class="section level2">
<h2>Executing NMDS</h2>
<p>NMDS can be performed in <code>R</code> with the elegant function
<code>metaMDS()</code> of the <code>vegan</code> package.
<code>metaMDS()</code> accepts raw data or dissimilarity matrices. A
dissimilarity index needs to be provided using the argument
<code>distance</code> if raw data is provided.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Using the raw community data in <code>macnally.clean</code>, you will
build an NMDS with two dimensions, using 20 random starts.</p>
</div>
<div class="tutorial-exercise" data-label="NMDSv1" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="0">
<pre class="text"><code># NMDS using the raw data matrix
set.seed(99) # To ensure the results match those below
macnally.MDS.V1 &lt;- metaMDS(comm = ___________, # Community data. 
                           k = 2, # Number of dimensions.
                           distance = &quot;bray&quot;, # Dissimilarity index used?
                           try = ___________, # Minimum numbers of random starts?
                           trace = 0 # Added to avoid printing the procedure
                           )
macnally.MDS.V1</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="NMDSv1-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># NMDS using the raw data matrix
set.seed(99) # To ensure the results match those below
macnally.MDS.V1 &lt;- metaMDS(comm = macnally.clean, # Community data. 
                           k = 2, # Number of dimensions.
                           distance = &quot;bray&quot;, # Dissimilarity index used?
                           try = 20, # Minimum numbers of random starts?
                           trace = 0 # Added to avoid printing the procedure
                           )
macnally.MDS.V1</code></pre>
</div>
<p>With <code>trace = 1</code>, you would see each iteration of the NMDS
until a solution is reached (i.e. stress was minimised after some number
of reconfigurations of the points in 2 dimensions). You can increase the
number of default iterations using the argument <code>trymax</code>,
which may help alleviate issues of non-convergence.</p>
<p>If you print the object created using <code>metaMDS()</code>, you
will see a value called stress that denotes the squared differences
between original and new distances.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Extract the stress value for your two axes NMDS.</p>
<p>You can extract this value using the subscript
<code>stress</code>.</p>
</div>
<div class="tutorial-exercise" data-label="NMDSstress"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Extract the from the NMDS
macnally.MDS.V1$________</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="NMDSstress-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Extract the from the NMDS
macnally.MDS.V1$stress</code></pre>
</div>
<p>As a rule of thumb, an NMDS ordination with a stress value around or
above 0.2 is deemed suspicious, and a stress value approaching 0.3
indicates that the ordination is arbitrary. Stress values equal to or
below 0.1 are considered fair, while values equal to or below 0.05
indicating a good fit. Allowing the algorithm to ordinate in more
dimensions can reduce the stress value. However, allowing more than
three dimensions makes interpretations more challenging.</p>
<p>To visualise what is measured in the “stress” metric, you can use
<strong>Shepard-plots</strong>, which show scatter around the regression
between the interpoint distances in the final configuration (i.e. the
distances between each pair of communities) against their original
dissimilarities. Large scatter around the line suggests that original
dissimilarities are not well preserved in the reduced number of
dimensions. Looks pretty good in this case.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Fit and Shepard Plot for your Non-metric Multidimensional Scaling
using the <code>stressplot()</code> function.</p>
</div>
<div class="tutorial-exercise" data-label="StressPlot"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Shepard Plot
_________(object = macnally.MDS.V1, # The metaMDS model
           pch = 19 , lty = 2# Point and line arguments
           )</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="StressPlot-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Shepard Plot
stressplot(object = macnally.MDS.V1, # The metaMDS model
           pch = 19 , lty = 2# Point and line arguments
           )</code></pre>
</div>
<p>In the example here, the stress value is 0.118 - that is borderline
fair. However, increasing the number of axes cold improve the stress
value.</p>
</div>
<div id="section-how-many-dimensions--1" class="section level2">
<h2>How many Dimensions? -1</h2>
<p>Plotting the observed stress values against the number of dimensions
used in a series of NMDS runs can guide selecting an appropriate number
of dimensions. One way to do this is to plot the stress values of
several runs of an NMDS algorithm allowing for different axes/dimensions
numbers. These are Shepard stress plots. As an example, you can do this
for 19 different configurations (That is, from 2 to 20 axes)</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Define the stress value for 19 different NMDS configurations.</p>
</div>
<div class="tutorial-exercise" data-label="NMDSV2" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="30">
<pre class="text"><code># Define the stress value for 19 different configurations From 2 to 20 groups
stressplot.Bct &lt;- sapply(2:20,
                         function(k){
                            NMDSTemp &lt;- _______(comm = macnally.dist, # Dissimilarities
                                                k = _______, # Number of dimensions.
                                                try = 20, # Minimum numbers of random starts?
                                                trace = 0 # Added to avoid printing the procedure
                                                )
                            NMDSTemp$stress # Extract the from the NMDS object.
                           })

## plot the Shepard stress plot
plot(x = 2:20, # Number of axes
     y = _______, # Stress value
     type = &quot;o&quot;, # Plot type
     pch = 19, # Type of point.
     col = &quot;red&quot;, # Colour fo the point.
     ylab = &quot;Stress&quot;, # Y-axis label.
     xlab = &quot;Number of dimensions&quot;# X-axis label.
     )

# Add the 0.1 critical value line
abline(h = 0.1, # The y-value(s) for horizontal line(s).
       lty = 3, lwd = 2 # Line width and type arguments.
       )
# Add the 0.05 critical value line
abline(h = 0.05, # The y-value(s) for horizontal line(s).
       lty = 4, lwd = 2 # Line width and type arguments.
       )

# Add a legend indicating the line type for each critical value
legend(&quot;topright&quot;, # Position the legend?
       lty = c(3,2), # The type of lines for each class.
       legend = c(0.1,0.5), # The Text for each class in in the legend.
       title = &quot;Critical Values&quot; # Main title
       )</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="NMDSV2-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Define the stress value for 19 different configurations From 2 to 20 groups
stressplot.Bct &lt;- sapply(2:20,
                         function(k){
                            NMDSTemp &lt;- metaMDS(comm = macnally.dist, # Dissimilarities
                                                k = k, # Number of dimensions.
                                                try = 20, # Minimum numbers of random starts?
                                                trace = 0 # Added to avoid printing the procedure
                                                )
                            NMDSTemp$stress # Extract the from the NMDS object.
                           })

## plot the Shepard stress plot
plot(x = 2:20, # Number of axes
     y = stressplot.Bct, # Stress value
     type = &quot;o&quot;, # Plot type
     pch = 19, # Type of point.
     col = &quot;red&quot;, # Colour fo the point.
     ylab = &quot;Stress&quot;, # Y-axis label.
     xlab = &quot;Number of dimensions&quot;# X-axis label.
     )

# Add the 0.1 critical value line
abline(h = 0.1, # The y-value(s) for horizontal line(s).
       lty = 3, lwd = 2 # Line width and type arguments.
       )
# Add the 0.05 critical value line
abline(h = 0.05, # The y-value(s) for horizontal line(s).
       lty = 4, lwd = 2 # Line width and type arguments.
       )

# Add a legend indicating the line type for each critical value
legend(&quot;topright&quot;, # Position the legend?
       lty = c(3,2), # The type of lines for each class.
       legend = c(0.1,0.5), # The Text for each class in in the legend.
       title = &quot;Critical Values&quot; # Main title
       )</code></pre>
</div>
</div>
<div id="section-how-many-dimensions---2" class="section level2">
<h2>How many Dimensions? - 2</h2>
<p>In the illustrated case, attempting an ordination with one or two
NMDS axes yields unacceptably high stress, whereas three to five
dimensions seems adequate (stress below 0.1). However, only after six
axes are used, the stress levels are so that you can consider the
ordination to have a good fit (stress below 0.05). Adding more
dimensions after six can lead to drops in the stress value, but the
subsequent gains are very small.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Plot, as a barplot, the relative change in stress as a function of
the number of used axes.</p>
</div>
<div class="tutorial-exercise" data-label="StrChng" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="20">
<pre class="text"><code>## Define the change in stress as the number of axes increase
StressChng &lt;- stressplot.Bct[1:18] - stressplot.Bct[2:19]
## Plot the relative change in stress
StressChngBrPlt &lt;- barplot(height = _________, # matrix of values describing the bars.
                           names.arg = paste(2:18, 3:20, sep = &quot;to&quot;), # A vector of names to be plotted below each bar.
                           xlab = &quot;Change in dimensions&quot;, # X-axis label.
                           ylab = &quot;Change in stress&quot;,# y-axis label.
                           las = 2 # Axis text orientation.
                           )
# Add a line showing the change in cumulative stress 
lines(x = _________, # X-axis position.
      y = _________, # Cumulative stress.
      type = &quot;b&quot;, # Type of plot.
      pch = 19, # Point type.
      col = &quot;red&quot;, #Point/line colour.
      lwd = 3) # Line Arguments.</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="StrChng-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>## Define the change in stress as the number of axes increase
StressChng &lt;- stressplot.Bct[1:18] - stressplot.Bct[2:19]
## Plot the relative change in stress
StressChngBrPlt &lt;- barplot(height = StressChng, # matrix of values describing the bars.
                           names.arg = paste(2:18, 3:20, sep = &quot;to&quot;), # A vector of names to be plotted below each bar.
                           xlab = &quot;Change in dimensions&quot;, # X-axis label.
                           ylab = &quot;Change in stress&quot;,# y-axis label.
                           las = 2 # Axis text orientation.
                           )
# Add a line showing the change in cumulative stress 
lines(x = StressChngBrPlt, # X-axis position.
      y = StressChng, # Cumulative stress.
      type = &quot;b&quot;, # Type of plot.
      pch = 19, # Point type.
      col = &quot;red&quot;, #Point/line colour.
      lwd = 3) # Line Arguments.</code></pre>
</div>
<p>When the stress plots of the first and final NMDS are compared, it is
clear that the first configuration performed OK but had a larger scatter
around the trend-line than the configuration with six (6) axes.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Build the optimal NMDS using the minimum number of axes that make the
stress be below 0.05.</p>
<p>Compare the stress plot of the NMDS using the optimal number of axes
to one using only two (2) axes. Here, add the stress value for each
configuration to the main figure title as text.</p>
</div>
<div class="tutorial-exercise" data-label="NMDSBest" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="25">
<pre class="text"><code># Define the Number of axes to use
kUse &lt;- min(which(stressplot.Bct&lt;0.05))

# Print the stress value for the selected number of axes. 
stressplot.Bct[_______]

# Build the final NMDS
macnally.MDS.V3 &lt;- metaMDS(comm = macnally.dist, # Dissimilarities
                           k = _______+1, # Number of dimensions.
                           try = 20, # Minimum numbers of random starts?
                           trace = 0 # Added to avoid printing the procedure
                           )

# Make a stressplot of the final NMDS 
# Add the stress value to the figure main title.
stressplot(object = _______,
           main = paste0(&quot;NMDS with 6 axes\n Stress =&quot;,
                          round(macnally.MDS.V3$stress,3)))

# Make a stressplot of the NMDS  with 2 axes.
# Add the stress value to the figure main title.
stressplot(object = macnally.MDS.V1,
           main = paste0(&quot;NMDS with 2 axes\n Stress =&quot;,
                          round(macnally.MDS.V1$stress,3))
           )</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="NMDSBest-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Define the Number of axes to use
kUse &lt;- min(which(stressplot.Bct&lt;0.05))

# Print the stress value for the selected number of axes. 
stressplot.Bct[kUse]

# Build the final NMDS
macnally.MDS.V3 &lt;- metaMDS(comm = macnally.dist, # Dissimilarities
                           k = kUse+1, # Number of dimensions.
                           try = 20, # Minimum numbers of random starts?
                           trace = 0 # Added to avoid printing the procedure
                           )

# Make a stressplot of the final NMDS 
# Add the stress value to the figure main title.
stressplot(object = macnally.MDS.V3,
           main = paste0(&quot;NMDS with 6 axes\n Stress =&quot;,
                          round(macnally.MDS.V3$stress,3)))

# Make a stressplot of the NMDS  with 2 axes.
# Add the stress value to the figure main title.
stressplot(object = macnally.MDS.V1,
           main = paste0(&quot;NMDS with 2 axes\n Stress =&quot;,
                          round(macnally.MDS.V1$stress,3))
           )</code></pre>
</div>
</div>
<div id="section-ploting-an-ndms" class="section level2">
<h2>PLoting an NDMS</h2>
<p>Now that the optimal number of axes has been defined, you can plot
the NMDS space. This, like in PCA or PCoA, is done using the
<code>plot()</code> function.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Build an NMDS with three (3) axes, as it is a fair representation
that makes the visualisation simpler.</p>
<p>After that, plot the position of the site across the combinations of
axes.</p>
</div>
<div class="tutorial-exercise" data-label="NMDSPlot" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="30">
<pre class="text"><code>## Build the NMDS with 3 axes
macnally.MDS.V4 &lt;- metaMDS(comm = macnally.clean, # Community data. 
                           k = 3, # Number of dimensions.
                           distance = &quot;bray&quot;, # Dissimilarity index used?
                           try = 20, # Minimum numbers of random starts?
                           trace = 0 # Added to avoid printing the procedure
                           )

# plot the first and second  NMDS axes
plot(____________, # The NMDS object 
     display = c(&quot;species&quot;, &quot;sites&quot;), # Display &quot;sites&quot; AND &quot;species&quot;.
     choices = c(____________, ____________), # Axes shown
     type = &quot;p&quot;, # Plot type: &quot;p&quot; for points, &quot;t&quot; for text, and &quot;n&quot; for axes only.
     main = c(&quot;NMDS axes 1 and 2&quot;) # main Title
     )

# Plot the first and third two NMDS axes
plot(____________, # The NMDS object 
     display = c(&quot;species&quot;, &quot;sites&quot;), # Display &quot;sites&quot; AND &quot;species&quot;.
     choices = c(____________, ____________), # Axes shown
     type = &quot;p&quot;, # Plot type: &quot;p&quot; for points, &quot;t&quot; for text, and &quot;n&quot; for axes only.
     main = c(&quot;NMDS axes 1 and 3&quot;) # main Title
     )

# Plot the second and third two NMDS axes
plot(____________, # The NMDS object 
     display = c(&quot;species&quot;, &quot;sites&quot;), # Display &quot;sites&quot; AND &quot;species&quot;.
     choices = c(____________, ____________), # Axes shown
     type = &quot;p&quot;, # Plot type: &quot;p&quot; for points, &quot;t&quot; for text, and &quot;n&quot; for axes only.
     main = c(&quot;NMDS axes 2 and 3&quot;) # main Title
     )</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="NMDSPlot-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>## Build the NMDS with 3 axes
macnally.MDS.V4 &lt;- metaMDS(comm = macnally.clean, # Community data. 
                           k = 3, # Number of dimensions.
                           distance = &quot;bray&quot;, # Dissimilarity index used?
                           try = 20, # Minimum numbers of random starts?
                           trace = 0 # Added to avoid printing the procedure
                           )

# plot the first and second  NMDS axes
plot(macnally.MDS.V4, # The NMDS object 
     display = c(&quot;species&quot;, &quot;sites&quot;), # Display &quot;sites&quot; AND &quot;species&quot;.
     choices = c(1, 2), # Axes shown
     type = &quot;p&quot;, # Plot type: &quot;p&quot; for points, &quot;t&quot; for text, and &quot;n&quot; for axes only.
     main = c(&quot;NMDS axes 1 and 2&quot;) # main Title
     )

# Plot the first and third two NMDS axes
plot(macnally.MDS.V4, # The NMDS object 
     display = c(&quot;species&quot;, &quot;sites&quot;), # Display &quot;sites&quot; AND &quot;species&quot;.
     choices = c(1, 3), # Axes shown
     type = &quot;p&quot;, # Plot type: &quot;p&quot; for points, &quot;t&quot; for text, and &quot;n&quot; for axes only.
     main = c(&quot;NMDS axes 1 and 3&quot;) # main Title
     )

# Plot the second and third two NMDS axes
plot(macnally.MDS.V4, # The NMDS object 
     display = c(&quot;species&quot;, &quot;sites&quot;), # Display &quot;sites&quot; AND &quot;species&quot;.
     choices = c(2, 3), # Axes shown
     type = &quot;p&quot;, # Plot type: &quot;p&quot; for points, &quot;t&quot; for text, and &quot;n&quot; for axes only.
     main = c(&quot;NMDS axes 2 and 3&quot;) # main Title
     )</code></pre>
</div>
<p>Like in the PCoA example above, to see if you can distinguish between
habitats (<code>HABITAT</code>) based on the bird composition, you can
plot NMDS space, colour coding each point by habitat. This requires a
bit of coding, so you extract the NMDS scores using the
<code>points</code> subscript on an object created with the
<code>metaMDS()</code> function, and then plot these as you would do
with a scatter plot using <code>HABITAT</code> to set the colours of
each point.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Plot each pairwise combination of axes from the 3-axes NMDS, group
the observations based on <code>HABITAT</code>, as this variable is a
surrogate of the overall composition of species.</p>
<p>For this, use the <code>ordihull()</code> function of the
<code>vegan</code> package to add polygons that enclose each
habitat.</p>
</div>
<div class="tutorial-exercise" data-label="NMDSHabi" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="20">
<pre class="text"><code>## Plot axis based on Pair List
  plot(macnally.MDS.V4$______[,c(1,2)], # Which to axis to plot.
       pch = 19, # Type of point.
       col = factor(macnally$______), #Give the point colours based on the habitat.
       main = &quot;NMDS axes 1 an 2&quot;)

## Add a polygon for the habitats
ordihull(ord = macnally.MDS.V4$______[, c(1,2)], # An ordination object
         groups = factor(macnally$______), # Factor giving the groups for
         draw = &quot;polygon&quot;, # What to draw? lines or polygons?
         col = 1:length(unique(macnally$______)), # colours based on the Habitat.
         label = F)
legend(&quot;bottomleft&quot;, # Position the legend?
       fill = 1:length(unique(macnally$______)), #The type of colours  for each class.
       legend = unique(macnally$______), # # The Text for each class in in the legend
       title = &quot;Habitat types&quot;, # Main title
       xpd=NA,
       cex=0.5) </code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="tutorial-exercise-support" data-label="NMDSHabi-solution"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>## Plot axis based on Pair List
  plot(macnally.MDS.V4$points[,c(1,2)], # Which to axis to plot.
       pch = 19, # Type of point.
       col = factor(macnally$HABITAT), #Give the point colours based on the habitat.
       main = &quot;NMDS axes 1 an 2&quot;)

## Add a polygon for the habitats
ordihull(ord = macnally.MDS.V4$points[, c(1,2)], # An ordination object
         groups = factor(macnally$HABITAT), # Factor giving the groups for
         draw = &quot;polygon&quot;, # What to draw? lines or polygons?
         col = 1:length(unique(macnally$HABITAT)), # colours based on the Habitat.
         label = F)
legend(&quot;bottomleft&quot;, # Position the legend?
       fill = 1:length(unique(macnally$HABITAT)), #The type of colours  for each class.
       legend = unique(macnally$HABITAT), # # The Text for each class in in the legend
       title = &quot;Habitat types&quot;, # Main title
       xpd=NA,
       cex=0.5) </code></pre>
</div>
<p>
<script type="application/shiny-prerendered" data-context="server-start">
knitr::opts_chunk$set(echo = TRUE, eval = T)
require("vegan") # - vegan: Community Ecology Statistics including distance matrices  
require("cluster")# - cluster: Identifying cluster goodness  
require("ade4")# - ade4: Euclidean distance calculations  
require("ape")# - ape: PCoA calculation  
require('learnr') #  learnr
# Setup
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE)
gradethis::gradethis_setup()
tutorial_options(exercise.blanks = TRUE)

# Laod data
macnally <- read.csv( file = "https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv")
macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE
macnally.dist <- vegdist(x = macnally.clean, method = "bray")
Hclus.1 <- hclust(d = macnally.dist, method = "single")
SingLin.dist <- cophenetic(Hclus.1)
Hclus.2 <-  hclust(d = macnally.dist, method = "complete")
CompLin.dist <- cophenetic(Hclus.2)
Hclus.3 <- hclust(d = macnally.dist,method = "average")
UPGMA.dist <- cophenetic(Hclus.3)
Hclus.4 <- hclust(d = macnally.dist,method = "ward.D2")
Ward.dist <- cophenetic(Hclus.4)

## Ordination
macnally.dist.Sqrt <- sqrt(macnally.dist)
# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined
#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)
macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = "none")
macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = "bray",try = 20,trace = 0)
stressplot.Bct <- sapply(2:20,
                         function(k){
                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)
                           NMDSTemp$stress
                         })
macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = "bray",try = 20,trace = 0)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::register_http_handlers(session, metadata = NULL)
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::prepare_tutorial_state(session)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::i18n_observe_tutorial_language(input, session)
</script>


<script type="application/shiny-prerendered" data-context="server">
session$onSessionEnded(function() {
        learnr:::event_trigger(session, "session_stop")
      })
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-BrayDist-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-BrayDist-code-editor`)), session)
output$`tutorial-exercise-BrayDist-output` <- renderUI({
  `tutorial-exercise-BrayDist-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "BrayDist", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "BrayDist", code = "# Estimate the  dissimilarities between sampled sites.\nmacnally.dist <- vegdist(x = macnally.clean, # the Community data matrix \n                         method = \"_______\" # defie the Dissimilarity index to use.\n                         )\n# See the Output\nhead(_______)", 
        opts = list(label = "\"BrayDist\"", exercise = "TRUE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = structure("grade_code()", chunk_opts = list(label = "BrayDist-check")), 
    solution = structure(c("# Estimate the  dissimilarities between sampled sites.", 
    "macnally.dist <- vegdist(x = macnally.clean, # the Community data matrix ", 
    "                         method = \"bray\" # defie the Dissimilarity index to use.", 
    "                         )", "# See the Output", "head(macnally.dist)"
    ), chunk_opts = list(label = "BrayDist-solution", exercise.reveal_solution = T)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_Ordination_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "BrayDist", exercise = TRUE, 
        code = c("# Estimate the  dissimilarities between sampled sites.", 
        "macnally.dist <- vegdist(x = macnally.clean, # the Community data matrix ", 
        "                         method = \"_______\" # defie the Dissimilarity index to use.", 
        "                         )", "# See the Output", "head(_______)"
        ), out.width.px = 624, out.height.px = 384, params.src = "BrayDist, exercise=TRUE", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-Dend1a-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-Dend1a-code-editor`)), session)
output$`tutorial-exercise-Dend1a-output` <- renderUI({
  `tutorial-exercise-Dend1a-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "Dend1a", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "Dend1a", code = "# Single linkage\nHclus.1 <- hclust(d = macnally.dist, # A dissimilarity structure.\n                  method = \"_______\") # Agglomeration method to be used.\n\n# Plot the Hierarchical cluster (hclust) object.\nplot(x = _______, # An object of the type produced by hclust.\n     main = \"Bray Curtis\\n Single linkage\", # Main title.\n     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.\n     ) ", 
        opts = list(label = "\"Dend1a\"", exercise = "TRUE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = structure("grade_code()", chunk_opts = list(label = "Dend1a-check")), 
    solution = structure(c("# Single linkage", "Hclus.1 <- hclust(d = macnally.dist, # A dissimilarity structure.", 
    "                  method = \"single\") # Agglomeration method to be used.", 
    "", "# Plot the Hierarchical cluster (hclust) object.", "plot(x = Hclus.1, # An object of the type produced by hclust.", 
    "     main = \"Bray Curtis\\n Single linkage\", # Main title.", 
    "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
    "     ) "), chunk_opts = list(label = "Dend1a-solution", 
        exercise.reveal_solution = T)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_Ordination_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "Dend1a", exercise = TRUE, 
        code = c("# Single linkage", "Hclus.1 <- hclust(d = macnally.dist, # A dissimilarity structure.", 
        "                  method = \"_______\") # Agglomeration method to be used.", 
        "", "# Plot the Hierarchical cluster (hclust) object.", 
        "plot(x = _______, # An object of the type produced by hclust.", 
        "     main = \"Bray Curtis\\n Single linkage\", # Main title.", 
        "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
        "     ) "), out.width.px = 624, out.height.px = 384, 
        params.src = "Dend1a, exercise=TRUE", fig.num = 0, exercise.df_print = "paged"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-Dend1b-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-Dend1b-code-editor`)), session)
output$`tutorial-exercise-Dend1b-output` <- renderUI({
  `tutorial-exercise-Dend1b-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "Dend1b", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "Dend1b", code = "## Complete linkage\nHclus.2 <-  hclust(d = macnally.dist, # A dissimilarity structure.\n                  method = \"_________\") # Agglomeration method to be used.\n# Plot the Hierarchical cluster (hclust) object.\nplot(x = _________, # An object of the type produced by hclust.\n     main = \"Bray Curtis\\n Complete linkage\", # Main title.\n     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.\n     ) ", 
        opts = list(label = "\"Dend1b\"", exercise = "TRUE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = structure("grade_code()", chunk_opts = list(label = "Dend1b-check")), 
    solution = structure(c("## Complete linkage", "Hclus.2 <-  hclust(d = macnally.dist, # A dissimilarity structure.", 
    "                  method = \"complete\") # Agglomeration method to be used.", 
    "# Plot the Hierarchical cluster (hclust) object.", "plot(x = Hclus.2, # An object of the type produced by hclust.", 
    "     main = \"Bray Curtis\\n Complete linkage\", # Main title.", 
    "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
    "     ) "), chunk_opts = list(label = "Dend1b-solution", 
        exercise.reveal_solution = T)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_Ordination_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "Dend1b", exercise = TRUE, 
        code = c("## Complete linkage", "Hclus.2 <-  hclust(d = macnally.dist, # A dissimilarity structure.", 
        "                  method = \"_________\") # Agglomeration method to be used.", 
        "# Plot the Hierarchical cluster (hclust) object.", "plot(x = _________, # An object of the type produced by hclust.", 
        "     main = \"Bray Curtis\\n Complete linkage\", # Main title.", 
        "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
        "     ) "), out.width.px = 624, out.height.px = 384, 
        params.src = "Dend1b, exercise=TRUE", fig.num = 0, exercise.df_print = "paged"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-Dend1c-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-Dend1c-code-editor`)), session)
output$`tutorial-exercise-Dend1c-output` <- renderUI({
  `tutorial-exercise-Dend1c-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "Dend1c", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "Dend1c", code = "## Average (UPGMA) linkage  \nHclus.3 <- hclust(d = macnally.dist, # A dissimilarity structure.\n                  method = \"_______\") # Agglomeration method to be used.\n# Plot the Hierarchical cluster (hclust) object.\nplot(x = _______, # An object of the type produced by hclust.\n     main = \"Bray Curtis\\n Average\", # Main title.\n     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.\n     ) ", 
        opts = list(label = "\"Dend1c\"", exercise = "TRUE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = structure("grade_code()", chunk_opts = list(label = "Dend1c-check")), 
    solution = structure(c("## Average (UPGMA) linkage  ", "Hclus.3 <- hclust(d = macnally.dist, # A dissimilarity structure.", 
    "                  method = \"average\") # Agglomeration method to be used.", 
    "# Plot the Hierarchical cluster (hclust) object.", "plot(x = Hclus.2, # An object of the type produced by hclust.", 
    "     main = \"Bray Curtis\\n Average\", # Main title.", 
    "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
    "     ) "), chunk_opts = list(label = "Dend1c-solution", 
        exercise.reveal_solution = T)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_Ordination_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "Dend1c", exercise = TRUE, 
        code = c("## Average (UPGMA) linkage  ", "Hclus.3 <- hclust(d = macnally.dist, # A dissimilarity structure.", 
        "                  method = \"_______\") # Agglomeration method to be used.", 
        "# Plot the Hierarchical cluster (hclust) object.", "plot(x = _______, # An object of the type produced by hclust.", 
        "     main = \"Bray Curtis\\n Average\", # Main title.", 
        "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
        "     ) "), out.width.px = 624, out.height.px = 384, 
        params.src = "Dend1c, exercise=TRUE", fig.num = 0, exercise.df_print = "paged"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-DenPltLab-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-DenPltLab-code-editor`)), session)
output$`tutorial-exercise-DenPltLab-output` <- renderUI({
  `tutorial-exercise-DenPltLab-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "DenPltLab", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "DenPltLab", code = "# Plot the Complete Linkage Hierarchical cluster (hclust) object.\nplot(x = _______, # An object of the type produced by hclust().\n     labels = macnally$_______, # A character vector of labels for the leaves of the tree.\n     main = \"Bray Curtis\\n Complete\", # Main title.\n     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.\n     ) ", 
        opts = list(label = "\"DenPltLab\"", exercise = "TRUE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = structure("grade_code()", chunk_opts = list(label = "DenPltLab-check")), 
    solution = structure(c("# Plot the Complete Linkage Hierarchical cluster (hclust) object.", 
    "plot(x = Hclus.2, # An object of the type produced by hclust().", 
    "     labels = macnally$HABITAT, # A character vector of labels for the leaves of the tree.", 
    "     main = \"Bray Curtis\\n Complete\", # Main title.", 
    "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
    "     ) "), chunk_opts = list(label = "DenPltLab-solution", 
        exercise.reveal_solution = T)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_Ordination_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "DenPltLab", exercise = TRUE, 
        code = c("# Plot the Complete Linkage Hierarchical cluster (hclust) object.", 
        "plot(x = _______, # An object of the type produced by hclust().", 
        "     labels = macnally$_______, # A character vector of labels for the leaves of the tree.", 
        "     main = \"Bray Curtis\\n Complete\", # Main title.", 
        "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
        "     ) "), out.width.px = 624, out.height.px = 384, 
        params.src = "DenPltLab, exercise=TRUE", fig.num = 0, 
        exercise.df_print = "paged"), engine = "r", version = "4"), class = c("r", 
"tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-WardDend-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-WardDend-code-editor`)), session)
output$`tutorial-exercise-WardDend-output` <- renderUI({
  `tutorial-exercise-WardDend-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "WardDend", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "WardDend", code = "## Ward’s clustering.  \nHclus.4 <- hclust(d = macnally.dist, # A dissimilarity structure.\n                  method = \"_______\") # Agglomeration method to be used.\n\n# Plot the Hierarchical cluster (hclust) object.\nplot(x = _______, # An object of the type produced by hclust.\n     main = \"Bray Curtis\\n Ward’s method \", # Main title.\n     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.\n     ) \n\n# Plot the Hierarchical cluster (hclust) object, adding the habitat-type \nplot(x = _______, # An object of the type produced by hclust.\n     labels = macnally$_______, # A character vector of labels for the leaves of the tree.\n     main = \"Bray Curtis\\n Ward’s method\", # Main title.\n     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.\n     ) ", 
        opts = list(label = "\"WardDend\"", exercise = "TRUE", 
            exercise.lines = "20"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "WardDend-check")), solution = structure(c("## Ward’s clustering.  ", 
    "Hclus.4 <- hclust(d = macnally.dist, # A dissimilarity structure.", 
    "                  method = \"ward.D2\") # Agglomeration method to be used.", 
    "", "# Plot the Hierarchical cluster (hclust) object.", "plot(x = Hclus.4, # An object of the type produced by hclust.", 
    "     main = \"Bray Curtis\\n Ward’s method \", # Main title.", 
    "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
    "     ) ", "", "# Plot the Hierarchical cluster (hclust) object, adding the habitat-type ", 
    "plot(x = Hclus.4, # An object of the type produced by hclust.", 
    "     labels = macnally$HABITAT, # A character vector of labels for the leaves of the tree.", 
    "     main = \"Bray Curtis\\n Ward’s method\", # Main title.", 
    "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
    "     ) "), chunk_opts = list(label = "WardDend-solution", 
        exercise.reveal_solution = T)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_Ordination_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "WardDend", exercise = TRUE, 
        exercise.lines = 20, code = c("## Ward’s clustering.  ", 
        "Hclus.4 <- hclust(d = macnally.dist, # A dissimilarity structure.", 
        "                  method = \"_______\") # Agglomeration method to be used.", 
        "", "# Plot the Hierarchical cluster (hclust) object.", 
        "plot(x = _______, # An object of the type produced by hclust.", 
        "     main = \"Bray Curtis\\n Ward’s method \", # Main title.", 
        "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
        "     ) ", "", "# Plot the Hierarchical cluster (hclust) object, adding the habitat-type ", 
        "plot(x = _______, # An object of the type produced by hclust.", 
        "     labels = macnally$_______, # A character vector of labels for the leaves of the tree.", 
        "     main = \"Bray Curtis\\n Ward’s method\", # Main title.", 
        "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
        "     ) "), out.width.px = 624, out.height.px = 384, 
        params.src = "WardDend, exercise=TRUE, exercise.lines=20", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ShepDiag1-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ShepDiag1-code-editor`)), session)
output$`tutorial-exercise-ShepDiag1-output` <- renderUI({
  `tutorial-exercise-ShepDiag1-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ShepDiag1", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "ShepDiag1", code = "# Calculate the cophenetic distance for the single linkage clustering.\nSingLin.dist <- cophenetic(_______)\n# Print the object class of the cophenetic distance\nclass(_______)\n\n## Plot the original vs cophenetic for the Single Linkage dendrogram.\nplot(x = _______, # Cophenetic distances.\n     y = macnally.dist, # Original distances.\n     main = 'Cophenetic Correlation\\n Single linkage',# Figure main title.\n     pch = 19, col = \"lightgrey\", cex=1.2 # Define Point type, colour, and size arguments.\n     )\n# Add a 1:1 line\nabline(a = 0, b = 1, # Set the intercept (a) and slope (b).\n       lty = 1, lwd = 2,\n       xpd = F) # Define the line width and type attributes.\n\n# Add a line representing the smoothed relation between the original vs cophenetic distances\n# A Loess model\nSmothMod <- lowess(macnally.dist ~ _______)\n# Add a line with the Loess model\nlines(_______, # The Loess model \n      lty = 2, col = \"red\", lwd = 2) # Define the line colour, width, and type attributes.\n\n# Estimate the correlations between original vs cophenetic distances.\ncor.SingLin <- cor(_______, macnally.dist)\n\n# Add the correlation to the figure as a text box\nlegend(\"topleft\", # Position the legend?\n       legend = paste(\"Pearson = \", round(cor.SingLin, 3)), # Legend Text.\n       bty = \"n\" # Type of box to be drawn around the legend.\n       )", 
        opts = list(label = "\"ShepDiag1\"", exercise = "TRUE", 
            exercise.lines = "30"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "ShepDiag1-check")), solution = structure(c("# Calculate the cophenetic distance for the single linkage clustering.", 
    "SingLin.dist <- cophenetic(Hclus.1)", "# Print the object class of the cophenetic distance", 
    "class(SingLin.dist)", "", "## Plot the original vs cophenetic for the Single Linkage dendrogram.", 
    "plot(x = SingLin.dist, # Cophenetic distances.", "     y = macnally.dist, # Original distances.", 
    "     main = 'Cophenetic Correlation\\n Single linkage',# Figure main title.", 
    "     pch = 19, col = \"lightgrey\", cex=1.2 # Define Point type, colour, and size arguments.", 
    "     )", "# Add a 1:1 line", "abline(a = 0, b = 1, # Set the intercept (a) and slope (b).", 
    "       lty = 1, lwd = 2,", "       xpd = F) # Define the line width and type attributes.", 
    "", "# Add a line representing the smoothed relation between the original vs cophenetic distances", 
    "# A Loess model", "SmothMod <- lowess(macnally.dist ~ SingLin.dist)", 
    "# Add a line with the Loess model", "lines(SmothMod, # The Loess model ", 
    "      lty = 2, col = \"red\", lwd = 2) # Define the line colour, width, and type attributes.", 
    "", "# Estimate the correlations between original vs cophenetic distances.", 
    "cor.SingLin <- cor(SingLin.dist, macnally.dist)", "", "# Add the correlation to the figure as a text box", 
    "legend(\"topleft\", # Position the legend?", "       legend = paste(\"Pearson = \", round(cor.SingLin, 3)), # Legend Text.", 
    "       bty = \"n\" # Type of box to be drawn around the legend.", 
    "       )"), chunk_opts = list(label = "ShepDiag1-solution", 
        exercise.reveal_solution = T)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_Ordination_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "ShepDiag1", exercise = TRUE, 
        exercise.lines = 30, code = c("# Calculate the cophenetic distance for the single linkage clustering.", 
        "SingLin.dist <- cophenetic(_______)", "# Print the object class of the cophenetic distance", 
        "class(_______)", "", "## Plot the original vs cophenetic for the Single Linkage dendrogram.", 
        "plot(x = _______, # Cophenetic distances.", "     y = macnally.dist, # Original distances.", 
        "     main = 'Cophenetic Correlation\\n Single linkage',# Figure main title.", 
        "     pch = 19, col = \"lightgrey\", cex=1.2 # Define Point type, colour, and size arguments.", 
        "     )", "# Add a 1:1 line", "abline(a = 0, b = 1, # Set the intercept (a) and slope (b).", 
        "       lty = 1, lwd = 2,", "       xpd = F) # Define the line width and type attributes.", 
        "", "# Add a line representing the smoothed relation between the original vs cophenetic distances", 
        "# A Loess model", "SmothMod <- lowess(macnally.dist ~ _______)", 
        "# Add a line with the Loess model", "lines(_______, # The Loess model ", 
        "      lty = 2, col = \"red\", lwd = 2) # Define the line colour, width, and type attributes.", 
        "", "# Estimate the correlations between original vs cophenetic distances.", 
        "cor.SingLin <- cor(_______, macnally.dist)", "", "# Add the correlation to the figure as a text box", 
        "legend(\"topleft\", # Position the legend?", "       legend = paste(\"Pearson = \", round(cor.SingLin, 3)), # Legend Text.", 
        "       bty = \"n\" # Type of box to be drawn around the legend.", 
        "       )"), out.width.px = 624, out.height.px = 384, 
        params.src = "ShepDiag1, exercise=TRUE, exercise.lines=30", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ShepDiag2-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ShepDiag2-code-editor`)), session)
output$`tutorial-exercise-ShepDiag2-output` <- renderUI({
  `tutorial-exercise-ShepDiag2-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ShepDiag2", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "ShepDiag2", code = "# Calculate the cophenetic distance for the complete linkage clustering.\nCompLin.dist <- cophenetic(______)\n# Print the object class of the cophenetic distance\nclass(CompLin.dist)\n\n# Plot the original vs cophenetic for the Complete Linkage dendrogram.\n  plot(x = ______, # Cophenetic distances.\n       y = macnally.dist, # Original distances.\n       main = 'Cophenetic Correlation\\n Complete linkage'# Figure main title.\n  )\n# Add a 1:1 line\nabline(a = 0, b = 1, # Set the intercept (a) and slope (b).\n       lty = 1, lwd = 2) # Define the line width and type attributes.\n\n# Add a line representing the smoothed relation between the original vs cophenetic distances\n# A Loess model\nSmothMod <- lowess(macnally.dist ~ ______)\n# Add a line with the Loess model\nlines(______, # The Loess model \n      lty = 2, col = \"red\", lwd = 2) # Define the line colour, width, and type attributes.\n\n# Estimate the correlations between original vs cophenetic distances.\ncor.CompLin <- cor(______, macnally.dist)\n\n# Add the correlation to the figure as a text box\nlegend(\"topleft\", # Where to place the legend box.\n       legend = paste(\"Pearson = \", round(cor.CompLin, 3)), # Legend Text.\n       bty = \"n\" # Type of box to be drawn around the legend.\n)", 
        opts = list(label = "\"ShepDiag2\"", exercise = "TRUE", 
            exercise.lines = "30"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "ShepDiag2-check")), solution = structure(c("# Calculate the cophenetic distance for the complete linkage clustering.", 
    "CompLin.dist <- cophenetic(Hclus.2)", "# Print the object class of the cophenetic distance", 
    "class(CompLin.dist)", "", "# Plot the original vs cophenetic for the Complete Linkage dendrogram.", 
    "  plot(x = CompLin.dist, # Cophenetic distances.", "       y = macnally.dist, # Original distances.", 
    "       main = 'Cophenetic Correlation\\n Complete linkage'# Figure main title.", 
    "  )", "# Add a 1:1 line", "abline(a = 0, b = 1, # Set the intercept (a) and slope (b).", 
    "       lty = 1, lwd = 2) # Define the line width and type attributes.", 
    "", "# Add a line representing the smoothed relation between the original vs cophenetic distances", 
    "# A Loess model", "SmothMod <- lowess(macnally.dist ~ CompLin.dist)", 
    "# Add a line with the Loess model", "lines(SmothMod, # The Loess model ", 
    "      lty = 2, col = \"red\", lwd = 2) # Define the line colour, width, and type attributes.", 
    "", "# Estimate the correlations between original vs cophenetic distances.", 
    "cor.CompLin <- cor(CompLin.dist, macnally.dist)", "", "# Add the correlation to the figure as a text box", 
    "legend(\"topleft\", # Where to place the legend box.", "       legend = paste(\"Pearson = \", round(cor.CompLin, 3)), # Legend Text.", 
    "       bty = \"n\" # Type of box to be drawn around the legend.", 
    ")"), chunk_opts = list(label = "ShepDiag2-solution", exercise.reveal_solution = T)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_Ordination_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "ShepDiag2", exercise = TRUE, 
        exercise.lines = 30, code = c("# Calculate the cophenetic distance for the complete linkage clustering.", 
        "CompLin.dist <- cophenetic(______)", "# Print the object class of the cophenetic distance", 
        "class(CompLin.dist)", "", "# Plot the original vs cophenetic for the Complete Linkage dendrogram.", 
        "  plot(x = ______, # Cophenetic distances.", "       y = macnally.dist, # Original distances.", 
        "       main = 'Cophenetic Correlation\\n Complete linkage'# Figure main title.", 
        "  )", "# Add a 1:1 line", "abline(a = 0, b = 1, # Set the intercept (a) and slope (b).", 
        "       lty = 1, lwd = 2) # Define the line width and type attributes.", 
        "", "# Add a line representing the smoothed relation between the original vs cophenetic distances", 
        "# A Loess model", "SmothMod <- lowess(macnally.dist ~ ______)", 
        "# Add a line with the Loess model", "lines(______, # The Loess model ", 
        "      lty = 2, col = \"red\", lwd = 2) # Define the line colour, width, and type attributes.", 
        "", "# Estimate the correlations between original vs cophenetic distances.", 
        "cor.CompLin <- cor(______, macnally.dist)", "", "# Add the correlation to the figure as a text box", 
        "legend(\"topleft\", # Where to place the legend box.", 
        "       legend = paste(\"Pearson = \", round(cor.CompLin, 3)), # Legend Text.", 
        "       bty = \"n\" # Type of box to be drawn around the legend.", 
        ")"), out.width.px = 624, out.height.px = 384, params.src = "ShepDiag2, exercise=TRUE, exercise.lines=30", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ShepDiag3-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ShepDiag3-code-editor`)), session)
output$`tutorial-exercise-ShepDiag3-output` <- renderUI({
  `tutorial-exercise-ShepDiag3-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ShepDiag3", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "ShepDiag3", code = "# Calculate the cophenetic distance for the average/UPGMA clustering.\nUPGMA.dist <- cophenetic(______)\n# Print the object class of the cophenetic distance\nclass(UPGMA.dist)\n\n# Plot the original vs cophenetic for the UPGMA dendrogram.\n  plot(x = ______, # Cophenetic distances.\n       y = macnally.dist, # Original distances.\n       main = 'Cophenetic Correlation\\n UPGMA'# Figure main title.\n  )\n# Add a 1:1 line\nabline(a = 0, b = 1, # Set the intercept (a) and slope (b).\n       lty = 1, lwd = 2) # Define the line width and type attributes.\n\n# Add a line representing the smoothed relation between the original vs cophenetic distances\n# A Loess model\nSmothMod <- lowess(macnally.dist ~ ______)\n# Add a line with the Loess model\nlines(______, # The Loess model \n      lty = 2, col = \"red\", lwd = 2) # Define the line colour, width, and type attributes.\n\n# Estimate the correlations between original vs cophenetic distances.\ncor.CompLin <- cor(______, macnally.dist)\n\n# Add the correlation to the figure as a text box\nlegend(\"topleft\", # Where to place the legend box.\n       legend = paste(\"Pearson = \", round(cor.CompLin, 3)), # Legend Text.\n       bty = \"n\" # Type of box to be drawn around the legend.\n)", 
        opts = list(label = "\"ShepDiag3\"", exercise = "TRUE", 
            exercise.lines = "30"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "ShepDiag3-check")), solution = structure(c("# Calculate the cophenetic distance for the average/UPGMA clustering.", 
    "UPGMA.dist <- cophenetic(Hclus.3)", "# Print the object class of the cophenetic distance", 
    "class(UPGMA.dist)", "", "# Plot the original vs cophenetic for the UPGMA dendrogram.", 
    "  plot(x = UPGMA.dist, # Cophenetic distances.", "       y = macnally.dist, # Original distances.", 
    "       main = 'Cophenetic Correlation\\n UPGMA'# Figure main title.", 
    "  )", "# Add a 1:1 line", "abline(a = 0, b = 1, # Set the intercept (a) and slope (b).", 
    "       lty = 1, lwd = 2) # Define the line width and type attributes.", 
    "", "# Add a line representing the smoothed relation between the original vs cophenetic distances", 
    "# A Loess model", "SmothMod <- lowess(macnally.dist ~ UPGMA.dist)", 
    "# Add a line with the Loess model", "lines(SmothMod, # The Loess model ", 
    "      lty = 2, col = \"red\", lwd = 2) # Define the line colour, width, and type attributes.", 
    "", "# Estimate the correlations between original vs cophenetic distances.", 
    "cor.CompLin <- cor(UPGMA.dist, macnally.dist)", "", "# Add the correlation to the figure as a text box", 
    "legend(\"topleft\", # Where to place the legend box.", "       legend = paste(\"Pearson = \", round(cor.CompLin, 3)), # Legend Text.", 
    "       bty = \"n\" # Type of box to be drawn around the legend.", 
    ")"), chunk_opts = list(label = "ShepDiag3-solution", exercise.reveal_solution = T)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_Ordination_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "ShepDiag3", exercise = TRUE, 
        exercise.lines = 30, code = c("# Calculate the cophenetic distance for the average/UPGMA clustering.", 
        "UPGMA.dist <- cophenetic(______)", "# Print the object class of the cophenetic distance", 
        "class(UPGMA.dist)", "", "# Plot the original vs cophenetic for the UPGMA dendrogram.", 
        "  plot(x = ______, # Cophenetic distances.", "       y = macnally.dist, # Original distances.", 
        "       main = 'Cophenetic Correlation\\n UPGMA'# Figure main title.", 
        "  )", "# Add a 1:1 line", "abline(a = 0, b = 1, # Set the intercept (a) and slope (b).", 
        "       lty = 1, lwd = 2) # Define the line width and type attributes.", 
        "", "# Add a line representing the smoothed relation between the original vs cophenetic distances", 
        "# A Loess model", "SmothMod <- lowess(macnally.dist ~ ______)", 
        "# Add a line with the Loess model", "lines(______, # The Loess model ", 
        "      lty = 2, col = \"red\", lwd = 2) # Define the line colour, width, and type attributes.", 
        "", "# Estimate the correlations between original vs cophenetic distances.", 
        "cor.CompLin <- cor(______, macnally.dist)", "", "# Add the correlation to the figure as a text box", 
        "legend(\"topleft\", # Where to place the legend box.", 
        "       legend = paste(\"Pearson = \", round(cor.CompLin, 3)), # Legend Text.", 
        "       bty = \"n\" # Type of box to be drawn around the legend.", 
        ")"), out.width.px = 624, out.height.px = 384, params.src = "ShepDiag3, exercise=TRUE, exercise.lines=30", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ShepDiag4-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ShepDiag4-code-editor`)), session)
output$`tutorial-exercise-ShepDiag4-output` <- renderUI({
  `tutorial-exercise-ShepDiag4-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ShepDiag4", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "ShepDiag4", code = "# Calculate the cophenetic distance for the Ward clustering.\nWard.dist <- cophenetic(______)\n# Print the object class of the cophenetic distance\nclass(Ward.dist)\n# Plot the original vs cophenetic for the Ward dendrogram.\n  plot(x = ______, # Cophenetic distances.\n       y = macnally.dist, # Original distances.\n       main = 'Cophenetic Correlation\\n Ward'# Figure main title.\n  )\n# Add a 1:1 line\nabline(a = 0, b = 1, # Set the intercept (a) and slope (b).\n       lty = 1, lwd = 2) # Define the line width and type attributes.\n\n# Add a line representing the smoothed relation between the original vs cophenetic distances\n# A Loess model\nSmothMod <- lowess(macnally.dist ~ ______)\n# Add a line with the Loess model\nlines(______, # The Loess model \n      lty = 2, col = \"red\", lwd = 2) # Define the line colour, width, and type attributes.\n\n# Estimate the correlations between original vs cophenetic distances.\ncor.CompLin <- cor(______, macnally.dist)\n\n# Add the correlation to the figure as a text box\nlegend(\"topleft\", # Where to place the legend box.\n       legend = paste(\"Pearson = \", round(cor.CompLin, 3)), # Legend Text.\n       bty = \"n\" # Type of box to be drawn around the legend.\n)", 
        opts = list(label = "\"ShepDiag4\"", exercise = "TRUE", 
            exercise.lines = "30"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "ShepDiag4-check")), solution = structure(c("# Calculate the cophenetic distance for the Ward clustering.", 
    "Ward.dist <- cophenetic(Hclus.4)", "# Print the object class of the cophenetic distance", 
    "class(Ward.dist)", "# Plot the original vs cophenetic for the Ward dendrogram.", 
    "  plot(x = Ward.dist, # Cophenetic distances.", "       y = macnally.dist, # Original distances.", 
    "       main = 'Cophenetic Correlation\\n Ward'# Figure main title.", 
    "  )", "# Add a 1:1 line", "abline(a = 0, b = 1, # Set the intercept (a) and slope (b).", 
    "       lty = 1, lwd = 2) # Define the line width and type attributes.", 
    "", "# Add a line representing the smoothed relation between the original vs cophenetic distances", 
    "# A Loess model", "SmothMod <- lowess(macnally.dist ~ Ward.dist)", 
    "# Add a line with the Loess model", "lines(SmothMod, # The Loess model ", 
    "      lty = 2, col = \"red\", lwd = 2) # Define the line colour, width, and type attributes.", 
    "", "# Estimate the correlations between original vs cophenetic distances.", 
    "cor.CompLin <- cor(Ward.dist, macnally.dist)", "", "# Add the correlation to the figure as a text box", 
    "legend(\"topleft\", # Where to place the legend box.", "       legend = paste(\"Pearson = \", round(cor.CompLin, 3)), # Legend Text.", 
    "       bty = \"n\" # Type of box to be drawn around the legend.", 
    ")"), chunk_opts = list(label = "ShepDiag4-solution", exercise.reveal_solution = T)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_Ordination_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "ShepDiag4", exercise = TRUE, 
        exercise.lines = 30, code = c("# Calculate the cophenetic distance for the Ward clustering.", 
        "Ward.dist <- cophenetic(______)", "# Print the object class of the cophenetic distance", 
        "class(Ward.dist)", "# Plot the original vs cophenetic for the Ward dendrogram.", 
        "  plot(x = ______, # Cophenetic distances.", "       y = macnally.dist, # Original distances.", 
        "       main = 'Cophenetic Correlation\\n Ward'# Figure main title.", 
        "  )", "# Add a 1:1 line", "abline(a = 0, b = 1, # Set the intercept (a) and slope (b).", 
        "       lty = 1, lwd = 2) # Define the line width and type attributes.", 
        "", "# Add a line representing the smoothed relation between the original vs cophenetic distances", 
        "# A Loess model", "SmothMod <- lowess(macnally.dist ~ ______)", 
        "# Add a line with the Loess model", "lines(______, # The Loess model ", 
        "      lty = 2, col = \"red\", lwd = 2) # Define the line colour, width, and type attributes.", 
        "", "# Estimate the correlations between original vs cophenetic distances.", 
        "cor.CompLin <- cor(______, macnally.dist)", "", "# Add the correlation to the figure as a text box", 
        "legend(\"topleft\", # Where to place the legend box.", 
        "       legend = paste(\"Pearson = \", round(cor.CompLin, 3)), # Legend Text.", 
        "       bty = \"n\" # Type of box to be drawn around the legend.", 
        ")"), out.width.px = 624, out.height.px = 384, params.src = "ShepDiag4, exercise=TRUE, exercise.lines=30", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-DistCor-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-DistCor-code-editor`)), session)
output$`tutorial-exercise-DistCor-output` <- renderUI({
  `tutorial-exercise-DistCor-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "DistCor", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "DistCor", code = "# Gower distance for the Single linkage clustering\ngow.dist.single <- sum((macnally.dist - ______) ^ 2)\ngow.dist.single\n\n# Gower distance for the Complete linkage clustering\ngow.dist.comp <- sum((macnally.dist - ______) ^ 2)\ngow.dist.comp\n\n# Gower distance for the UPGMA clustering\ngow.dist.UPGMA <- sum((macnally.dist - ______) ^ 2)\ngow.dist.UPGMA\n\n# Gower distance for the Ward clustering\ngow.dist.ward <- sum((macnally.dist - ______) ^ 2)\ngow.dist.ward\n", 
        opts = list(label = "\"DistCor\"", exercise = "TRUE", 
            exercise.lines = "20"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "DistCor-check")), solution = structure(c("# Gower distance for the Single linkage clustering", 
    "gow.dist.single <- sum((macnally.dist - SingLin.dist) ^ 2)", 
    "gow.dist.single", "", "# Gower distance for the Complete linkage clustering", 
    "gow.dist.comp <- sum((macnally.dist - CompLin.dist) ^ 2)", 
    "gow.dist.comp", "", "# Gower distance for the UPGMA clustering", 
    "gow.dist.UPGMA <- sum((macnally.dist - UPGMA.dist) ^ 2)", 
    "gow.dist.UPGMA", "", "# Gower distance for the Ward clustering", 
    "gow.dist.ward <- sum((macnally.dist - Ward.dist) ^ 2)", 
    "gow.dist.ward", ""), chunk_opts = list(label = "DistCor-solution", 
        exercise.reveal_solution = T)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_Ordination_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "DistCor", exercise = TRUE, 
        exercise.lines = 20, code = c("# Gower distance for the Single linkage clustering", 
        "gow.dist.single <- sum((macnally.dist - ______) ^ 2)", 
        "gow.dist.single", "", "# Gower distance for the Complete linkage clustering", 
        "gow.dist.comp <- sum((macnally.dist - ______) ^ 2)", 
        "gow.dist.comp", "", "# Gower distance for the UPGMA clustering", 
        "gow.dist.UPGMA <- sum((macnally.dist - ______) ^ 2)", 
        "gow.dist.UPGMA", "", "# Gower distance for the Ward clustering", 
        "gow.dist.ward <- sum((macnally.dist - ______) ^ 2)", 
        "gow.dist.ward", ""), out.width.px = 624, out.height.px = 384, 
        params.src = "DistCor, exercise=TRUE, exercise.lines=20", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-SplitPLot-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-SplitPLot-code-editor`)), session)
output$`tutorial-exercise-SplitPLot-output` <- renderUI({
  `tutorial-exercise-SplitPLot-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "SplitPLot", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "SplitPLot", code = "# Plot the best clustering approach (hclust) object, adding the two groups classification as labels.\nplot(x = _____, # An object of the type produced by hclust.\n     labels = cutree(_____, 2), # A character vector of labels for the tree's leaves.\n     main = \"Two groups\\n UPGMA\", # Main title.\n     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.\n     ) \n\n# Plot the best clustering approach (hclust) object, adding the three groups classification as labels.\nplot(x = _____, # An object of the type produced by hclust.\n     labels = cutree(_____, 3), # A character vector of labels for the tree's leaves.\n     main = \"Three groups\\n UPGMA\", # Main title.\n     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.\n     ) \n\n# Plot the best clustering approach (hclust) object, adding the four groups classification as labels.\nplot(x = _____, # An object of the type produced by hclust.\n     labels = cutree(_____, 4), # A character vector of labels for the tree's leaves.\n     main = \"Four groups\\n UPGMA\", # Main title.\n     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.\n     ) \n\n# Plot the best clustering approach (hclust) object, adding the five groups classification as labels.\nplot(x = _____, # An object of the type produced by hclust.\n     labels = cutree(_____, 5), # A character vector of labels for the tree's leaves.\n     main = \"Five groups\\n UPGMA\", # Main title.\n     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.\n     ) ", 
        opts = list(label = "\"SplitPLot\"", exercise = "TRUE", 
            exercise.lines = "25"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "SplitPLot-check")), solution = structure(c("# Plot the best clustering approach (hclust) object, adding the two groups classification as labels.", 
    "plot(x = Hclus.3, # An object of the type produced by hclust.", 
    "     labels = cutree(Hclus.3, 2), # A character vector of labels for the tree's leaves.", 
    "     main = \"Two groups\\n UPGMA\", # Main title.", "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
    "     ) ", "", "# Plot the best clustering approach (hclust) object, adding the three groups classification as labels.", 
    "plot(x = Hclus.3, # An object of the type produced by hclust.", 
    "     labels = cutree(Hclus.3, 3), # A character vector of labels for the tree's leaves.", 
    "     main = \"Three groups\\n UPGMA\", # Main title.", "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
    "     ) ", "", "# Plot the best clustering approach (hclust) object, adding the four groups classification as labels.", 
    "plot(x = Hclus.3, # An object of the type produced by hclust.", 
    "     labels = cutree(Hclus.3, 4), # A character vector of labels for the tree's leaves.", 
    "     main = \"Four groups\\n UPGMA\", # Main title.", "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
    "     ) ", "", "# Plot the best clustering approach (hclust) object, adding the five groups classification as labels.", 
    "plot(x = Hclus.3, # An object of the type produced by hclust.", 
    "     labels = cutree(Hclus.3, 5), # A character vector of labels for the tree's leaves.", 
    "     main = \"Five groups\\n UPGMA\", # Main title.", "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
    "     ) "), chunk_opts = list(label = "SplitPLot-solution", 
        exercise.reveal_solution = T)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_Ordination_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "SplitPLot", exercise = TRUE, 
        exercise.lines = 25, code = c("# Plot the best clustering approach (hclust) object, adding the two groups classification as labels.", 
        "plot(x = _____, # An object of the type produced by hclust.", 
        "     labels = cutree(_____, 2), # A character vector of labels for the tree's leaves.", 
        "     main = \"Two groups\\n UPGMA\", # Main title.", 
        "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
        "     ) ", "", "# Plot the best clustering approach (hclust) object, adding the three groups classification as labels.", 
        "plot(x = _____, # An object of the type produced by hclust.", 
        "     labels = cutree(_____, 3), # A character vector of labels for the tree's leaves.", 
        "     main = \"Three groups\\n UPGMA\", # Main title.", 
        "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
        "     ) ", "", "# Plot the best clustering approach (hclust) object, adding the four groups classification as labels.", 
        "plot(x = _____, # An object of the type produced by hclust.", 
        "     labels = cutree(_____, 4), # A character vector of labels for the tree's leaves.", 
        "     main = \"Four groups\\n UPGMA\", # Main title.", 
        "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
        "     ) ", "", "# Plot the best clustering approach (hclust) object, adding the five groups classification as labels.", 
        "plot(x = _____, # An object of the type produced by hclust.", 
        "     labels = cutree(_____, 5), # A character vector of labels for the tree's leaves.", 
        "     main = \"Five groups\\n UPGMA\", # Main title.", 
        "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
        "     ) "), out.width.px = 624, out.height.px = 384, 
        params.src = "SplitPLot, exercise=TRUE, exercise.lines=25", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-FusionPlt-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-FusionPlt-code-editor`)), session)
output$`tutorial-exercise-FusionPlt-output` <- renderUI({
  `tutorial-exercise-FusionPlt-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "FusionPlt", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "FusionPlt", code = "# Plot the fusion level values of the best clustering approach\nplot(x = ______$______, # The clustering height: that is, the value of the criterion associated with the clustering method for the particular agglomeration.\n     y = nrow(______):2, # Fusion Node.\n     type = \"S\", # type of plot desired? = stair steps.\n     main = \"Fusion levels - UPGMA\", # Main title.\n     ylab = \"k (number of clusters)\", # Y-lab label.\n     xlab = \"h (node height)\", # x-lab label.\n     col = \"grey\", lwd = 2 # Line piloting arguments. \n     )\n\n# Use the text() function to define the Fusions level of each brake\ntext(x = ______$______, # The clustering height: that is, the value of the criterion associated with the clustering method for the particular agglomeration.\n     y = nrow(macnally):2, # Fusion Node.\n     labels = nrow(macnally):2, # Fusion Node.\n     col = \"red\", cex = 0.8 # Text colour and size?\n     )", 
        opts = list(label = "\"FusionPlt\"", exercise = "TRUE", 
            exercise.lines = "20"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "FusionPlt-check")), solution = structure(c("# Plot the fusion level values of the best clustering approach", 
    "plot(x = Hclus.3$height, # The clustering height: that is, the value of the criterion associated with the clustering method for the particular agglomeration.", 
    "     y = nrow(macnally):2, # Fusion Node.", "     type = \"S\", # type of plot desired? = stair steps.", 
    "     main = \"Fusion levels - UPGMA\", # Main title.", "     ylab = \"k (number of clusters)\", # Y-lab label.", 
    "     xlab = \"h (node height)\", # x-lab label.", "     col = \"grey\", lwd = 2 # Line piloting arguments. ", 
    "     )", "", "# Use the text() function to define the Fusions level of each brake", 
    "text(x = Hclus.3$height, # The clustering height: that is, the value of the criterion associated with the clustering method for the particular agglomeration.", 
    "     y = nrow(macnally):2, # Fusion Node.", "     labels = nrow(macnally):2, # Fusion Node.", 
    "     col = \"red\", cex = 0.8 # Text colour and size?", 
    "     )"), chunk_opts = list(label = "FusionPlt-solution", 
        exercise.reveal_solution = T)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_Ordination_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "FusionPlt", exercise = TRUE, 
        exercise.lines = 20, code = c("# Plot the fusion level values of the best clustering approach", 
        "plot(x = ______$______, # The clustering height: that is, the value of the criterion associated with the clustering method for the particular agglomeration.", 
        "     y = nrow(______):2, # Fusion Node.", "     type = \"S\", # type of plot desired? = stair steps.", 
        "     main = \"Fusion levels - UPGMA\", # Main title.", 
        "     ylab = \"k (number of clusters)\", # Y-lab label.", 
        "     xlab = \"h (node height)\", # x-lab label.", "     col = \"grey\", lwd = 2 # Line piloting arguments. ", 
        "     )", "", "# Use the text() function to define the Fusions level of each brake", 
        "text(x = ______$______, # The clustering height: that is, the value of the criterion associated with the clustering method for the particular agglomeration.", 
        "     y = nrow(macnally):2, # Fusion Node.", "     labels = nrow(macnally):2, # Fusion Node.", 
        "     col = \"red\", cex = 0.8 # Text colour and size?", 
        "     )"), out.width.px = 624, out.height.px = 384, params.src = "FusionPlt, exercise=TRUE, exercise.lines=20", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-BstNbrGrp-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-BstNbrGrp-code-editor`)), session)
output$`tutorial-exercise-BstNbrGrp-output` <- renderUI({
  `tutorial-exercise-BstNbrGrp-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "BstNbrGrp", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "BstNbrGrp", code = "# Plot the best clustering approach (hclust) object, adding the best-number of groups classification as labels.\nplot(x = ______, # An object of the type produced by hclust.\n     labels = cutree(______, 4), # A character vector of labels for the tree's leaves.\n     main = \"Four groups\\n UPGMA\", # Main title.\n     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.\n     ) ", 
        opts = list(label = "\"BstNbrGrp\"", exercise = "TRUE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = structure("grade_code()", chunk_opts = list(label = "BstNbrGrp-check")), 
    solution = structure(c("# Plot the best clustering approach (hclust) object, adding the best-number of groups classification as labels.", 
    "plot(x = Hclus.3, # An object of the type produced by hclust.", 
    "     labels = cutree(Hclus.3, 4), # A character vector of labels for the tree's leaves.", 
    "     main = \"Four groups\\n UPGMA\", # Main title.", "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
    "     ) "), chunk_opts = list(label = "BstNbrGrp-solution", 
        exercise.reveal_solution = T)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_Ordination_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "BstNbrGrp", exercise = TRUE, 
        code = c("# Plot the best clustering approach (hclust) object, adding the best-number of groups classification as labels.", 
        "plot(x = ______, # An object of the type produced by hclust.", 
        "     labels = cutree(______, 4), # A character vector of labels for the tree's leaves.", 
        "     main = \"Four groups\\n UPGMA\", # Main title.", 
        "     cex.main = 2, cex = 0.8, cex.axis = 1.2, cex.lab = 1.5 # Define the text sizes.", 
        "     ) "), out.width.px = 624, out.height.px = 384, 
        params.src = "BstNbrGrp, exercise=TRUE", fig.num = 0, 
        exercise.df_print = "paged"), engine = "r", version = "4"), class = c("r", 
"tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-FinNbClus-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-FinNbClus-code-editor`)), session)
output$`tutorial-exercise-FinNbClus-output` <- renderUI({
  `tutorial-exercise-FinNbClus-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "FinNbClus", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "FinNbClus", code = "# Choose the number of clusters\nk <- _____\n# Prune the UPGMA tree into six groups\nUPGMA.6groups <- cutree(tree = _____, # A tree as produced by hclust.\n                        k = k # Desired number of groups.\n                        )\n# Compute silhouette information according to a given clustering in k clusters\nsil <- silhouette(x = _____, # Vector with k different integer cluster codes.\n                  dist = macnally.dist # Original a dissimilarity object.\n                  )\n# give the names to sil based on of sites\nrownames(sil) <- row.names(macnally.clean)\n\n# Silhouette plot of the final partition\nplot(x = _____, # The silhouette object\n     main = \"Silhouette plot - Bray Curtis - UPGMA\", # Main tytle\n     cex.names = 0.8, # Size of text\n     col = 2:(k + 1) # Bar colours (one per group)\n     )", 
        opts = list(label = "\"FinNbClus\"", exercise = "TRUE", 
            exercise.lines = "20"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "FinNbClus-check")), solution = structure(c("# Choose the number of clusters", 
    "k <- 6", "# Prune the UPGMA tree into six groups", "UPGMA.6groups <- cutree(tree = Hclus.3, # A tree as produced by hclust.", 
    "                        k = k # Desired number of groups.", 
    "                        )", "# Compute silhouette information according to a given clustering in k clusters", 
    "sil <- silhouette(x = UPGMA.6groups, # Vector with k different integer cluster codes.", 
    "                  dist = macnally.dist # Original a dissimilarity object.", 
    "                  )", "# give the names to sil based on of sites", 
    "rownames(sil) <- row.names(macnally.clean)", "", "# Silhouette plot of the final partition", 
    "plot(x = sil, # The silhouette object", "     main = \"Silhouette plot - Bray Curtis - UPGMA\", # Main tytle", 
    "     cex.names = 0.8, # Size of text", "     col = 2:(k + 1) # Bar colours (one per group)", 
    "     )"), chunk_opts = list(label = "FinNbClus-solution", 
        exercise.reveal_solution = T)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_Ordination_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "FinNbClus", exercise = TRUE, 
        exercise.lines = 20, code = c("# Choose the number of clusters", 
        "k <- _____", "# Prune the UPGMA tree into six groups", 
        "UPGMA.6groups <- cutree(tree = _____, # A tree as produced by hclust.", 
        "                        k = k # Desired number of groups.", 
        "                        )", "# Compute silhouette information according to a given clustering in k clusters", 
        "sil <- silhouette(x = _____, # Vector with k different integer cluster codes.", 
        "                  dist = macnally.dist # Original a dissimilarity object.", 
        "                  )", "# give the names to sil based on of sites", 
        "rownames(sil) <- row.names(macnally.clean)", "", "# Silhouette plot of the final partition", 
        "plot(x = _____, # The silhouette object", "     main = \"Silhouette plot - Bray Curtis - UPGMA\", # Main tytle", 
        "     cex.names = 0.8, # Size of text", "     col = 2:(k + 1) # Bar colours (one per group)", 
        "     )"), out.width.px = 624, out.height.px = 384, params.src = "FinNbClus, exercise=TRUE, exercise.lines=20", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-iseuclid1-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-iseuclid1-code-editor`)), session)
output$`tutorial-exercise-iseuclid1-output` <- renderUI({
  `tutorial-exercise-iseuclid1-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "iseuclid1", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "iseuclid1", code = "# Is macnally.dist Euclidean?\n_______(macnally.dist)", 
        opts = list(label = "\"iseuclid1\"", exercise = "TRUE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = structure("grade_code()", chunk_opts = list(label = "iseuclid1-check")), 
    solution = structure(c("# Is macnally.dist Euclidean?", "is.euclid(macnally.dist)"
    ), chunk_opts = list(label = "iseuclid1-solution", exercise.reveal_solution = T)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_Ordination_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "iseuclid1", exercise = TRUE, 
        code = c("# Is macnally.dist Euclidean?", "_______(macnally.dist)"
        ), out.width.px = 624, out.height.px = 384, params.src = "iseuclid1, exercise=TRUE", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-iseuclid2-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-iseuclid2-code-editor`)), session)
output$`tutorial-exercise-iseuclid2-output` <- renderUI({
  `tutorial-exercise-iseuclid2-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "iseuclid2", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "iseuclid2", code = "## Lingoes correction\nmacnally.dist.Ling <- sqrt(_____)+1\n# Is it euclidean?\n_____(macnally.dist.Ling)\n\n## Cailliez correction\nmacnally.dist.Cail <- _____+1\n# Is it euclidean?\n_____(macnally.dist.Cail)\n\n## Sqrt correction\nmacnally.dist.Sqrt <- sqrt(_____)\n# Is it euclidean?\n_____(macnally.dist.Sqrt)", 
        opts = list(label = "\"iseuclid2\"", exercise = "TRUE", 
            exercise.lines = "20"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "iseuclid2-check")), solution = structure(c("## Lingoes correction", 
    "macnally.dist.Ling <- sqrt(macnally.dist)+1", "# Is it euclidean?", 
    "is.euclid(macnally.dist.Ling)", "", "## Cailliez correction", 
    "macnally.dist.Cail <- macnally.dist+1", "# Is it euclidean?", 
    "is.euclid(macnally.dist.Cail)", "", "## Sqrt correction", 
    "macnally.dist.Sqrt <- sqrt(macnally.dist)", "# Is it euclidean?", 
    "is.euclid(macnally.dist.Sqrt)"), chunk_opts = list(label = "iseuclid2-solution", 
        exercise.reveal_solution = T)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_Ordination_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "iseuclid2", exercise = TRUE, 
        exercise.lines = 20, code = c("## Lingoes correction", 
        "macnally.dist.Ling <- sqrt(_____)+1", "# Is it euclidean?", 
        "_____(macnally.dist.Ling)", "", "## Cailliez correction", 
        "macnally.dist.Cail <- _____+1", "# Is it euclidean?", 
        "_____(macnally.dist.Cail)", "", "## Sqrt correction", 
        "macnally.dist.Sqrt <- sqrt(_____)", "# Is it euclidean?", 
        "_____(macnally.dist.Sqrt)"), out.width.px = 624, out.height.px = 384, 
        params.src = "iseuclid2, exercise=TRUE, exercise.lines=20", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-PCoAV2-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-PCoAV2-code-editor`)), session)
output$`tutorial-exercise-PCoAV2-output` <- renderUI({
  `tutorial-exercise-PCoAV2-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "PCoAV2", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "PCoAV2", code = "# PCoA using pcoa - see that the number of PCoA assess to be extracted is defined\nmacnally.pcoa.V2 <- pcoa(__________,# An Euclidean distance matrix. \n                         correction = \"none\" # How to correct the distance matrix?\n                         )\n\n# Print the structure of the object created with the pcoa() function.\nstr(macnally.pcoa.V2)", 
        opts = list(label = "\"PCoAV2\"", exercise = "TRUE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = structure("grade_code()", chunk_opts = list(label = "PCoAV2-check")), 
    solution = structure(c("# PCoA using pcoa - see that the number of PCoA assess to be extracted is defined", 
    "macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,# An Euclidean distance matrix. ", 
    "                         correction = \"none\" # How to correct the distance matrix?", 
    "                         )", "", "# Print the structure of the object created with the pcoa() function.", 
    "str(macnally.pcoa.V2)"), chunk_opts = list(label = "PCoAV2-solution", 
        exercise.reveal_solution = T)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_Ordination_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "PCoAV2", exercise = TRUE, 
        code = c("# PCoA using pcoa - see that the number of PCoA assess to be extracted is defined", 
        "macnally.pcoa.V2 <- pcoa(__________,# An Euclidean distance matrix. ", 
        "                         correction = \"none\" # How to correct the distance matrix?", 
        "                         )", "", "# Print the structure of the object created with the pcoa() function.", 
        "str(macnally.pcoa.V2)"), out.width.px = 624, out.height.px = 384, 
        params.src = "PCoAV2, exercise=TRUE", fig.num = 0, exercise.df_print = "paged"), 
    engine = "r", version = "4"), class = c("r", "tutorial_exercise"
)))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-CumeigeValPlt-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-CumeigeValPlt-code-editor`)), session)
output$`tutorial-exercise-CumeigeValPlt-output` <- renderUI({
  `tutorial-exercise-CumeigeValPlt-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "CumeigeValPlt", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "CumeigeValPlt", code = "# Extract the Cumulative relative eigenvalues/variance.\nmacnally.CumulEig <- _________$ values$Cumul_eig\n\n## Plot the cumulative eigenvalues/variance. \nmacnally.barplot <- barplot(_________) \n\n## Add the y-axes names\ntext(x = as.numeric(_________)-0.5, # X-axis location.\n     y = rep(0, length(macnally.CumulEig)), # Y-axis location.\n     labels = paste(1:length(macnally.CumulEig), \"PCoA\", sep = \"_\"), # Text\n     srt = 45, xpd = NA, cex = 0.5, # Text arguments: angle (srt), plot in the full area (xpd), size of the text\n     pos = 1 # Position specifier for the text.\n     )\n\n# Add the Broken Stick expectation as a line\n\n# Extract the Cumulative broken stick fractions\nmacnally.CumulBrStick <-_________$ values$Cumul_br_stick\n\n# Add the Cumulative broken stick fractions as a line\nlines(x = macnally.barplot, # X-axis position.\n      y = _________, # Y-axis = Cumulative broken stick fractions\n      type = \"o\", # type of plot desired = overplotted points and lines\n      col = \"red\" # colour\n      )\n\n## Define the LAST PCoA axis where the observed cumulative variance is larger than that of a broken stick model\nmax(which(_________>_________))", 
        opts = list(label = "\"CumeigeValPlt\"", exercise = "TRUE", 
            exercise.lines = "30"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "CumeigeValPlt-check")), solution = structure(c("# Extract the Cumulative relative eigenvalues/variance.", 
    "macnally.CumulEig <- macnally.pcoa.V2$ values$Cumul_eig", 
    "", "## Plot the cumulative eigenvalues/variance. ", "macnally.barplot <- barplot(macnally.CumulEig) ", 
    "", "## Add the y-axes names", "text(x = as.numeric(macnally.barplot)-0.5, # X-axis location.", 
    "     y = rep(0, length(macnally.CumulEig)), # Y-axis location.", 
    "     labels = paste(1:length(macnally.CumulEig), \"PCoA\", sep = \"_\"), # Text", 
    "     srt = 45, xpd = NA, cex = 0.5, # Text arguments: angle (srt), plot in the full area (xpd), size of the text", 
    "     pos = 1 # Position specifier for the text.", "     )", 
    "", "# Add the Broken Stick expectation as a line", "", "# Extract the Cumulative broken stick fractions", 
    "macnally.CumulBrStick <-macnally.pcoa.V2$ values$Cumul_br_stick", 
    "", "# Add the Cumulative broken stick fractions as a line", 
    "lines(x = macnally.barplot, # X-axis position.", "      y = macnally.CumulBrStick, # Y-axis = Cumulative broken stick fractions", 
    "      type = \"o\", # type of plot desired = overplotted points and lines", 
    "      col = \"red\" # colour", "      )", "", "## Define the LAST PCoA axis where the observed cumulative variance is larger than that of a broken stick model", 
    "max(which(macnally.CumulEig>macnally.CumulBrStick))"), chunk_opts = list(
        label = "CumeigeValPlt-solution", exercise.reveal_solution = T)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_Ordination_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "CumeigeValPlt", exercise = TRUE, 
        exercise.lines = 30, code = c("# Extract the Cumulative relative eigenvalues/variance.", 
        "macnally.CumulEig <- _________$ values$Cumul_eig", "", 
        "## Plot the cumulative eigenvalues/variance. ", "macnally.barplot <- barplot(_________) ", 
        "", "## Add the y-axes names", "text(x = as.numeric(_________)-0.5, # X-axis location.", 
        "     y = rep(0, length(macnally.CumulEig)), # Y-axis location.", 
        "     labels = paste(1:length(macnally.CumulEig), \"PCoA\", sep = \"_\"), # Text", 
        "     srt = 45, xpd = NA, cex = 0.5, # Text arguments: angle (srt), plot in the full area (xpd), size of the text", 
        "     pos = 1 # Position specifier for the text.", "     )", 
        "", "# Add the Broken Stick expectation as a line", "", 
        "# Extract the Cumulative broken stick fractions", "macnally.CumulBrStick <-_________$ values$Cumul_br_stick", 
        "", "# Add the Cumulative broken stick fractions as a line", 
        "lines(x = macnally.barplot, # X-axis position.", "      y = _________, # Y-axis = Cumulative broken stick fractions", 
        "      type = \"o\", # type of plot desired = overplotted points and lines", 
        "      col = \"red\" # colour", "      )", "", "## Define the LAST PCoA axis where the observed cumulative variance is larger than that of a broken stick model", 
        "max(which(_________>_________))"), out.width.px = 624, 
        out.height.px = 384, params.src = "CumeigeValPlt, exercise=TRUE, exercise.lines=30", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-PCoAV2plot-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-PCoAV2plot-code-editor`)), session)
output$`tutorial-exercise-PCoAV2plot-output` <- renderUI({
  `tutorial-exercise-PCoAV2plot-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "PCoAV2plot", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "PCoAV2plot", code = "# Biplots based on pcoa\nbiplot.pcoa(x = ________, # Output object from pcoa\n            Y = macnally.clean, # Variables to be projected onto the ordination plot\n            main = \"PCoA Biplot\\n Response variables Projected as in PCA\" # Main title\n            )\n# Add a vertical and horizontal doted line at 0.\nabline(h = 0, v = 0, lty = 3)", 
        opts = list(label = "\"PCoAV2plot\"", exercise = "TRUE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = structure("grade_code()", chunk_opts = list(label = "PCoAV2plot-check")), 
    solution = structure(c("", "# Biplots based on pcoa", "biplot.pcoa(x = macnally.pcoa.V2, # Output object from pcoa", 
    "            Y = macnally.clean, # Variables to be projected onto the ordination plot", 
    "            main = \"PCoA Biplot\\n Response variables Projected as in PCA\" # Main title", 
    "            )", "# Add a vertical and horizontal doted line at 0.", 
    "abline(h = 0, v = 0, lty = 3)"), chunk_opts = list(label = "PCoAV2plot-solution", 
        exercise.reveal_solution = T)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_Ordination_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "PCoAV2plot", exercise = TRUE, 
        code = c("# Biplots based on pcoa", "biplot.pcoa(x = ________, # Output object from pcoa", 
        "            Y = macnally.clean, # Variables to be projected onto the ordination plot", 
        "            main = \"PCoA Biplot\\n Response variables Projected as in PCA\" # Main title", 
        "            )", "# Add a vertical and horizontal doted line at 0.", 
        "abline(h = 0, v = 0, lty = 3)"), out.width.px = 624, 
        out.height.px = 384, params.src = "PCoAV2plot, exercise=TRUE", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ObsByClust2-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ObsByClust2-code-editor`)), session)
output$`tutorial-exercise-ObsByClust2-output` <- renderUI({
  `tutorial-exercise-ObsByClust2-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ObsByClust2", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "ObsByClust2", code = "# Plot the PCoA space generated using the pcoa() function. \nbiplot(x = ________, # Output object from pcoa\n       main = \"PCoA with species weighted averages\" # Main title\n       )\n\n# Add a vertical and horizontal doted line at 0.\nabline(h = 0, v = 0, lty = 3)\n\n# Plot polygons grouping observations by cluster.\nmacnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt,\n                             k = (nrow(macnally.clean) - 1), eig = TRUE)\nordihull(ord = ________, # A result from an ordination.\n         choices = c(1, 2), # Axes shown.\n         groups = cutree(________, 6), # Factor giving the groups for which the graphical item is drawn\n         draw = \"polygon\", # ow should objects be represented on the plot? (lines or polygon )\n         col = 1:6 # Colour for each group.\n         )", 
        opts = list(label = "\"ObsByClust2\"", exercise = "TRUE", 
            exercise.lines = "20"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "ObsByClust2-check")), solution = structure(c("# Plot the PCoA space generated using the pcoa() function. ", 
    "biplot(x = macnally.pcoa.V2, # Output object from pcoa", 
    "       main = \"PCoA with species weighted averages\" # Main title", 
    "       )", "", "# Add a vertical and horizontal doted line at 0.", 
    "abline(h = 0, v = 0, lty = 3)", "", "# Plot polygons grouping observations by cluster.", 
    "macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt,", "                             k = (nrow(macnally.clean) - 1), eig = TRUE)", 
    "ordihull(ord = macnally.pcoa.V1, # A result from an ordination.", 
    "         choices = c(1, 2), # Axes shown.", "         groups = cutree(Hclus.3, 6), # Factor giving the groups for which the graphical item is drawn", 
    "         draw = \"polygon\", # ow should objects be represented on the plot? (lines or polygon )", 
    "         col = 1:6 # Colour for each group.", "         )"
    ), chunk_opts = list(label = "ObsByClust2-solution", exercise.reveal_solution = T)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_Ordination_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "ObsByClust2", exercise = TRUE, 
        exercise.lines = 20, code = c("# Plot the PCoA space generated using the pcoa() function. ", 
        "biplot(x = ________, # Output object from pcoa", "       main = \"PCoA with species weighted averages\" # Main title", 
        "       )", "", "# Add a vertical and horizontal doted line at 0.", 
        "abline(h = 0, v = 0, lty = 3)", "", "# Plot polygons grouping observations by cluster.", 
        "macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt,", 
        "                             k = (nrow(macnally.clean) - 1), eig = TRUE)", 
        "ordihull(ord = ________, # A result from an ordination.", 
        "         choices = c(1, 2), # Axes shown.", "         groups = cutree(________, 6), # Factor giving the groups for which the graphical item is drawn", 
        "         draw = \"polygon\", # ow should objects be represented on the plot? (lines or polygon )", 
        "         col = 1:6 # Colour for each group.", "         )"
        ), out.width.px = 624, out.height.px = 384, params.src = "ObsByClust2, exercise=TRUE, exercise.lines=20", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-NMDSv1-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-NMDSv1-code-editor`)), session)
output$`tutorial-exercise-NMDSv1-output` <- renderUI({
  `tutorial-exercise-NMDSv1-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "NMDSv1", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "NMDSv1", code = "# NMDS using the raw data matrix\nset.seed(99) # To ensure the results match those below\nmacnally.MDS.V1 <- metaMDS(comm = ___________, # Community data. \n                           k = 2, # Number of dimensions.\n                           distance = \"bray\", # Dissimilarity index used?\n                           try = ___________, # Minimum numbers of random starts?\n                           trace = 0 # Added to avoid printing the procedure\n                           )\nmacnally.MDS.V1\n", 
        opts = list(label = "\"NMDSv1\"", exercise = "TRUE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = structure("grade_code()", chunk_opts = list(label = "NMDSv1-check")), 
    solution = structure(c("# NMDS using the raw data matrix", 
    "set.seed(99) # To ensure the results match those below", 
    "macnally.MDS.V1 <- metaMDS(comm = macnally.clean, # Community data. ", 
    "                           k = 2, # Number of dimensions.", 
    "                           distance = \"bray\", # Dissimilarity index used?", 
    "                           try = 20, # Minimum numbers of random starts?", 
    "                           trace = 0 # Added to avoid printing the procedure", 
    "                           )", "macnally.MDS.V1"), chunk_opts = list(
        label = "NMDSv1-solution", exercise.reveal_solution = T)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_Ordination_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "NMDSv1", exercise = TRUE, 
        code = c("# NMDS using the raw data matrix", "set.seed(99) # To ensure the results match those below", 
        "macnally.MDS.V1 <- metaMDS(comm = ___________, # Community data. ", 
        "                           k = 2, # Number of dimensions.", 
        "                           distance = \"bray\", # Dissimilarity index used?", 
        "                           try = ___________, # Minimum numbers of random starts?", 
        "                           trace = 0 # Added to avoid printing the procedure", 
        "                           )", "macnally.MDS.V1", ""
        ), out.width.px = 624, out.height.px = 384, params.src = "NMDSv1, exercise=TRUE", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-NMDSstress-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-NMDSstress-code-editor`)), session)
output$`tutorial-exercise-NMDSstress-output` <- renderUI({
  `tutorial-exercise-NMDSstress-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "NMDSstress", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "NMDSstress", code = "# Extract the from the NMDS\nmacnally.MDS.V1$________", 
        opts = list(label = "\"NMDSstress\"", exercise = "TRUE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = structure("grade_code()", chunk_opts = list(label = "NMDSstress-check")), 
    solution = structure(c("# Extract the from the NMDS", "macnally.MDS.V1$stress"
    ), chunk_opts = list(label = "NMDSstress-solution", exercise.reveal_solution = T)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_Ordination_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "NMDSstress", exercise = TRUE, 
        code = c("# Extract the from the NMDS", "macnally.MDS.V1$________"
        ), out.width.px = 624, out.height.px = 384, params.src = "NMDSstress, exercise=TRUE", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-StressPlot-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-StressPlot-code-editor`)), session)
output$`tutorial-exercise-StressPlot-output` <- renderUI({
  `tutorial-exercise-StressPlot-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "StressPlot", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "StressPlot", code = "# Shepard Plot\n_________(object = macnally.MDS.V1, # The metaMDS model\n           pch = 19 , lty = 2# Point and line arguments\n           )", 
        opts = list(label = "\"StressPlot\"", exercise = "TRUE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = structure("grade_code()", chunk_opts = list(label = "StressPlot-check")), 
    solution = structure(c("# Shepard Plot", "stressplot(object = macnally.MDS.V1, # The metaMDS model", 
    "           pch = 19 , lty = 2# Point and line arguments", 
    "           )"), chunk_opts = list(label = "StressPlot-solution", 
        exercise.reveal_solution = T)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_Ordination_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "StressPlot", exercise = TRUE, 
        code = c("# Shepard Plot", "_________(object = macnally.MDS.V1, # The metaMDS model", 
        "           pch = 19 , lty = 2# Point and line arguments", 
        "           )"), out.width.px = 624, out.height.px = 384, 
        params.src = "StressPlot, exercise=TRUE", fig.num = 0, 
        exercise.df_print = "paged"), engine = "r", version = "4"), class = c("r", 
"tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-NMDSV2-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-NMDSV2-code-editor`)), session)
output$`tutorial-exercise-NMDSV2-output` <- renderUI({
  `tutorial-exercise-NMDSV2-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "NMDSV2", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "NMDSV2", code = "# Define the stress value for 19 different configurations From 2 to 20 groups\nstressplot.Bct <- sapply(2:20,\n                         function(k){\n                            NMDSTemp <- _______(comm = macnally.dist, # Dissimilarities\n                                                k = _______, # Number of dimensions.\n                                                try = 20, # Minimum numbers of random starts?\n                                                trace = 0 # Added to avoid printing the procedure\n                                                )\n                            NMDSTemp$stress # Extract the from the NMDS object.\n                           })\n\n## plot the Shepard stress plot\nplot(x = 2:20, # Number of axes\n     y = _______, # Stress value\n     type = \"o\", # Plot type\n     pch = 19, # Type of point.\n     col = \"red\", # Colour fo the point.\n     ylab = \"Stress\", # Y-axis label.\n     xlab = \"Number of dimensions\"# X-axis label.\n     )\n\n# Add the 0.1 critical value line\nabline(h = 0.1, # The y-value(s) for horizontal line(s).\n       lty = 3, lwd = 2 # Line width and type arguments.\n       )\n# Add the 0.05 critical value line\nabline(h = 0.05, # The y-value(s) for horizontal line(s).\n       lty = 4, lwd = 2 # Line width and type arguments.\n       )\n\n# Add a legend indicating the line type for each critical value\nlegend(\"topright\", # Position the legend?\n       lty = c(3,2), # The type of lines for each class.\n       legend = c(0.1,0.5), # The Text for each class in in the legend.\n       title = \"Critical Values\" # Main title\n       )", 
        opts = list(label = "\"NMDSV2\"", exercise = "TRUE", 
            exercise.lines = "30"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "NMDSV2-check")), solution = structure(c("# Define the stress value for 19 different configurations From 2 to 20 groups", 
    "stressplot.Bct <- sapply(2:20,", "                         function(k){", 
    "                            NMDSTemp <- metaMDS(comm = macnally.dist, # Dissimilarities", 
    "                                                k = k, # Number of dimensions.", 
    "                                                try = 20, # Minimum numbers of random starts?", 
    "                                                trace = 0 # Added to avoid printing the procedure", 
    "                                                )", "                            NMDSTemp$stress # Extract the from the NMDS object.", 
    "                           })", "", "## plot the Shepard stress plot", 
    "plot(x = 2:20, # Number of axes", "     y = stressplot.Bct, # Stress value", 
    "     type = \"o\", # Plot type", "     pch = 19, # Type of point.", 
    "     col = \"red\", # Colour fo the point.", "     ylab = \"Stress\", # Y-axis label.", 
    "     xlab = \"Number of dimensions\"# X-axis label.", "     )", 
    "", "# Add the 0.1 critical value line", "abline(h = 0.1, # The y-value(s) for horizontal line(s).", 
    "       lty = 3, lwd = 2 # Line width and type arguments.", 
    "       )", "# Add the 0.05 critical value line", "abline(h = 0.05, # The y-value(s) for horizontal line(s).", 
    "       lty = 4, lwd = 2 # Line width and type arguments.", 
    "       )", "", "# Add a legend indicating the line type for each critical value", 
    "legend(\"topright\", # Position the legend?", "       lty = c(3,2), # The type of lines for each class.", 
    "       legend = c(0.1,0.5), # The Text for each class in in the legend.", 
    "       title = \"Critical Values\" # Main title", "       )"
    ), chunk_opts = list(label = "NMDSV2-solution", exercise.reveal_solution = T)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_Ordination_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "NMDSV2", exercise = TRUE, 
        exercise.lines = 30, code = c("# Define the stress value for 19 different configurations From 2 to 20 groups", 
        "stressplot.Bct <- sapply(2:20,", "                         function(k){", 
        "                            NMDSTemp <- _______(comm = macnally.dist, # Dissimilarities", 
        "                                                k = _______, # Number of dimensions.", 
        "                                                try = 20, # Minimum numbers of random starts?", 
        "                                                trace = 0 # Added to avoid printing the procedure", 
        "                                                )", 
        "                            NMDSTemp$stress # Extract the from the NMDS object.", 
        "                           })", "", "## plot the Shepard stress plot", 
        "plot(x = 2:20, # Number of axes", "     y = _______, # Stress value", 
        "     type = \"o\", # Plot type", "     pch = 19, # Type of point.", 
        "     col = \"red\", # Colour fo the point.", "     ylab = \"Stress\", # Y-axis label.", 
        "     xlab = \"Number of dimensions\"# X-axis label.", 
        "     )", "", "# Add the 0.1 critical value line", "abline(h = 0.1, # The y-value(s) for horizontal line(s).", 
        "       lty = 3, lwd = 2 # Line width and type arguments.", 
        "       )", "# Add the 0.05 critical value line", "abline(h = 0.05, # The y-value(s) for horizontal line(s).", 
        "       lty = 4, lwd = 2 # Line width and type arguments.", 
        "       )", "", "# Add a legend indicating the line type for each critical value", 
        "legend(\"topright\", # Position the legend?", "       lty = c(3,2), # The type of lines for each class.", 
        "       legend = c(0.1,0.5), # The Text for each class in in the legend.", 
        "       title = \"Critical Values\" # Main title", "       )"
        ), out.width.px = 624, out.height.px = 384, params.src = "NMDSV2, exercise=TRUE, exercise.lines=30", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-StrChng-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-StrChng-code-editor`)), session)
output$`tutorial-exercise-StrChng-output` <- renderUI({
  `tutorial-exercise-StrChng-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "StrChng", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "StrChng", code = "## Define the change in stress as the number of axes increase\nStressChng <- stressplot.Bct[1:18] - stressplot.Bct[2:19]\n## Plot the relative change in stress\nStressChngBrPlt <- barplot(height = _________, # matrix of values describing the bars.\n                           names.arg = paste(2:18, 3:20, sep = \"to\"), # A vector of names to be plotted below each bar.\n                           xlab = \"Change in dimensions\", # X-axis label.\n                           ylab = \"Change in stress\",# y-axis label.\n                           las = 2 # Axis text orientation.\n                           )\n# Add a line showing the change in cumulative stress \nlines(x = _________, # X-axis position.\n      y = _________, # Cumulative stress.\n      type = \"b\", # Type of plot.\n      pch = 19, # Point type.\n      col = \"red\", #Point/line colour.\n      lwd = 3) # Line Arguments.", 
        opts = list(label = "\"StrChng\"", exercise = "TRUE", 
            exercise.lines = "20"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "StrChng-check")), solution = structure(c("## Define the change in stress as the number of axes increase", 
    "StressChng <- stressplot.Bct[1:18] - stressplot.Bct[2:19]", 
    "## Plot the relative change in stress", "StressChngBrPlt <- barplot(height = StressChng, # matrix of values describing the bars.", 
    "                           names.arg = paste(2:18, 3:20, sep = \"to\"), # A vector of names to be plotted below each bar.", 
    "                           xlab = \"Change in dimensions\", # X-axis label.", 
    "                           ylab = \"Change in stress\",# y-axis label.", 
    "                           las = 2 # Axis text orientation.", 
    "                           )", "# Add a line showing the change in cumulative stress ", 
    "lines(x = StressChngBrPlt, # X-axis position.", "      y = StressChng, # Cumulative stress.", 
    "      type = \"b\", # Type of plot.", "      pch = 19, # Point type.", 
    "      col = \"red\", #Point/line colour.", "      lwd = 3) # Line Arguments."
    ), chunk_opts = list(label = "StrChng-solution", exercise.reveal_solution = T)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_Ordination_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "StrChng", exercise = TRUE, 
        exercise.lines = 20, code = c("## Define the change in stress as the number of axes increase", 
        "StressChng <- stressplot.Bct[1:18] - stressplot.Bct[2:19]", 
        "## Plot the relative change in stress", "StressChngBrPlt <- barplot(height = _________, # matrix of values describing the bars.", 
        "                           names.arg = paste(2:18, 3:20, sep = \"to\"), # A vector of names to be plotted below each bar.", 
        "                           xlab = \"Change in dimensions\", # X-axis label.", 
        "                           ylab = \"Change in stress\",# y-axis label.", 
        "                           las = 2 # Axis text orientation.", 
        "                           )", "# Add a line showing the change in cumulative stress ", 
        "lines(x = _________, # X-axis position.", "      y = _________, # Cumulative stress.", 
        "      type = \"b\", # Type of plot.", "      pch = 19, # Point type.", 
        "      col = \"red\", #Point/line colour.", "      lwd = 3) # Line Arguments."
        ), out.width.px = 624, out.height.px = 384, params.src = "StrChng, exercise=TRUE, exercise.lines=20", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-NMDSBest-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-NMDSBest-code-editor`)), session)
output$`tutorial-exercise-NMDSBest-output` <- renderUI({
  `tutorial-exercise-NMDSBest-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "NMDSBest", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "NMDSBest", code = "# Define the Number of axes to use\nkUse <- min(which(stressplot.Bct<0.05))\n\n# Print the stress value for the selected number of axes. \nstressplot.Bct[_______]\n\n# Build the final NMDS\nmacnally.MDS.V3 <- metaMDS(comm = macnally.dist, # Dissimilarities\n                           k = _______+1, # Number of dimensions.\n                           try = 20, # Minimum numbers of random starts?\n                           trace = 0 # Added to avoid printing the procedure\n                           )\n\n# Make a stressplot of the final NMDS \n# Add the stress value to the figure main title.\nstressplot(object = _______,\n           main = paste0(\"NMDS with 6 axes\\n Stress =\",\n                          round(macnally.MDS.V3$stress,3)))\n\n# Make a stressplot of the NMDS  with 2 axes.\n# Add the stress value to the figure main title.\nstressplot(object = macnally.MDS.V1,\n           main = paste0(\"NMDS with 2 axes\\n Stress =\",\n                          round(macnally.MDS.V1$stress,3))\n           )", 
        opts = list(label = "\"NMDSBest\"", exercise = "TRUE", 
            exercise.lines = "25"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "NMDSBest-check")), solution = structure(c("# Define the Number of axes to use", 
    "kUse <- min(which(stressplot.Bct<0.05))", "", "# Print the stress value for the selected number of axes. ", 
    "stressplot.Bct[kUse]", "", "# Build the final NMDS", "macnally.MDS.V3 <- metaMDS(comm = macnally.dist, # Dissimilarities", 
    "                           k = kUse+1, # Number of dimensions.", 
    "                           try = 20, # Minimum numbers of random starts?", 
    "                           trace = 0 # Added to avoid printing the procedure", 
    "                           )", "", "# Make a stressplot of the final NMDS ", 
    "# Add the stress value to the figure main title.", "stressplot(object = macnally.MDS.V3,", 
    "           main = paste0(\"NMDS with 6 axes\\n Stress =\",", 
    "                          round(macnally.MDS.V3$stress,3)))", 
    "", "# Make a stressplot of the NMDS  with 2 axes.", "# Add the stress value to the figure main title.", 
    "stressplot(object = macnally.MDS.V1,", "           main = paste0(\"NMDS with 2 axes\\n Stress =\",", 
    "                          round(macnally.MDS.V1$stress,3))", 
    "           )"), chunk_opts = list(label = "NMDSBest-solution", 
        exercise.reveal_solution = T)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_Ordination_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "NMDSBest", exercise = TRUE, 
        exercise.lines = 25, code = c("# Define the Number of axes to use", 
        "kUse <- min(which(stressplot.Bct<0.05))", "", "# Print the stress value for the selected number of axes. ", 
        "stressplot.Bct[_______]", "", "# Build the final NMDS", 
        "macnally.MDS.V3 <- metaMDS(comm = macnally.dist, # Dissimilarities", 
        "                           k = _______+1, # Number of dimensions.", 
        "                           try = 20, # Minimum numbers of random starts?", 
        "                           trace = 0 # Added to avoid printing the procedure", 
        "                           )", "", "# Make a stressplot of the final NMDS ", 
        "# Add the stress value to the figure main title.", "stressplot(object = _______,", 
        "           main = paste0(\"NMDS with 6 axes\\n Stress =\",", 
        "                          round(macnally.MDS.V3$stress,3)))", 
        "", "# Make a stressplot of the NMDS  with 2 axes.", 
        "# Add the stress value to the figure main title.", "stressplot(object = macnally.MDS.V1,", 
        "           main = paste0(\"NMDS with 2 axes\\n Stress =\",", 
        "                          round(macnally.MDS.V1$stress,3))", 
        "           )"), out.width.px = 624, out.height.px = 384, 
        params.src = "NMDSBest, exercise=TRUE, exercise.lines=25", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-NMDSPlot-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-NMDSPlot-code-editor`)), session)
output$`tutorial-exercise-NMDSPlot-output` <- renderUI({
  `tutorial-exercise-NMDSPlot-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "NMDSPlot", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "NMDSPlot", code = "## Build the NMDS with 3 axes\nmacnally.MDS.V4 <- metaMDS(comm = macnally.clean, # Community data. \n                           k = 3, # Number of dimensions.\n                           distance = \"bray\", # Dissimilarity index used?\n                           try = 20, # Minimum numbers of random starts?\n                           trace = 0 # Added to avoid printing the procedure\n                           )\n\n# plot the first and second  NMDS axes\nplot(____________, # The NMDS object \n     display = c(\"species\", \"sites\"), # Display \"sites\" AND \"species\".\n     choices = c(____________, ____________), # Axes shown\n     type = \"p\", # Plot type: \"p\" for points, \"t\" for text, and \"n\" for axes only.\n     main = c(\"NMDS axes 1 and 2\") # main Title\n     )\n\n# Plot the first and third two NMDS axes\nplot(____________, # The NMDS object \n     display = c(\"species\", \"sites\"), # Display \"sites\" AND \"species\".\n     choices = c(____________, ____________), # Axes shown\n     type = \"p\", # Plot type: \"p\" for points, \"t\" for text, and \"n\" for axes only.\n     main = c(\"NMDS axes 1 and 3\") # main Title\n     )\n\n# Plot the second and third two NMDS axes\nplot(____________, # The NMDS object \n     display = c(\"species\", \"sites\"), # Display \"sites\" AND \"species\".\n     choices = c(____________, ____________), # Axes shown\n     type = \"p\", # Plot type: \"p\" for points, \"t\" for text, and \"n\" for axes only.\n     main = c(\"NMDS axes 2 and 3\") # main Title\n     )\n", 
        opts = list(label = "\"NMDSPlot\"", exercise = "TRUE", 
            exercise.lines = "30"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "NMDSPlot-check")), solution = structure(c("## Build the NMDS with 3 axes", 
    "macnally.MDS.V4 <- metaMDS(comm = macnally.clean, # Community data. ", 
    "                           k = 3, # Number of dimensions.", 
    "                           distance = \"bray\", # Dissimilarity index used?", 
    "                           try = 20, # Minimum numbers of random starts?", 
    "                           trace = 0 # Added to avoid printing the procedure", 
    "                           )", "", "# plot the first and second  NMDS axes", 
    "plot(macnally.MDS.V4, # The NMDS object ", "     display = c(\"species\", \"sites\"), # Display \"sites\" AND \"species\".", 
    "     choices = c(1, 2), # Axes shown", "     type = \"p\", # Plot type: \"p\" for points, \"t\" for text, and \"n\" for axes only.", 
    "     main = c(\"NMDS axes 1 and 2\") # main Title", "     )", 
    "", "# Plot the first and third two NMDS axes", "plot(macnally.MDS.V4, # The NMDS object ", 
    "     display = c(\"species\", \"sites\"), # Display \"sites\" AND \"species\".", 
    "     choices = c(1, 3), # Axes shown", "     type = \"p\", # Plot type: \"p\" for points, \"t\" for text, and \"n\" for axes only.", 
    "     main = c(\"NMDS axes 1 and 3\") # main Title", "     )", 
    "", "# Plot the second and third two NMDS axes", "plot(macnally.MDS.V4, # The NMDS object ", 
    "     display = c(\"species\", \"sites\"), # Display \"sites\" AND \"species\".", 
    "     choices = c(2, 3), # Axes shown", "     type = \"p\", # Plot type: \"p\" for points, \"t\" for text, and \"n\" for axes only.", 
    "     main = c(\"NMDS axes 2 and 3\") # main Title", "     )", 
    "", ""), chunk_opts = list(label = "NMDSPlot-solution", exercise.reveal_solution = T)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_Ordination_cache/html/", cache.vars = NULL, 
        cache.lazy = TRUE, dependson = NULL, autodep = FALSE, 
        cache.rebuild = FALSE, fig.keep = "high", fig.show = "asis", 
        fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "NMDSPlot", exercise = TRUE, 
        exercise.lines = 30, code = c("## Build the NMDS with 3 axes", 
        "macnally.MDS.V4 <- metaMDS(comm = macnally.clean, # Community data. ", 
        "                           k = 3, # Number of dimensions.", 
        "                           distance = \"bray\", # Dissimilarity index used?", 
        "                           try = 20, # Minimum numbers of random starts?", 
        "                           trace = 0 # Added to avoid printing the procedure", 
        "                           )", "", "# plot the first and second  NMDS axes", 
        "plot(____________, # The NMDS object ", "     display = c(\"species\", \"sites\"), # Display \"sites\" AND \"species\".", 
        "     choices = c(____________, ____________), # Axes shown", 
        "     type = \"p\", # Plot type: \"p\" for points, \"t\" for text, and \"n\" for axes only.", 
        "     main = c(\"NMDS axes 1 and 2\") # main Title", 
        "     )", "", "# Plot the first and third two NMDS axes", 
        "plot(____________, # The NMDS object ", "     display = c(\"species\", \"sites\"), # Display \"sites\" AND \"species\".", 
        "     choices = c(____________, ____________), # Axes shown", 
        "     type = \"p\", # Plot type: \"p\" for points, \"t\" for text, and \"n\" for axes only.", 
        "     main = c(\"NMDS axes 1 and 3\") # main Title", 
        "     )", "", "# Plot the second and third two NMDS axes", 
        "plot(____________, # The NMDS object ", "     display = c(\"species\", \"sites\"), # Display \"sites\" AND \"species\".", 
        "     choices = c(____________, ____________), # Axes shown", 
        "     type = \"p\", # Plot type: \"p\" for points, \"t\" for text, and \"n\" for axes only.", 
        "     main = c(\"NMDS axes 2 and 3\") # main Title", 
        "     )", ""), out.width.px = 624, out.height.px = 384, 
        params.src = "NMDSPlot, exercise=TRUE, exercise.lines=30", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-NMDSHabi-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-NMDSHabi-code-editor`)), session)
output$`tutorial-exercise-NMDSHabi-output` <- renderUI({
  `tutorial-exercise-NMDSHabi-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "NMDSHabi", global_setup = structure(c("knitr::opts_chunk$set(echo = TRUE, eval = T)", 
"require(\"vegan\") # - vegan: Community Ecology Statistics including distance matrices  ", 
"require(\"cluster\")# - cluster: Identifying cluster goodness  ", 
"require(\"ade4\")# - ade4: Euclidean distance calculations  ", 
"require(\"ape\")# - ape: PCoA calculation  ", "require('learnr') #  learnr", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Laod data", 
"macnally <- read.csv( file = \"https://raw.githubusercontent.com/AlejoOrdonez/StaGeoMod2021/main/macnally.csv\")", 
"macnally.clean <- macnally[, -c(1:2, 105:107)]; rownames(macnally.clean) <- macnally$SITE", 
"macnally.dist <- vegdist(x = macnally.clean, method = \"bray\")", 
"Hclus.1 <- hclust(d = macnally.dist, method = \"single\")", 
"SingLin.dist <- cophenetic(Hclus.1)", "Hclus.2 <-  hclust(d = macnally.dist, method = \"complete\")", 
"CompLin.dist <- cophenetic(Hclus.2)", "Hclus.3 <- hclust(d = macnally.dist,method = \"average\")", 
"UPGMA.dist <- cophenetic(Hclus.3)", "Hclus.4 <- hclust(d = macnally.dist,method = \"ward.D2\")", 
"Ward.dist <- cophenetic(Hclus.4)", "", "## Ordination", "macnally.dist.Sqrt <- sqrt(macnally.dist)", 
"# PCoA using cmdscale - see that the number of PCoA assess to be extracted is defined", 
"#macnally.pcoa.V1 <- cmdscale(d = macnally.dist.Sqrt, k = (nrow(macnally.clean) - 1), eig = TRUE)", 
"macnally.pcoa.V2 <- pcoa(macnally.dist.Sqrt,correction = \"none\")", 
"macnally.MDS.V1 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)", 
"stressplot.Bct <- sapply(2:20,", "                         function(k){", 
"                           NMDSTemp <- metaMDS(comm = macnally.dist,k = k, try = 20, trace = 0)", 
"                           NMDSTemp$stress", "                         })", 
"macnally.MDS.V4 <- metaMDS(comm = macnally.clean, k = 2,distance = \"bray\",try = 20,trace = 0)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "NMDSHabi", code = "## Plot axis based on Pair List\n  plot(macnally.MDS.V4$______[,c(1,2)], # Which to axis to plot.\n       pch = 19, # Type of point.\n       col = factor(macnally$______), #Give the point colours based on the habitat.\n       main = \"NMDS axes 1 an 2\")\n\n## Add a polygon for the habitats\nordihull(ord = macnally.MDS.V4$______[, c(1,2)], # An ordination object\n         groups = factor(macnally$______), # Factor giving the groups for\n         draw = \"polygon\", # What to draw? lines or polygons?\n         col = 1:length(unique(macnally$______)), # colours based on the Habitat.\n         label = F)\nlegend(\"bottomleft\", # Position the legend?\n       fill = 1:length(unique(macnally$______)), #The type of colours  for each class.\n       legend = unique(macnally$______), # # The Text for each class in in the legend\n       title = \"Habitat types\", # Main title\n       xpd=NA,\n       cex=0.5) ", 
        opts = list(label = "\"NMDSHabi\"", exercise = "TRUE", 
            exercise.lines = "20"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "NMDSHabi-check")), solution = structure(c("## Plot axis based on Pair List", 
    "  plot(macnally.MDS.V4$points[,c(1,2)], # Which to axis to plot.", 
    "       pch = 19, # Type of point.", "       col = factor(macnally$HABITAT), #Give the point colours based on the habitat.", 
    "       main = \"NMDS axes 1 an 2\")", "", "## Add a polygon for the habitats", 
    "ordihull(ord = macnally.MDS.V4$points[, c(1,2)], # An ordination object", 
    "         groups = factor(macnally$HABITAT), # Factor giving the groups for", 
    "         draw = \"polygon\", # What to draw? lines or polygons?", 
    "         col = 1:length(unique(macnally$HABITAT)), # colours based on the Habitat.", 
    "         label = F)", "legend(\"bottomleft\", # Position the legend?", 
    "       fill = 1:length(unique(macnally$HABITAT)), #The type of colours  for each class.", 
    "       legend = unique(macnally$HABITAT), # # The Text for each class in in the legend", 
    "       title = \"Habitat types\", # Main title", "       xpd=NA,", 
    "       cex=0.5) "), chunk_opts = list(label = "NMDSHabi-solution", 
        exercise.reveal_solution = T)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_Ordination_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_Ordination_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ..., \n    solution_eval_fn = NULL) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "NMDSHabi", exercise = TRUE, 
        exercise.lines = 20, code = c("## Plot axis based on Pair List", 
        "  plot(macnally.MDS.V4$______[,c(1,2)], # Which to axis to plot.", 
        "       pch = 19, # Type of point.", "       col = factor(macnally$______), #Give the point colours based on the habitat.", 
        "       main = \"NMDS axes 1 an 2\")", "", "## Add a polygon for the habitats", 
        "ordihull(ord = macnally.MDS.V4$______[, c(1,2)], # An ordination object", 
        "         groups = factor(macnally$______), # Factor giving the groups for", 
        "         draw = \"polygon\", # What to draw? lines or polygons?", 
        "         col = 1:length(unique(macnally$______)), # colours based on the Habitat.", 
        "         label = F)", "legend(\"bottomleft\", # Position the legend?", 
        "       fill = 1:length(unique(macnally$______)), #The type of colours  for each class.", 
        "       legend = unique(macnally$______), # # The Text for each class in in the legend", 
        "       title = \"Habitat types\", # Main title", "       xpd=NA,", 
        "       cex=0.5) "), out.width.px = 624, out.height.px = 384, 
        params.src = "NMDSHabi, exercise=TRUE, exercise.lines=20", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "4"), class = c("r", "tutorial_exercise")))
</script>
</p>
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="dependencies">
{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["header-attrs"]},{"type":"character","attributes":{},"value":["2.16"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pandoc"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["header-attrs.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootstrap"]},{"type":"character","attributes":{},"value":["3.3.5"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/bootstrap"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["viewport"]}},"value":[{"type":"character","attributes":{},"value":["width=device-width, initial-scale=1"]}]},{"type":"character","attributes":{},"value":["js/bootstrap.min.js","shim/html5shiv.min.js","shim/respond.min.js"]},{"type":"character","attributes":{},"value":["css/cerulean.min.css"]},{"type":"character","attributes":{},"value":["<style>h1 {font-size: 34px;}\n       h1.title {font-size: 38px;}\n       h2 {font-size: 30px;}\n       h3 {font-size: 24px;}\n       h4 {font-size: 18px;}\n       h5 {font-size: 16px;}\n       h6 {font-size: 12px;}\n       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}\n       pre:not([class]) { background-color: white }<\/style>"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["pagedtable"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pagedtable-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/pagedtable.js"]},{"type":"character","attributes":{},"value":["css/pagedtable.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["textmate.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.10.7.9000"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["i18n"]},{"type":"character","attributes":{},"value":["21.6.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/i18n"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["i18next.min.js","tutorial-i18n-init.js"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["<script id=\"i18n-cstm-trns\" type=\"application/json\">{\"language\":\"en\",\"resources\":{\"en\":{\"translation\":{\"button\":{\"runcode\":\"Run Code\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Hint\",\"hint_plural\":\"Hints\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Next Hint\",\"hintprev\":\"Previous Hint\",\"solution\":\"Solution\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copy to Clipboard\",\"startover\":\"Start Over\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continue\",\"submitanswer\":\"Submit Answer\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Previous Topic\",\"nexttopic\":\"Next Topic\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Try Again\"},\"text\":{\"startover\":\"Start Over\",\"areyousure\":\"Are you sure you want to start over? (all exercise progress will be reset)\",\"youmustcomplete\":\"You must complete the\",\"exercise\":\"exercise\",\"exercise_plural\":\"exercises\",\"inthissection\":\"in this section before continuing.\",\"code\":\"Code\",\"enginecap\":\"{{engine}} $t(text.code)\",\"quiz\":\"Quiz\",\"blank\":\"blank\",\"blank_plural\":\"blanks\",\"exercisecontainsblank\":\"This exercise contains {{count}} $t(text.blank).\",\"pleasereplaceblank\":\"Please replace {{blank}} with valid code.\",\"unparsable\":\"It looks like this might not be valid R code. R cannot determine how to turn your text into a complete command. You may have forgotten to fill in a blank, to remove an underscore, to include a comma between arguments, or to close an opening <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> or <code>{<\\/code> with a matching <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code> or <code>}<\\/code>.\\n\",\"unparsablequotes\":\"<p>It looks like your R code contains specially formatted quotation marks or &quot;curly&quot; quotes (<code>{{character}}<\\/code>) around character strings, making your code invalid. R requires character values to be contained in straight quotation marks (<code>&quot;<\\/code> or <code>'<\\/code>).<\\/p> {{code}} <p>Don't worry, this is a common source of errors when you copy code from another app that applies its own formatting to text. You can try replacing the code on that line with the following. There may be other places that need to be fixed, too.<\\/p> {{suggestion}}\\n\",\"unparsableunicode\":\"<p>It looks like your R code contains an unexpected special character (<code>{{character}}<\\/code>) that makes your code invalid.<\\/p> {{code}} <p>Sometimes your code may contain a special character that looks like a regular character, especially if you copy and paste the code from another app. Try deleting the special character from your code and retyping it manually.<\\/p>\\n\",\"unparsableunicodesuggestion\":\"<p>It looks like your R code contains an unexpected special character (<code>{{character}}<\\/code>) that makes your code invalid.<\\/p> {{code}} <p>Sometimes your code may contain a special character that looks like a regular character, especially if you copy and paste the code from another app. You can try replacing the code on that line with the following. There may be other places that need to be fixed, too.<\\/p> {{suggestion}}\\n\",\"and\":\"and\",\"or\":\"or\",\"listcomma\":\", \",\"oxfordcomma\":\",\"}}},\"fr\":{\"translation\":{\"button\":{\"runcode\":\"Lancer le Code\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Indication\",\"hint_plural\":\"Indications\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Indication Suivante\",\"hintprev\":\"Indication Précédente\",\"solution\":\"Solution\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copier dans le Presse-papier\",\"startover\":\"Recommencer\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuer\",\"submitanswer\":\"Soumettre\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Chapitre Précédent\",\"nexttopic\":\"Chapitre Suivant\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Réessayer\"},\"text\":{\"startover\":\"Recommencer\",\"areyousure\":\"Êtes-vous certains de vouloir recommencer? (La progression sera remise à zéro)\",\"youmustcomplete\":\"Vous devez d'abord compléter\",\"exercise\":\"l'exercice\",\"exercise_plural\":\"des exercices\",\"inthissection\":\"de cette section avec de continuer.\",\"code\":\"Code\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"and\":\"et\",\"or\":\"ou\",\"oxfordcomma\":\"\"}}},\"es\":{\"translation\":{\"button\":{\"runcode\":\"Ejecutar código\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Pista\",\"hint_plural\":\"Pistas\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Siguiente pista\",\"hintprev\":\"Pista anterior\",\"solution\":\"Solución\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copiar al portapapeles\",\"startover\":\"Reiniciar\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuar\",\"submitanswer\":\"Enviar respuesta\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Tema anterior\",\"nexttopic\":\"Tema siguiente\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Volver a intentar\"},\"text\":{\"startover\":\"Reiniciar\",\"areyousure\":\"¿De verdad quieres empezar de nuevo? (todo el progreso del ejercicio se perderá)\",\"youmustcomplete\":\"Debes completar\",\"exercise\":\"el ejercicio\",\"exercise_plural\":\"los ejercicios\",\"inthissection\":\"en esta sección antes de continuar.\",\"code\":\"Código\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Cuestionario\",\"and\":\"y\",\"or\":\"o\",\"oxfordcomma\":\"\"}}},\"pt\":{\"translation\":{\"button\":{\"runcode\":\"Executar código\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Dica\",\"hint_plural\":\"Dicas\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Próxima dica\",\"hintprev\":\"Dica anterior\",\"solution\":\"Solução\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copiar para a área de transferência\",\"startover\":\"Reiniciar\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuar\",\"submitanswer\":\"Enviar resposta\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Tópico anterior\",\"nexttopic\":\"Próximo tópico\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Tentar novamente\"},\"text\":{\"startover\":\"Reiniciar\",\"areyousure\":\"Tem certeza que deseja começar novamente? (todo o progresso feito será perdido)\",\"youmustcomplete\":\"Você deve completar\",\"exercise\":\"o exercício\",\"exercise_plural\":\"os exercícios\",\"inthissection\":\"nesta seção antes de continuar.\",\"code\":\"Código\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"and\":\"e\",\"or\":\"ou\",\"oxfordcomma\":\"\"}}},\"tr\":{\"translation\":{\"button\":{\"runcode\":\"Çalıştırma Kodu\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Ipucu\",\"hint_plural\":\"İpuçları\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Sonraki İpucu\",\"hintprev\":\"Önceki İpucu\",\"solution\":\"Çözüm\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Pano'ya Kopyala\",\"startover\":\"Baştan Başlamak\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Devam et\",\"submitanswer\":\"Cevabı onayla\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Önceki Konu\",\"nexttopic\":\"Sonraki Konu\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Tekrar Deneyin\"},\"text\":{\"startover\":\"Baştan Başlamak\",\"areyousure\":\"Baştan başlamak istediğinizden emin misiniz? (tüm egzersiz ilerlemesi kaybolacak)\",\"youmustcomplete\":\"Tamamlamalısın\",\"exercise\":\"egzersiz\",\"exercise_plural\":\"egzersizler\",\"inthissection\":\"devam etmeden önce bu bölümde\",\"code\":\"Kod\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Sınav\",\"oxfordcomma\":\"\"}}},\"emo\":{\"translation\":{\"button\":{\"runcode\":\"🏃\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"💡\",\"hint_plural\":\"$t(button.hint)\",\"hinttitle\":\"$t(button.hint)\",\"solution\":\"🎯\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"📋\",\"startover\":\"⏮\",\"startovertitle\":\"Start Over\",\"continue\":\"✅\",\"submitanswer\":\"🆗\",\"submitanswertitle\":\"Submit Answer\",\"previoustopic\":\"⬅\",\"nexttopic\":\"➡\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"🔁\"},\"text\":{\"startover\":\"⏮\",\"areyousure\":\"🤔\",\"youmustcomplete\":\"⚠️ 👉 🧑‍💻\",\"exercise\":\"\",\"exercise_plural\":\"\",\"inthissection\":\"\",\"code\":\"💻\",\"enginecap\":\"$t(text.code) {{engine}}\",\"oxfordcomma\":\"\"}}},\"eu\":{\"translation\":{\"button\":{\"runcode\":\"Kodea egikaritu\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Laguntza\",\"hint_plural\":\"Laguntza\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Aurreko laguntza\",\"hintprev\":\"Hurrengo laguntza\",\"solution\":\"Ebazpena\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Arbelean kopiatu\",\"startover\":\"Berrabiarazi\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Jarraitu\",\"submitanswer\":\"Erantzuna bidali\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Aurreko atala\",\"nexttopic\":\"Hurrengo atala\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Berriro saiatu\"},\"text\":{\"startover\":\"Berrabiarazi\",\"areyousure\":\"Berriro hasi nahi duzu? (egindako lana galdu egingo da)\",\"youmustcomplete\":\"Aurrera egin baino lehen atal honetako\",\"exercise\":\"ariketa egin behar duzu.\",\"exercise_plural\":\"ariketak egin behar dituzu.\",\"inthissection\":\"\",\"code\":\"Kodea\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Galdetegia\",\"oxfordcomma\":\"\"}}},\"de\":{\"translation\":{\"button\":{\"runcode\":\"Code ausführen\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Tipp\",\"hint_plural\":\"Tipps\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Nächster Tipp\",\"hintprev\":\"Vorheriger Tipp\",\"solution\":\"Lösung\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"In die Zwischenablage kopieren\",\"startover\":\"Neustart\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Weiter\",\"submitanswer\":\"Antwort einreichen\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Vorheriges Kapitel\",\"nexttopic\":\"Nächstes Kapitel\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Nochmal versuchen\"},\"text\":{\"startover\":\"Neustart\",\"areyousure\":\"Bist du sicher, dass du neustarten willst? (der gesamte Lernfortschritt wird gelöscht)\",\"youmustcomplete\":\"Vervollstädinge\",\"exercise\":\"die Übung\",\"exercise_plural\":\"die Übungen\",\"inthissection\":\"in diesem Kapitel, bevor du fortfährst.\",\"code\":\"Code\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"blank\":\"Lücke\",\"blank_plural\":\"Lücken\",\"pleasereplaceblank\":\"Bitte ersetze {{blank}} mit gültigem Code.\",\"unparsable\":\"Dies scheint kein gültiger R Code zu sein. R kann deinen Text nicht in einen gültigen Befehl übersetzen. Du hast vielleicht vergessen, die Lücke zu füllen, einen Unterstrich zu entfernen, ein Komma zwischen Argumente zu setzen oder ein eröffnendes <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> oder <code>{<\\/code> mit einem zugehörigen <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code> oder <code>}<\\/code> zu schließen.\\n\",\"and\":\"und\",\"or\":\"oder\",\"listcomma\":\", \",\"oxfordcomma\":\",\"}}},\"ko\":{\"translation\":{\"button\":{\"runcode\":\"코드 실행\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"힌트\",\"hint_plural\":\"힌트들\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"다음 힌트\",\"hintprev\":\"이전 힌트\",\"solution\":\"솔루션\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"클립보드에 복사\",\"startover\":\"재학습\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"다음 학습으로\",\"submitanswer\":\"정답 제출\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"이전 토픽\",\"nexttopic\":\"다음 토픽\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"재시도\"},\"text\":{\"startover\":\"재학습\",\"areyousure\":\"다시 시작 하시겠습니까? (모든 예제의 진행 정보가 재설정됩니다)\",\"youmustcomplete\":\"당신은 완료해야 합니다\",\"exercise\":\"연습문제\",\"exercise_plural\":\"연습문제들\",\"inthissection\":\"이 섹션을 실행하기 전에\",\"code\":\"코드\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"퀴즈\",\"blank\":\"공백\",\"blank_plural\":\"공백들\",\"exercisecontainsblank\":\"이 연습문제에는 {{count}}개의 $t(text.blank)이 포함되어 있습니다.\",\"pleasereplaceblank\":\"{{blank}}를 유효한 코드로 바꾸십시오.\",\"unparsable\":\"이것은 유효한 R 코드가 아닐 수 있습니다. R은 텍스트를 완전한 명령으로 변환하는 방법을 결정할 수 없습니다. 당신은 공백이나 밑줄을 대체하여 채우기, 인수를 컴마로 구분하기, 또는 <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> , <code>{<\\/code>로 시작하는 구문을 닫는 <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code>, <code>}<\\/code>을 잊었을 수도 있습니다.\\n\",\"and\":\"그리고\",\"or\":\"혹은\",\"listcomma\":\", \",\"oxfordcomma\":\"\"}}},\"zh\":{\"translation\":{\"button\":{\"runcode\":\"运行代码\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"提示\",\"hint_plural\":\"提示\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"下一个提示\",\"hintprev\":\"上一个提示\",\"solution\":\"答案\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"复制到剪切板\",\"startover\":\"重新开始\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"继续\",\"submitanswer\":\"提交答案\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"上一专题\",\"nexttopic\":\"下一专题\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"再试一次\"},\"text\":{\"startover\":\"重置\",\"areyousure\":\"你确定要重新开始吗? (所有当前进度将被重置)\",\"youmustcomplete\":\"你必须完成\",\"exercise\":\"练习\",\"exercise_plural\":\"练习\",\"inthissection\":\"在进行本节之前\",\"code\":\"代码\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"测试\",\"blank\":\"空\",\"blank_plural\":\"空\",\"exercisecontainsblank\":\"本练习包含{{count}}个$t(text.blank)\",\"pleasereplaceblank\":\"请在{{blank}}内填写恰当的代码\",\"unparsable\":\"这似乎不是有效的R代码。 R不知道如何将您的文本转换为完整的命令。 您是否忘了填空，忘了删除下划线，忘了在参数之间包含逗号，或者是忘了用<code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code>,<code>}<\\/code>来封闭<code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code>。 or <code>{<\\/code>。\\n\",\"unparsablequotes\":\"<p>您的R代码中似乎含有特殊格式的引号，或者弯引号(<code>{{character}}<\\/code>) 在字符串前后，在R中字符串应该被直引号(<code>&quot;<\\/code> 或者 <code>'<\\/code>)包裹。<\\/p> {{code}} <p>别担心，该错误经常在复制粘贴包含格式的代码时遇到， 您可以尝试将该行中的代码替换为以下代码，也许还有其他地方需要修改。<\\/p> {{suggestion}}\\n\",\"unparsableunicode\":\"<p>您的代码中似乎包含有异常字符(<code>{{character}}<\\/code>),导致代码无效。<\\/p> {{code}} <p>有时候你的代码可能含有看似正常字符的特殊字符，特别是当你复制粘贴其他来源代码的时候。 请试着删除这些特殊字符,重新输入<\\/p>\\n\",\"unparsableunicodesuggestion\":\"<p>您的代码中似乎包含有异常字符(<code>{{character}}<\\/code>),导致代码无效。<\\/p> {{code}} <p>有时候你的代码可能含有看似正常字符的特殊字符，特别是当你复制粘贴其他来源代码的时候。 请试着删除这些特殊字符,重新输入<\\/p>\\n\",\"and\":\"且\",\"or\":\"或\",\"listcomma\":\",\",\"oxfordcomma\":\",\"}}},\"pl\":{\"translation\":{\"button\":{\"runcode\":\"Uruchom kod\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Podpowiedź\",\"hint_plural\":\"Podpowiedzi\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Następna podpowiedź\",\"hintprev\":\"Poprzednia podpowiedź\",\"solution\":\"Rozwiązanie\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Kopiuj do schowka\",\"startover\":\"Zacznij od początku\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Kontynuuj\",\"submitanswer\":\"Wyślij\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Poprzednia sekcja\",\"nexttopic\":\"Następna sekcja\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Spróbuj ponownie\"},\"text\":{\"startover\":\"Zacznij od początku\",\"areyousure\":\"Czy na pewno chcesz zacząć od początku? (cały postęp w zadaniu zostanie utracony)\",\"youmustcomplete\":\"Musisz ukończyć\",\"exercise\":\"ćwiczenie\",\"exercise_plural\":\"ćwiczenia\",\"inthissection\":\"w tej sekcji przed kontynuowaniem\",\"code\":\"Kod\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"blank\":\"luka\",\"blank_plural\":\"luk(i)\",\"exercisecontainsblank\":\"To ćwiczenie zawiera {{count}} $t(text.blank).\",\"pleasereplaceblank\":\"Proszę uzupełnić {{blank}} prawidłowym kodem.\",\"unparsable\":\"Wygląda na to, że może to nie być prawidłowy kod R. R nie jest w stanie przetworzyć Twojego tekstu na polecenie. Mogłeś(-aś) zapomnieć wypełnić luki, usunąć podkreślnik, umieścić przecinka między argumentami, lub zamknąć znak <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> lub <code>{<\\/code> odpowiadającym <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code> lub <code>}<\\/code>.\\n\",\"unparsablequotes\":\"<p>Wygląda na to, że Twój kod zawiera szczególnie sformatowane cudzysłowy lub cudzysłowy typograficzne (<code>{{character}}<\\/code>) przy ciągach znaków, co sprawia, że kod jest niepoprawny. R wymaga cudzysłowów prostych (<code>&quot;<\\/code> albo <code>'<\\/code>).<\\/p> {{code}} <p>Nie martw się, to powszechne źródło błędów, gdy kopiuje się kod z innego programu, który sam formatuje teskt. Możesz spróbować zastąpić swój kod następującym kodem. Mogą być też inne miejsca, które wymagają poprawienia.<\\/p> {{suggestion}}\\n\",\"unparsableunicode\":\"<p>Wygląda na to, że Twój kod zawiera niespodziewany znak specjalny (<code>{{character}}<\\/code>), co sprawia, że kod jest niepoprawny.<\\/p> {{code}} <p>Czasami Twój kod może zawierać znak specjalny, który wygląda jak zwykły znak, zwłaszcza jeśli kopiujesz kod z innego programu. Spróbuj usunąć znak specjalny i wpisać do ponownie ręcznie.<\\/p>\\n\",\"unparsableunicodesuggestion\":\"<p>Wygląda na to, że Twój kod zawiera niespodziewany znak specjalny (<code>{{character}}<\\/code>), co sprawia, że kod jest niepoprawny.<\\/p> {{code}} <p>Czasami Twój kod może zawierać znak specjalny, który wygląda jak zwykły znak, zwłaszcza jeśli kopiujesz kod z innego programu. Możesz spróbować zastąpić swój kod następującym kodem. Mogą być też inne miejsca, które wymagają poprawienia.<\\/p> {{suggestion}}\\n\",\"and\":\"i\",\"or\":\"lub\",\"listcomma\":\", \",\"oxfordcomma\":\"\"}}}}}<\/script>"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-format"]},{"type":"character","attributes":{},"value":["0.10.7.9000"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmarkdown/templates/tutorial/resources"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-format.js"]},{"type":"character","attributes":{},"value":["tutorial-format.css","rstudio-theme.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["navigation"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/navigation-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tabsets.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["default.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["font-awesome"]},{"type":"character","attributes":{},"value":["5.1.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/fontawesome"]}]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["css/all.css","css/v4-shims.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.16"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootbox"]},{"type":"character","attributes":{},"value":["5.5.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/bootbox"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["bootbox.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["idb-keyvalue"]},{"type":"character","attributes":{},"value":["3.2.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/idb-keyval"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["idb-keyval-iife-compat.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.10.7.9000"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.7.9000"]}]}]}
</script>
<!--/html_preserve-->
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="execution_dependencies">
{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages"]}},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages","version"]},"class":{"type":"character","attributes":{},"value":["data.frame"]},"row.names":{"type":"integer","attributes":{},"value":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60]}},"value":[{"type":"character","attributes":{},"value":["ade4","ape","backports","base","bslib","cachem","checkmate","cli","cluster","compiler","curl","datasets","digest","ellipsis","evaluate","fastmap","gradethis","graphics","grDevices","grid","htmltools","htmlwidgets","httpuv","jquerylib","jsonlite","knitr","later","lattice","learnr","lifecycle","magrittr","markdown","MASS","Matrix","methods","mgcv","mime","nlme","parallel","permute","promises","R6","Rcpp","rlang","rmarkdown","rprojroot","rstudioapi","sass","shiny","splines","stats","stringi","stringr","tools","utils","vegan","withr","xfun","xtable","yaml"]},{"type":"character","attributes":{},"value":["1.7-19","5.6-2","1.4.1","4.2.2","0.4.0","1.0.6","2.1.0","3.4.0","2.1.4","4.2.2","4.3.2","4.2.2","0.6.29","0.3.2","0.16","1.1.0","0.2.10.9000","4.2.2","4.2.2","4.2.2","0.5.3","1.5.4","1.6.6","0.1.4","1.8.0","1.40","1.3.0","0.20-45","0.10.7.9000","1.0.2","2.0.3","1.1","7.3-58.1","1.5-1","4.2.2","1.8-41","0.12","3.1-160","4.2.2","0.9-7","1.2.0.1","2.5.1","1.0.9","1.0.5","2.16","2.0.3","0.14","0.4.2","1.7.2","4.2.2","4.2.2","1.7.8","1.4.1","4.2.2","4.2.2","2.6-4","2.5.0","0.33","1.8-4","2.3.5"]}]}]}
</script>
<!--/html_preserve-->
</div>

</article> <!-- topics -->

<div class="topicsContainer">
<div class="topicsPositioner">
<div class="band">
<div class="bandContent topicsListContainer">

<!-- begin doc-metadata -->
<div id="doc-metadata">
<h1 class="title toc-ignore" style="display:none;">Spatial
Interpolation</h1>
</div>
<!-- end doc-metadata -->

</div> <!-- bandContent.topicsListContainer -->
</div> <!-- band -->
</div> <!-- topicsPositioner -->
</div> <!-- topicsContainer -->


</main> <!-- bandContent page -->
</div> <!-- pageContent band -->



<!-- Build Tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("section-TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<script>
// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});
</script>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>


</body>

</html>
