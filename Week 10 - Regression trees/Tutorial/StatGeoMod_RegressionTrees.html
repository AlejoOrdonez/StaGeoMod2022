<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />



<meta name="progressive" content="false" />
<meta name="allow-skip" content="false" />
<meta name="learnr-version-prerender" content="0.10.5.9000" />

<title>Classification and Regression Trees</title>

<!-- header-includes START -->
<!-- HEAD_CONTENT -->
<!-- header-includes END -->
<!-- HEAD_CONTENT -->

<!-- highlightjs -->
<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>


<!-- taken from https://github.com/rstudio/rmarkdown/blob/de8a9c38618903627ca509f5401d50a0876079f7/inst/rmd/h/default.html#L293-L343 -->
<!-- tabsets -->
<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>
<!-- end tabsets -->


</head>

<body>
<a class='sr-only sr-only-focusable visually-hidden-focusable' href='#learnr-tutorial-content'>Skip to Tutorial Content</a>



<div class="pageContent band">
<main class="bandContent page">

<article class="topics" id="learnr-tutorial-content">

<div id="section-supervised-classification-of-satellite-images"
class="section level2">
<h2>Supervised Classification of satellite images</h2>
<p>In supervised classification, you have prior knowledge about some of
the features of interest (in this case, land-cover types). In the
context of satellite images, this prior knowledge can come from, for
example, fieldwork, reference spatial data or interpretation of
high-resolution imagery (such as available on Google maps). Specific
sites in the study area that represent homogeneous examples of these
known land-cover types are identified. These areas are commonly referred
to as training sites because the spectral properties of these sites are
used to train the classification algorithm.</p>
</div>
<div id="section-reference-data" class="section level2">
<h2>Reference data</h2>
<p>As stated above, supervised classification is based on the principle
that you have prior knowledge about some of the features of interest. In
this case, you will use the United States National Land Cover Database
for the year 2011 (NLCD <a href="https://www.mrlc.gov/"
class="uri">https://www.mrlc.gov/</a>) to identify the spectral signal
of predefined land cover classes. The NLCD is a 30m Landsat-based land
cover database spanning four epochs (1992, 2001, 2006 and 2011). NLCD
2011 has two pairs of class values and names that correspond to the
levels of land use and land cover classification system (see <a
href="https://www.mrlc.gov/nlcd11_leg.php"
class="uri">https://www.mrlc.gov/nlcd11_leg.php</a> for the class names
in NCLD 2011). The names represent the level of complexity, level I (and
the one you will use) being the simplest, with broad land cover
categories.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Load the NLCD data into <code>R</code>. The NLCD data in the file
<code>nlcd-L1.tif</code> is a <code>RasterStack</code>, with two bands
located in R-Studio cloud data [see the Files tab in the lower right
window].</p>
<ul>
<li><p>Band 1 is the land cover classification for 2001.</p></li>
<li><p>Band-2 is the land cover classification for 2011.</p></li>
</ul>
</div>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Plot the Land Cover classification raster <code>nlcd</code>. Here,
define nine (9) values contrasting colour scheme using the
<code>hcl.colors()</code> function.</p>
</div>
<div class="tutorial-exercise" data-label="nlcdPlot" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="10">
<pre class="text"><code>plot(x = _______, # raster to plot.
     col = sample(hcl.colors(______, palette = &quot;Zissou&quot;)) # Define the colour ramp 
     )</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>However, it is impossible to determine the land-cover class for each
grid cell based on this figure. For this, you will need to define the
class names (the text name for each value in the raster). The object
<code>classdf</code> is where the class names and colours are put
together.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Print the <code>classdf</code> object to see the classification.</p>
</div>
<div class="tutorial-exercise" data-label="LookUpTble"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code>#Note from the table above that there is no class with value 6
_______</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-generate-sample-sites" class="section level2">
<h2>Generate sample sites</h2>
<p>Training and/or validation data can come from a variety of sources.
In this example, you will generate the training and validation sample
sites using the NLCD reference <code>RasterLayer.</code> Alternatively,
you can use predefined sites that you may have collected from other
sources. You will generate the sample sites following a stratified
random sampling to ensure each Land-Use/Land-Cover class is sampled
evenly.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Use the function <code>sampleStratified</code> from the
<code>raster</code> package to generate a stratified random sample of
the cell values of <code>nlcd2011</code>. You will select 200
observations per class.</p>
</div>
<div class="tutorial-exercise" data-label="StratSmpl"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="15">
<pre class="text"><code># Define  the training sites locations
# Set the random number generator to make the results reproducible.
set.seed(99)
# Sampling
samp2011 &lt;- sampleStratified(x = _____, # Raster to be &quot;sampled&quot;
                             size = _____, # Number of samples per class
                             na.rm = TRUE, # NA values are removed from random sample?
                             sp = TRUE # Output as a SpatialPointsDataFrame?
                             )

# Explore the data in samp2011 using the head() function.
_____(______)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>The stratified random sampling output is a
<code>SpatialPointsDataFrame</code> object (because the <code>sp</code>
argument is set to <code>TRUE</code>), which is <code>R</code>-speak for
a point-shapefile. Also, when printing the <code>samp2011</code> object,
you can see there are two variables. First, the <code>cell</code>
column, that contains the sampled cell numbers from
<code>nlcd2011</code>. Second, the <code>nlcd2011</code> column contains
the class values (1-9) corresponding to each Land Cover Class.</p>
<p>You have sampled many places of the <code>nlcd2011</code> Landcover
raster. <em>But how can you be sure that each class has 200 random
observations?</em> For this, you can tabulate the results from your
stratified random sampling using the function <code>table</code> (look
into <code>?table</code> to know how the function works)</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Tabulate the results from your stratified random sampling
<code>SpatialPointsDataFrame</code> using the function
<code>table</code> (look into <code>?table</code> to know how the
function works)</p>
</div>
<div class="tutorial-exercise" data-label="SmplTbl" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="10">
<pre class="text"><code># Extract the land cover classes identities (class values) for each plot sampled in the stratified random sample SpatialPointsDataFrame.
SampLCC &lt;- __________$_______

# Use the table() function to tabulate the number of land cover classes sampled by the `sampleStratified` function
______(______)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>The table above clearly shows that each land cover class has been
sampled precisely 200 times.</p>
</div>
<div id="section-extract-values-for-sites" class="section level2">
<h2>Extract values for sites</h2>
<p>Here you will use Landsat data (<code>landsat5</code>) already loaded
in the memory. As you now have a series of sites with an associated Land
cover class, you can extract the cell values from the
<code>landsat5</code> <code>RasterStack.</code> These band values will
be the predictor variables and “class values” from <code>nlcd2011</code>
will be the response variable. To extract these, you will use the
function <code>extract</code>.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Use the function <code>extract</code> to extract for each randomly
selected site per Landcover class the (those in <code>samp2011</code>)
hyperspectral bands in <code>landsat5</code>.</p>
</div>
<div class="tutorial-exercise" data-label="HiprSpcDta"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="20">
<pre class="text"><code># Extract the values from `landsat5`
sampvals &lt;- extract(x = ________, # Define the raster to be sampled.
                    y = ________, # Define the spatial vector data with the locations to sample.
                    df = TRUE # Return the results as a data.frame
                    )
# Explore sampvals
head(sampvals)

# combine the class information with extracted values
sampdata &lt;- data.frame(classvalue = samp2011@data$______, # Get the Landcover land cover classes identities from the samp2011 object.
                       ________[, -1] # The extracted data.frame with the hyperspectral bands in `landsat5` minus the ID column
                       )
# Explore the resulting data.frame using the head() function.
________(________)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-train-the-cart-classifier" class="section level2">
<h2>Train the CART classifier</h2>
<p>Now you will train the CART classification algorithm using
<code>sampdata</code> dataset. In this model, land cover classes are the
response variable (set up as a factor as these are coded as numbers in
the raster) and the ‘blue’, ‘green’, ‘red’, ‘NIR’, ‘SWIR1’, ‘SWIR2’
bands are the predictors.</p>
<p>For this, you will use the <code>rpart</code> function from the
<code>rpart</code> package. It is preferred to use the function
<code>rpart</code> instead of <code>tree</code> due to the way
<code>rpart</code> handles surrogate variables. Also, it follows Breiman
et al. (1984) [the reference that set the stage for this type of
regressions] quite closely. The name of the function stands for
‘Recursive Partitioning’. For this, you will use the functions in the
<code>rpart</code> package.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Load the <code>rpart</code> package and build a CART model ( using
the <code>rpart</code> function) that predicts land cover classes based
on the hyperspectral signal of sampled sites.</p>
<p>Remember that the response variable needs to be a factor!! So, you
can either Define the landcover class as a factor directly in the model
(that is use the <code>classvalue</code> variable in
<code>sampdata</code>) or recode <code>classnames1</code> as a factor in
<code>sampdata</code> before building the model. Here you will use the
first option.</p>
<p>One more point, This is a <strong>CLASIFICATION</strong> exercise.
This is a clue for you to know which type of model (one of
“<code>anova</code>”, “<code>poisson</code>”, “<code>class</code>” or
“<code>exp</code>”. ) you are building.</p>
</div>
<div class="tutorial-exercise" data-label="CART1" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="20">
<pre class="text"><code># Train the model
cartMod &lt;- rpart(formula = as.factor(________)~., # Define a formula linking the response (land cover classes) to the predictors (bands in Landsat5) - remember to Define the Land cover class as a factor
              data = ________, # Define the object with the response/predictors data!
              method = &#39;________&#39;, # Define the Type of model you are building.
              cp = 0.01, # Define the minimum level of increase in the complexity parameter
              minsplit = 5 #Define the minimum number of observations that must exist in a node in order for a split to be attempted
              )

# Show the contents of the classification model you just built using the
cartMod</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-plot-the-cart-classifier" class="section level2">
<h2>Plot the CART classifier</h2>
<p>As informative as the <code>print</code> of the <code>cartMod</code>
object is, the best way to evaluate a tree-based calcification is to
plot the classification tree.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Plot the classification tree <code>cartMod</code> you build in the
previous step.</p>
</div>
<div class="tutorial-exercise" data-label="CARTplt" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="15">
<pre class="text"><code># Plot the trained classification tree
plot(x = _______, # Define the classification/regression tree to plot.
     uniform = TRUE, # Use a uniform vertical spacing of the nodes?
     main = &quot;Classification Tree&quot; # Figure main title
     )

# Place the leaves Names on the dendrogram Plot
text(x = _______, # Define the classification/regression tree to plot,
     cex = 0.8 # Size of the text
     )</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>In the classification tree plot made above, class values are printed
at the leaf nodes. You can find the corresponding land cover names in
<code>classdf</code>.</p>
</div>
<div id="section-pruning-your-classification-tree---1"
class="section level2">
<h2>Pruning your classification tree - 1</h2>
<p>You will now focus on the set of procedures in <code>R</code> that
you can use to prune classification/regression trees (that is, cut them
at specific points). This “pruning” is based on the <em>cost–complexity
measure</em>, which is the base of model simplification in regression
trees.</p>
<p>One way to look at the changes in complexity is to generate a table
of <strong>Complexity Parameters</strong> and the associated errors
(<code>error</code> or deviance and <code>error</code> or
cross-validation error). For this, you will use both the
<code>printcp</code> and <code>plotcp</code> functions of the
<code>raprt</code> package.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p><strong>Print</strong> (using <code>printcp()</code>) and
<strong>plot</strong> (using <code>plotcp()</code>) the complexity
parameter Table for your CART model (<code>cartMod</code>).</p>
</div>
<div class="tutorial-exercise" data-label="CompParPrint"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="0">
<pre class="text"><code># Print the Complexity Parameter Table for a rpart Fit
_______(_______)

# Plot a Complexity Parameter Table for a rpart Fit. Here, note the dashed line, which shows the 1-SE of the minimum cp.
_______(_______)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-pruning-your-classification-tree---2a"
class="section level2">
<h2>Pruning your classification tree - 2a</h2>
<p>Model simplification in regression trees is the same as “pruning”
your tree at the point your complexity parameter full fills either of
two criteria:</p>
<ol style="list-style-type: decimal">
<li>The first level (i.e., least split) with minimum error. This is the
point where <em>xerror</em> starts increasing again. The first level
only kicks in when multiple levels have the same minimum error.
<strong>This is the method most commonly used</strong>.</li>
</ol>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Prune the classification tree using the <code>prune</code> function
using the minimum criteria - that is, where <code>xerror</code> is the
lowest.</p>
<p>Remember that your tree model is named <code>cartMod</code>, and that
you can get a table with the change in Complexity Parameters for a given
number of branches using the <code>printcp</code> function.</p>
<p>Finish by plotting the pruned tree.</p>
</div>
<div class="tutorial-exercise" data-label="CARTprune1"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="25">
<pre class="text"><code># Save the Complexity Parameter Table for Fitted rpart Object
printcpSumm &lt;- as.data.frame(printcp(_______))

# Pruning based on the minimum criteria
# Extract the complexity parameter where xerror is the lowest
CPVal.Min &lt;- printcpSumm[which.min(printcpSumm$_______), &quot;CP&quot;]

# Pruning based on the minimum criteria  
cartMod.pruned.1 &lt;- prune(_______, # Define the CART model to prune.
                       cp = _______ # Define the CP value at which the CART model will be pruned
                       )

# Plot the Pruned tree
plot(x = _______, # Define the classification/regression tree to plot.
     uniform = TRUE, # Use a uniform vertical spacing of the nodes?
     main = &quot;Classification Tree - min criteria&quot; # Figure main title
     )
# Place the leaf’s Names on the dendrogram Plot
text(x = _______, # Define the classification/regression tree to plot,
     cex = 0.8, # Size of the text
     xpd = NA)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>Based on the first criteria, the <code>cp</code> value with minimum
<code>xerror</code> is 0.012, a tree with ten (10) splits.</p>
</div>
<div id="section-pruning-your-classification-tree---2b"
class="section level2">
<h2>Pruning your classification tree - 2b</h2>
<p>Model simplification in regression trees is the same as “pruning”
your tree at the point your complexity parameter full fills either of
two criteria:</p>
<ol start="2" style="list-style-type: decimal">
<li>The first level where <em>error</em> falls into the ±1 <em>xstd</em>
range of min(error). That is, <span class="math inline">\(error &lt;
min(error) + xstd\)</span>. Graphically, it is the first level whose
error is at or below horizontal line dashed line when using the
<code>plotcp</code> function of <code>rpart.</code></li>
</ol>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Prune the classification tree using the <code>prune</code> function
utilising the xerror` ±1 xstd criteria - The first value was that the
xerror±xstd is at or below the min(xerror) + xstd.</p>
<p>Remember that your tree model is named <code>cartMod</code>, and that
you can get a table with the change in Complexity Parameters and their
variability for a given number of branches using the
<code>printcp</code> function.</p>
<p>Finish by plotting the pruned tree.</p>
</div>
<div class="tutorial-exercise" data-label="CARTprune2"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="30">
<pre class="text"><code># Pruning based on the ±1 xstd criteria
# Save the Complexity Parameter Table for Fitted rpart Object
printcpSumm &lt;- as.data.frame(_______(_______))

# What is the upper boundary of the min-xerror
MinxerrorUp &lt;- sum(printcpSumm[which.min(printcpSumm$_______),c(&quot;xerror&quot;,&quot;xstd&quot;)])

# What is the lower boundary of each xerror
Lowxerror &lt;- _______$xerror - _______$xstd

# Which number of splits is the first were Lowxerror &lt;= MinxerrorUp
Crit.Split &lt;-  min(which(_______ &lt;= _______))
  
# Extract the complexity parameter using the ±1 xstd range of min(error) criteria
CPVal.xstd &lt;- printcpSumm$_______[_______]

# Pruning based on the ±1 xstd criteria
cartMod.pruned.2 &lt;- prune(_______, # Define the CART model to prune.
                          cp = _______ # Define the CP value at which the CART model will be pruned
                       )
# Plot the Pruned tree
plot(x = _______, # Define the classification/regression tree to plot.
     uniform = TRUE, # Use a uniform vertical spacing of the nodes?
     main = &quot;Classification Tree - ±1 xstd criteria&quot; # Figure main title
     )
# Place the leaf’s Names on the dendrogram Plot
text(x = _______, # Define the classification/regression tree to plot,
     cex = 0.8, # Size of the text
     xpd = NA)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>Based on the second criteria, the <code>cp</code> value with
<code>xerror</code> ±1 xstd range of <code>min(xerror)</code> is 0.016,
a tree with eight (8) splits. This is the value where the xerror±xstd is
above the dashed line printed by <code>plotcp(cartMod)</code>.</p>
<p>Now you have done your first non-parametric regression to generate a
supervised classification of a satellite image!!. Now you will approach
the process of developing multiple models to address two of the central
problems with regression trees: these can be over-elaborated and respond
to random data features.</p>
</div>
<div id="section-model-evaluation---k-fold-validation"
class="section level2">
<h2>Model evaluation - K-fold validation</h2>
<p>Now that you have a classification model, you can evaluate the
accuracy of the prediction of it (e.g., its’ capacity to discriminate
between cultivated crops, pasture, grassland and shrubs).</p>
<p>To do this assessment, you can use a k-fold validation approach. For
this, you will use the <code>fold</code> function of the package
<code>dismo</code>). In this technique, the data used to fit the model
is split into <code>k</code> groups (typically five groups). In turn,
one of the groups will be used for model testing, while you will use the
rest of the data for model training (fitting).</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Do a five (5) k-fold partitioning of the training dataset
(<code>sampdata</code>), stratifying the folds by the Land Cover Class
(ensuring that all Classes, the <code>classvalue</code> variable is
<code>sampdata</code> are equally represented).</p>
</div>
<div class="tutorial-exercise" data-label="KFold" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="15">
<pre class="text"><code># set the random seed for reproducibility
set.seed(99)

# Do a k-fold partitioning of the training dataset
k.foldDta &lt;- kfold(_______, # the source data to use
                   k = _______, # number of Folds (here you use 5)
                   by = sampdata$_______) # define how to stratify the folds

# Tabulate the k-fold partitioning dataset by the Land Cover Class to see the number of samples per land cover class to be used in each fold.
table(_______,
      sampdata$_______)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>With the k-fold partitioning, you can now train and test your CART
model five times - five because you have five-folds!</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Train (using those points <strong>NOT</strong> in the k-fold dataset
<code>k.foldDta</code>) and test (using those points <strong>IN</strong>
the k-fold dataset <code>k.foldDta</code>) your <strong>CART</strong>
model.</p>
<p>For each of the five (5) folds, compute a confusion matrix and store
it as a component in a <code>CART.Kfold.List</code> list.</p>
<p>Finish by estimating the average confusion matrix over the five
folds.</p>
</div>
<div class="tutorial-exercise" data-label="CARTKfold"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="30">
<pre class="text"><code># Kfold Validation for the CART model
CART.Kfold.List &lt;- lapply(1:5, function(k){
# Define the Training data.frame - Observations NOT selected in the k-fold.
  train &lt;- sampdata[_________!= k, ]
# Define the test data.frame - Observations selected in the k-fold.
  test &lt;- _________[k.foldDta == k, ]

# Build a new CART model using the Train dataset
  cartMod.kfold.Mod &lt;- rpart(formula = as.factor(classvalue)~., # Define a formula linking the response (land cover classes) to the predictors (bands in Landsat5) - remember to Define the Land cover class as a factor
                             data = _________, # Define the object with the response/predictors data -  here is the training data.
                             method = &#39;class&#39;, # Define the Type of model you are building.
                             cp = 0.01, # Define the minimum level of increase in the complexity parameter
                             minsplit = 5 #Define the minimum number of observations that must exist in a node for a split to be attempted
                             )

# Predict the k-fold model on the test data.frame
  pclass &lt;- predict(object = _________, # Define the randomForest with the model.
                    newdata = _________, # Define data.frame used to make the prediction - here is the test data.
                    type = &quot;class&quot; # indicating the type of output
                    )
# create a table to compare the test-data and the prediction
  cbind(Observed = _________$classvalue,
        Predicted = as.numeric(as.vector(pclass)))
  })

# Confusion matrix for CART model the kfold validation
# Merge the tables in the list row-wise
CART.Kfold &lt;- do.call(&quot;rbind&quot;,
                      CART.Kfold.List)
# Make the matrix a data.frame
CART.Kfold &lt;- data.frame(CART.Kfold)

# Set the column names for the data.frame.
colnames(CART.Kfold) &lt;- c(&#39;observed&#39;, &#39;predicted&#39;)

# Tabulate the (miss)matches between the observed  and predicted test datasets
CART.conmat &lt;- table(_________)

# Change the name of the classes in the tabulation.
colnames(CART.conmat) &lt;- classdf[match(colnames(CART.conmat),classdf$classvalue1),&quot;nlcdclass&quot;]
rownames(CART.conmat) &lt;- classdf[match(rownames(CART.conmat),classdf$classvalue1),&quot;nlcdclass&quot;]

# Print the confusion matrix
CART.conmat/200</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Using the results of your cross-validation assessment
(<code>CART.conmat</code>), estimate the miss-classification rate
(proportion of observations wrongly classified by the model) for the
CART model.</p>
</div>
<div class="tutorial-exercise" data-label="MissClasRte"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="15">
<pre class="text"><code>### Miss classification of the CART model
CART.class.error &lt;- sapply(colnames(_______), # The cross-validation confusion matrix 
                           function(i){
                             sum(_______[i, !colnames(_______)%in%i])
                             })/apply(_______, 1, sum)

# Print the miss-classification of the RF model
CART.class.error

# Make a barplot of the miss-classification of the RF model
barplot(_______,
        main = &quot; CART model k-fold miss-classification rate&quot;,
        ylim =c(0,1))</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-global-model-evaluation" class="section level2">
<h2>Global Model evaluation</h2>
<p>Now that you have trained your classification model (CART), you can
use them to make predictions - even as these might not be the best
models!. For this, you will use the models to <em>classify</em> all
cells in <code>landsat5</code>. It is important that the layer names in
the RasterStack object to be classified exactly match those used as
predictors in the model. This would be the case if the same Raster
object were used (via extract) to obtain the values to fit the
model.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Use your CART model (<code>cartMod</code>) to predict land cover maps
for the region of interest using the information in
<code>landsat5</code>.</p>
</div>
<div class="tutorial-exercise" data-label="GlobMod" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="20">
<pre class="text"><code># Use the predict function (as implemented for raster objects and the CART model to generate predictors of land Cover classes for 2011.
CART.pr2011 &lt;- predict(object = _______, # Define the raster used to make the predictions.
                       model = _______, # Define the model used to make the predictions..
                       type = &#39;class&#39; # Define the type of predicted value returned  
                       )

# Plot the CART model PREDICTED map using the image() function and the HEX colours in classdf - remember that there is no class 6 in classdf, and so it does not have a colour.
image(_______,
     main = &quot;CART Predicted Land cover classification 2011&quot;, # Give the Name
     col = c(&quot;#5475A8&quot;, &quot;#B50000&quot;, &quot;#D2CDC0&quot;, &quot;#38814E&quot;, &quot;#AF963C&quot;,NA, &quot;#D1D182&quot;, &quot;#FBF65D&quot;, &quot;#C8E6F8&quot;))

# Add a legend linking land cover class names to the colours.
legend(&quot;topright&quot;, # Define the position the legend.
       inset = c(-0.24,0), # Define inset distance(s) from the margins.
       fill = classdf$_______, # Define the colours of each land cover class.
       legend  = classdf$_______, # Define each land cover class name.
       cex = 0.7, # Define the text size
       xpd=NA) # Plot outside the Figure region</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>Focusing on the modes, plotting and counting the misclassified cells
(observed != predicted), you can get an overview of the classification
error.</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Using your classified image (<code>CART.pr2011</code>), show the
misclassified cells (colour them <em>RED</em>) and those classified
correctly (colour them <em>BLUE</em>) by the CART model. for this you
will contrast <code>CART.pr2011</code> with the observed land cover
classification <code>nlcd2011</code>.</p>
<p>Also, estimate the proportion of all the cells that are misclassified
(wrong predictions) by the CART model.</p>
</div>
<div class="tutorial-exercise" data-label="ClasErr" data-completion="1"
data-diagnostics="1" data-startover="1" data-lines="10">
<pre class="text"><code># Use the image function to show the cells that are misclassified (Predicted != Observed) and classified correctly (Predicted == Observed) based on the CART model
image(_______ == _______, # Which cells are correctly classified (Predicted == Observed)
      main = &quot;CART misclassified cells&quot;,
      col = c(&quot;red&quot;, &quot;blue&quot;)) ## red is for areas misclassified

# Estimate the proportion of misclassified cells (Predicted != Observed)/Ncells for the CART model.
sum((_______!= _______)[])/ncell(nlcd2011) # sum of miss-classified cells (Predicted != Observed)</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
<p>Although visual inspections are OK and counts of miss-classified
cells show you the quality of the classification. You also want to
assess the per-class error rate (the number of observations in a class
the algorithm does misclassify)</p>
<div class="alert alert-info">
<p><strong>Your task:</strong></p>
<p>Estimate the confusion matrix for the raster’s predicted using the
CART model for this you will tabulate the cells correctly and
incorrectly classified by your model. That means contrasting your
predictions <code>CART.pr2011</code> and observations
<code>nlcd2011</code>.</p>
<p>Here the table will be build using the <em>“class names”</em> instead
of the numeric codes.</p>
</div>
<div class="tutorial-exercise" data-label="FullRAstAcc"
data-completion="1" data-diagnostics="1" data-startover="1"
data-lines="15">
<pre class="text"><code># Use the table() function to estimate the confusion matrix for the CART model
# The table is based on names and not numeric codes
CART.ConfMtx &lt;- table(classdf$nlcdclass[match(_________[], classdf$classvalue1)], # Names for each cell in the Observed raster
                      classdf$nlcdclass[match(_________[], classdf$classvalue1)] # Names for each cell in the Predicted raster
                      )

# Define the per-class error rate [proportion of the cells for a given land cover class correctly classified]
CARTclass.error &lt;- sapply(colnames(_________), # Do this by column manes in `CART.ConfMtx`
                          function(i){
                            sum(_________[i, !colnames(_________)%in%i]) # total of correctly classified per class
                            }) 

CARTclass.error/apply(_________, 1, sum) #Proportion of all observation in a class correctly classified</code></pre>
<script type="application/json" data-ui-opts="1">{"engine":"r","has_checker":true,"caption":"<span data-i18n=\"text.enginecap\" data-i18n-opts=\"{&quot;engine&quot;:&quot;R&quot;}\">R Code<\/span>"}</script>
</div>
</div>
<div id="section-final-points" class="section level2">
<h2>Final points</h2>
<p>Supervised classification is the technique most often used for the
quantitative analysis of remote sensing image data. At its core is the
concept of segmenting the spectral domain into regions that can be
associated with the ground cover classes of interest to a particular
application.</p>
<p>For example, you could use the PCA axes instead of the raw data in
the Landsat image. Alternatively, you could use more points to develop
your model (right now, you use 200 points that are not even 1% of the
available data - more data gives you a better model but requires more
computer power!!). I leave these tasks to the interested student! This
exercise gave you a guide of the procedure to do so, and although your
final model is not the best, it is the starting point for developing
this type of analysis.</p>
<p>
<script type="application/shiny-prerendered" data-context="server-start">
#Load packages
library(raster)
library(rpart)
library(dismo)
library(learnr)
# Setup
knitr::opts_chunk$set(echo = FALSE,
                      message = FALSE,
                      warning = FALSE)
gradethis::gradethis_setup()
tutorial_options(exercise.blanks = TRUE)

# Load the data
# Land Cover
nlcd <- stack("Data/nlcd-L1_Sml.tif")
names(nlcd) <- c("nlcd2001", "nlcd2011")
# Only 2011 data
nlcd2011 <- nlcd[[2]] # OR nlcd[["nlcd2011"]]

#table of classes
classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.
                      nlcdclass = c("Water", "Developed", "Barren", "Forest", "Shrubland", "Herbaceous", "Planted/Cultivated", "Wetlands"), # Class Name.
                      classcolor = c("#5475A8", "#B50000", "#D2CDC0", "#38814E", "#AF963C", "#D1D182", "#FBF65D", "#C8E6F8") # # Hex codes of colours.
                      )
# Satellite images
landsat5 <- stack("Data/centralvalley-2011LT5_Sml.tif")
names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')

# Stratified sampling
samp2011 <- sampleStratified(x = nlcd2011,size = 200,na.rm = TRUE, sp = TRUE)
# data for modelling
sampdata <- data.frame(classvalue = samp2011@data$nlcd2011,
                       extract(x = landsat5,y = samp2011,df = TRUE)[-1])
# CART model
cartMod <- rpart(formula = as.factor(classvalue)~.,data = sampdata,method = 'class',cp = 0.01,minsplit = 5)
# K-fold data 
k.foldDta <- kfold(sampdata, k = 5, by = sampdata$classvalue)
# Prediction
CART.pr2011 <- predict(object = landsat5, model = cartMod, type = 'class')


# Kfold Validation for the CART model
CART.Kfold.List <- lapply(1:5, function(k){
  train <- sampdata[k.foldDta!= k, ]
  test <- sampdata[k.foldDta == k, ]
  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~.,data = train, method = 'class', cp = 0.01, minsplit = 5)
  pclass <- predict(object = cartMod.kfold.Mod, newdata = test, type = "class")
  cbind(Observed = test$classvalue,
        Predicted = as.numeric(as.vector(pclass)))
  })
CART.Kfold <- do.call("rbind",CART.Kfold.List)
CART.Kfold <- data.frame(CART.Kfold)
colnames(CART.Kfold) <- c('observed', 'predicted')
CART.conmat <- table(CART.Kfold)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::register_http_handlers(session, metadata = NULL)
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::prepare_tutorial_state(session)
</script>
 
<script type="application/shiny-prerendered" data-context="server">
learnr:::i18n_observe_tutorial_language(input, session)
</script>


<script type="application/shiny-prerendered" data-context="server">
session$onSessionEnded(function() {
        learnr:::event_trigger(session, "session_stop")
      })
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-nlcdPlot-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-nlcdPlot-code-editor`)), session)
output$`tutorial-exercise-nlcdPlot-output` <- renderUI({
  `tutorial-exercise-nlcdPlot-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "nlcdPlot", global_setup = structure(c("#Load packages", 
"library(raster)", "library(rpart)", "library(dismo)", "library(learnr)", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Load the data", 
"# Land Cover", "nlcd <- stack(\"Data/nlcd-L1_Sml.tif\")", "names(nlcd) <- c(\"nlcd2001\", \"nlcd2011\")", 
"# Only 2011 data", "nlcd2011 <- nlcd[[2]] # OR nlcd[[\"nlcd2011\"]]", 
"", "#table of classes", "classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.", 
"                      nlcdclass = c(\"Water\", \"Developed\", \"Barren\", \"Forest\", \"Shrubland\", \"Herbaceous\", \"Planted/Cultivated\", \"Wetlands\"), # Class Name.", 
"                      classcolor = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\", \"#D1D182\", \"#FBF65D\", \"#C8E6F8\") # # Hex codes of colours.", 
"                      )", "# Satellite images", "landsat5 <- stack(\"Data/centralvalley-2011LT5_Sml.tif\")", 
"names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')", 
"", "# Stratified sampling", "samp2011 <- sampleStratified(x = nlcd2011,size = 200,na.rm = TRUE, sp = TRUE)", 
"# data for modelling", "sampdata <- data.frame(classvalue = samp2011@data$nlcd2011,", 
"                       extract(x = landsat5,y = samp2011,df = TRUE)[-1])", 
"# CART model", "cartMod <- rpart(formula = as.factor(classvalue)~.,data = sampdata,method = 'class',cp = 0.01,minsplit = 5)", 
"# K-fold data ", "k.foldDta <- kfold(sampdata, k = 5, by = sampdata$classvalue)", 
"# Prediction", "CART.pr2011 <- predict(object = landsat5, model = cartMod, type = 'class')", 
"", "", "# Kfold Validation for the CART model", "CART.Kfold.List <- lapply(1:5, function(k){", 
"  train <- sampdata[k.foldDta!= k, ]", "  test <- sampdata[k.foldDta == k, ]", 
"  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~.,data = train, method = 'class', cp = 0.01, minsplit = 5)", 
"  pclass <- predict(object = cartMod.kfold.Mod, newdata = test, type = \"class\")", 
"  cbind(Observed = test$classvalue,", "        Predicted = as.numeric(as.vector(pclass)))", 
"  })", "CART.Kfold <- do.call(\"rbind\",CART.Kfold.List)", "CART.Kfold <- data.frame(CART.Kfold)", 
"colnames(CART.Kfold) <- c('observed', 'predicted')", "CART.conmat <- table(CART.Kfold)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "nlcdPlot", code = "plot(x = _______, # raster to plot.\n     col = sample(hcl.colors(______, palette = \"Zissou\")) # Define the colour ramp \n     )", 
        opts = list(label = "\"nlcdPlot\"", exercise = "TRUE", 
            exercise.lines = "10"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "nlcdPlot-check")), solution = structure(c("plot(x = nlcd, # raster to plot.", 
    "     col = sample(hcl.colors(9, palette = \"Zissou\")) # Define the colour ramp ", 
    "     )"), chunk_opts = list(label = "nlcdPlot-solution", 
        exercise.reveal_solution = F)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_RegressionTrees_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_RegressionTrees_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "nlcdPlot", exercise = TRUE, 
        exercise.lines = 10, code = c("plot(x = _______, # raster to plot.", 
        "     col = sample(hcl.colors(______, palette = \"Zissou\")) # Define the colour ramp ", 
        "     )"), out.width.px = 624, out.height.px = 384, params.src = "nlcdPlot, exercise=TRUE, exercise.lines=10", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-LookUpTble-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-LookUpTble-code-editor`)), session)
output$`tutorial-exercise-LookUpTble-output` <- renderUI({
  `tutorial-exercise-LookUpTble-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "LookUpTble", global_setup = structure(c("#Load packages", 
"library(raster)", "library(rpart)", "library(dismo)", "library(learnr)", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Load the data", 
"# Land Cover", "nlcd <- stack(\"Data/nlcd-L1_Sml.tif\")", "names(nlcd) <- c(\"nlcd2001\", \"nlcd2011\")", 
"# Only 2011 data", "nlcd2011 <- nlcd[[2]] # OR nlcd[[\"nlcd2011\"]]", 
"", "#table of classes", "classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.", 
"                      nlcdclass = c(\"Water\", \"Developed\", \"Barren\", \"Forest\", \"Shrubland\", \"Herbaceous\", \"Planted/Cultivated\", \"Wetlands\"), # Class Name.", 
"                      classcolor = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\", \"#D1D182\", \"#FBF65D\", \"#C8E6F8\") # # Hex codes of colours.", 
"                      )", "# Satellite images", "landsat5 <- stack(\"Data/centralvalley-2011LT5_Sml.tif\")", 
"names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')", 
"", "# Stratified sampling", "samp2011 <- sampleStratified(x = nlcd2011,size = 200,na.rm = TRUE, sp = TRUE)", 
"# data for modelling", "sampdata <- data.frame(classvalue = samp2011@data$nlcd2011,", 
"                       extract(x = landsat5,y = samp2011,df = TRUE)[-1])", 
"# CART model", "cartMod <- rpart(formula = as.factor(classvalue)~.,data = sampdata,method = 'class',cp = 0.01,minsplit = 5)", 
"# K-fold data ", "k.foldDta <- kfold(sampdata, k = 5, by = sampdata$classvalue)", 
"# Prediction", "CART.pr2011 <- predict(object = landsat5, model = cartMod, type = 'class')", 
"", "", "# Kfold Validation for the CART model", "CART.Kfold.List <- lapply(1:5, function(k){", 
"  train <- sampdata[k.foldDta!= k, ]", "  test <- sampdata[k.foldDta == k, ]", 
"  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~.,data = train, method = 'class', cp = 0.01, minsplit = 5)", 
"  pclass <- predict(object = cartMod.kfold.Mod, newdata = test, type = \"class\")", 
"  cbind(Observed = test$classvalue,", "        Predicted = as.numeric(as.vector(pclass)))", 
"  })", "CART.Kfold <- do.call(\"rbind\",CART.Kfold.List)", "CART.Kfold <- data.frame(CART.Kfold)", 
"colnames(CART.Kfold) <- c('observed', 'predicted')", "CART.conmat <- table(CART.Kfold)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "LookUpTble", code = "#Note from the table above that there is no class with value 6\n_______", 
        opts = list(label = "\"LookUpTble\"", exercise = "TRUE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = structure("grade_code()", chunk_opts = list(label = "LookUpTble-check")), 
    solution = structure(c("#Note from the table above that there is no class with value 6", 
    "classdf"), chunk_opts = list(label = "LookUpTble-solution", 
        exercise.reveal_solution = F)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_RegressionTrees_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_RegressionTrees_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "LookUpTble", exercise = TRUE, 
        code = c("#Note from the table above that there is no class with value 6", 
        "_______"), out.width.px = 624, out.height.px = 384, 
        params.src = "LookUpTble, exercise=TRUE", fig.num = 0, 
        exercise.df_print = "paged"), engine = "r", version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-StratSmpl-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-StratSmpl-code-editor`)), session)
output$`tutorial-exercise-StratSmpl-output` <- renderUI({
  `tutorial-exercise-StratSmpl-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "StratSmpl", global_setup = structure(c("#Load packages", 
"library(raster)", "library(rpart)", "library(dismo)", "library(learnr)", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Load the data", 
"# Land Cover", "nlcd <- stack(\"Data/nlcd-L1_Sml.tif\")", "names(nlcd) <- c(\"nlcd2001\", \"nlcd2011\")", 
"# Only 2011 data", "nlcd2011 <- nlcd[[2]] # OR nlcd[[\"nlcd2011\"]]", 
"", "#table of classes", "classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.", 
"                      nlcdclass = c(\"Water\", \"Developed\", \"Barren\", \"Forest\", \"Shrubland\", \"Herbaceous\", \"Planted/Cultivated\", \"Wetlands\"), # Class Name.", 
"                      classcolor = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\", \"#D1D182\", \"#FBF65D\", \"#C8E6F8\") # # Hex codes of colours.", 
"                      )", "# Satellite images", "landsat5 <- stack(\"Data/centralvalley-2011LT5_Sml.tif\")", 
"names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')", 
"", "# Stratified sampling", "samp2011 <- sampleStratified(x = nlcd2011,size = 200,na.rm = TRUE, sp = TRUE)", 
"# data for modelling", "sampdata <- data.frame(classvalue = samp2011@data$nlcd2011,", 
"                       extract(x = landsat5,y = samp2011,df = TRUE)[-1])", 
"# CART model", "cartMod <- rpart(formula = as.factor(classvalue)~.,data = sampdata,method = 'class',cp = 0.01,minsplit = 5)", 
"# K-fold data ", "k.foldDta <- kfold(sampdata, k = 5, by = sampdata$classvalue)", 
"# Prediction", "CART.pr2011 <- predict(object = landsat5, model = cartMod, type = 'class')", 
"", "", "# Kfold Validation for the CART model", "CART.Kfold.List <- lapply(1:5, function(k){", 
"  train <- sampdata[k.foldDta!= k, ]", "  test <- sampdata[k.foldDta == k, ]", 
"  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~.,data = train, method = 'class', cp = 0.01, minsplit = 5)", 
"  pclass <- predict(object = cartMod.kfold.Mod, newdata = test, type = \"class\")", 
"  cbind(Observed = test$classvalue,", "        Predicted = as.numeric(as.vector(pclass)))", 
"  })", "CART.Kfold <- do.call(\"rbind\",CART.Kfold.List)", "CART.Kfold <- data.frame(CART.Kfold)", 
"colnames(CART.Kfold) <- c('observed', 'predicted')", "CART.conmat <- table(CART.Kfold)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "StratSmpl", code = "# Define  the training sites locations\n# Set the random number generator to make the results reproducible.\nset.seed(99)\n# Sampling\nsamp2011 <- sampleStratified(x = _____, # Raster to be \"sampled\"\n                             size = _____, # Number of samples per class\n                             na.rm = TRUE, # NA values are removed from random sample?\n                             sp = TRUE # Output as a SpatialPointsDataFrame?\n                             )\n\n# Explore the data in samp2011 using the head() function.\n_____(______)", 
        opts = list(label = "\"StratSmpl\"", exercise = "TRUE", 
            exercise.lines = "15"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "StratSmpl-check")), solution = structure(c("# Define  the training sites locations", 
    "# Set the random number generator to make the results reproducible.", 
    "set.seed(99)", "# Sampling", "samp2011 <- sampleStratified(x = nlcd2011, # Raster to be \"sampled\"", 
    "                             size = 200, # Number of samples per class", 
    "                             na.rm = TRUE, # NA values are removed from random sample?", 
    "                             sp = TRUE # Output as a SpatialPointsDataFrame?", 
    "                             )", "", "# Explore the data in samp2011 using the head() function.", 
    "head(samp2011)"), chunk_opts = list(label = "StratSmpl-solution", 
        exercise.reveal_solution = F)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_RegressionTrees_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_RegressionTrees_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "StratSmpl", exercise = TRUE, 
        exercise.lines = 15, code = c("# Define  the training sites locations", 
        "# Set the random number generator to make the results reproducible.", 
        "set.seed(99)", "# Sampling", "samp2011 <- sampleStratified(x = _____, # Raster to be \"sampled\"", 
        "                             size = _____, # Number of samples per class", 
        "                             na.rm = TRUE, # NA values are removed from random sample?", 
        "                             sp = TRUE # Output as a SpatialPointsDataFrame?", 
        "                             )", "", "# Explore the data in samp2011 using the head() function.", 
        "_____(______)"), out.width.px = 624, out.height.px = 384, 
        params.src = "StratSmpl, exercise=TRUE, exercise.lines=15", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-SmplTbl-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-SmplTbl-code-editor`)), session)
output$`tutorial-exercise-SmplTbl-output` <- renderUI({
  `tutorial-exercise-SmplTbl-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "SmplTbl", global_setup = structure(c("#Load packages", 
"library(raster)", "library(rpart)", "library(dismo)", "library(learnr)", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Load the data", 
"# Land Cover", "nlcd <- stack(\"Data/nlcd-L1_Sml.tif\")", "names(nlcd) <- c(\"nlcd2001\", \"nlcd2011\")", 
"# Only 2011 data", "nlcd2011 <- nlcd[[2]] # OR nlcd[[\"nlcd2011\"]]", 
"", "#table of classes", "classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.", 
"                      nlcdclass = c(\"Water\", \"Developed\", \"Barren\", \"Forest\", \"Shrubland\", \"Herbaceous\", \"Planted/Cultivated\", \"Wetlands\"), # Class Name.", 
"                      classcolor = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\", \"#D1D182\", \"#FBF65D\", \"#C8E6F8\") # # Hex codes of colours.", 
"                      )", "# Satellite images", "landsat5 <- stack(\"Data/centralvalley-2011LT5_Sml.tif\")", 
"names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')", 
"", "# Stratified sampling", "samp2011 <- sampleStratified(x = nlcd2011,size = 200,na.rm = TRUE, sp = TRUE)", 
"# data for modelling", "sampdata <- data.frame(classvalue = samp2011@data$nlcd2011,", 
"                       extract(x = landsat5,y = samp2011,df = TRUE)[-1])", 
"# CART model", "cartMod <- rpart(formula = as.factor(classvalue)~.,data = sampdata,method = 'class',cp = 0.01,minsplit = 5)", 
"# K-fold data ", "k.foldDta <- kfold(sampdata, k = 5, by = sampdata$classvalue)", 
"# Prediction", "CART.pr2011 <- predict(object = landsat5, model = cartMod, type = 'class')", 
"", "", "# Kfold Validation for the CART model", "CART.Kfold.List <- lapply(1:5, function(k){", 
"  train <- sampdata[k.foldDta!= k, ]", "  test <- sampdata[k.foldDta == k, ]", 
"  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~.,data = train, method = 'class', cp = 0.01, minsplit = 5)", 
"  pclass <- predict(object = cartMod.kfold.Mod, newdata = test, type = \"class\")", 
"  cbind(Observed = test$classvalue,", "        Predicted = as.numeric(as.vector(pclass)))", 
"  })", "CART.Kfold <- do.call(\"rbind\",CART.Kfold.List)", "CART.Kfold <- data.frame(CART.Kfold)", 
"colnames(CART.Kfold) <- c('observed', 'predicted')", "CART.conmat <- table(CART.Kfold)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "SmplTbl", code = "# Extract the land cover classes identities (class values) for each plot sampled in the stratified random sample SpatialPointsDataFrame.\nSampLCC <- __________$_______\n\n# Use the table() function to tabulate the number of land cover classes sampled by the `sampleStratified` function\n______(______)", 
        opts = list(label = "\"SmplTbl\"", exercise = "TRUE", 
            exercise.lines = "10"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "SmplTbl-check")), solution = structure(c("# Extract the land cover classes identities for each plot sampled in the stratified random sample.", 
    "SampLCC <- samp2011$nlcd2011", "", "# Use the table() function to tabulate the number of land cover classes sampled by the `sampleStratified` function", 
    "table(SampLCC)"), chunk_opts = list(label = "SmplTbl-solution", 
        exercise.reveal_solution = F)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_RegressionTrees_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_RegressionTrees_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "SmplTbl", exercise = TRUE, 
        exercise.lines = 10, code = c("# Extract the land cover classes identities (class values) for each plot sampled in the stratified random sample SpatialPointsDataFrame.", 
        "SampLCC <- __________$_______", "", "# Use the table() function to tabulate the number of land cover classes sampled by the `sampleStratified` function", 
        "______(______)"), out.width.px = 624, out.height.px = 384, 
        params.src = "SmplTbl, exercise=TRUE, exercise.lines=10", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-HiprSpcDta-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-HiprSpcDta-code-editor`)), session)
output$`tutorial-exercise-HiprSpcDta-output` <- renderUI({
  `tutorial-exercise-HiprSpcDta-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "HiprSpcDta", global_setup = structure(c("#Load packages", 
"library(raster)", "library(rpart)", "library(dismo)", "library(learnr)", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Load the data", 
"# Land Cover", "nlcd <- stack(\"Data/nlcd-L1_Sml.tif\")", "names(nlcd) <- c(\"nlcd2001\", \"nlcd2011\")", 
"# Only 2011 data", "nlcd2011 <- nlcd[[2]] # OR nlcd[[\"nlcd2011\"]]", 
"", "#table of classes", "classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.", 
"                      nlcdclass = c(\"Water\", \"Developed\", \"Barren\", \"Forest\", \"Shrubland\", \"Herbaceous\", \"Planted/Cultivated\", \"Wetlands\"), # Class Name.", 
"                      classcolor = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\", \"#D1D182\", \"#FBF65D\", \"#C8E6F8\") # # Hex codes of colours.", 
"                      )", "# Satellite images", "landsat5 <- stack(\"Data/centralvalley-2011LT5_Sml.tif\")", 
"names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')", 
"", "# Stratified sampling", "samp2011 <- sampleStratified(x = nlcd2011,size = 200,na.rm = TRUE, sp = TRUE)", 
"# data for modelling", "sampdata <- data.frame(classvalue = samp2011@data$nlcd2011,", 
"                       extract(x = landsat5,y = samp2011,df = TRUE)[-1])", 
"# CART model", "cartMod <- rpart(formula = as.factor(classvalue)~.,data = sampdata,method = 'class',cp = 0.01,minsplit = 5)", 
"# K-fold data ", "k.foldDta <- kfold(sampdata, k = 5, by = sampdata$classvalue)", 
"# Prediction", "CART.pr2011 <- predict(object = landsat5, model = cartMod, type = 'class')", 
"", "", "# Kfold Validation for the CART model", "CART.Kfold.List <- lapply(1:5, function(k){", 
"  train <- sampdata[k.foldDta!= k, ]", "  test <- sampdata[k.foldDta == k, ]", 
"  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~.,data = train, method = 'class', cp = 0.01, minsplit = 5)", 
"  pclass <- predict(object = cartMod.kfold.Mod, newdata = test, type = \"class\")", 
"  cbind(Observed = test$classvalue,", "        Predicted = as.numeric(as.vector(pclass)))", 
"  })", "CART.Kfold <- do.call(\"rbind\",CART.Kfold.List)", "CART.Kfold <- data.frame(CART.Kfold)", 
"colnames(CART.Kfold) <- c('observed', 'predicted')", "CART.conmat <- table(CART.Kfold)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "HiprSpcDta", code = "# Extract the values from `landsat5`\nsampvals <- extract(x = ________, # Define the raster to be sampled.\n                    y = ________, # Define the spatial vector data with the locations to sample.\n                    df = TRUE # Return the results as a data.frame\n                    )\n# Explore sampvals\nhead(sampvals)\n\n# combine the class information with extracted values\nsampdata <- data.frame(classvalue = samp2011@data$______, # Get the Landcover land cover classes identities from the samp2011 object.\n                       ________[, -1] # The extracted data.frame with the hyperspectral bands in `landsat5` minus the ID column\n                       )\n# Explore the resulting data.frame using the head() function.\n________(________)", 
        opts = list(label = "\"HiprSpcDta\"", exercise = "TRUE", 
            exercise.lines = "20"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "HiprSpcDta-check")), solution = structure(c("# Extract the values from `landsat5`", 
    "sampvals <- extract(x = landsat5, # Define the raster to be samples.", 
    "                    y = samp2011, # Define the spatial object data with the locations to sample.", 
    "                    df = TRUE # Return the results as a data.frame?", 
    "                    )", "", "# Explore sampvals", "head(sampvals)", 
    "", "# combine the class information with extracted values", 
    "sampdata <- data.frame(classvalue = samp2011@data$nlcd2011, # Get the Landcover land cover classes identities from the samp2011 object.", 
    "                       sampvals[, -1] # The extracted data.frame with the hyperspectral bands in `landsat5` minus the ID column", 
    "                       )", "# Explore the resulting data.frame using the head() function.", 
    "head(sampdata)"), chunk_opts = list(label = "HiprSpcDta-solution", 
        exercise.reveal_solution = F)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_RegressionTrees_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_RegressionTrees_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "HiprSpcDta", exercise = TRUE, 
        exercise.lines = 20, code = c("# Extract the values from `landsat5`", 
        "sampvals <- extract(x = ________, # Define the raster to be sampled.", 
        "                    y = ________, # Define the spatial vector data with the locations to sample.", 
        "                    df = TRUE # Return the results as a data.frame", 
        "                    )", "# Explore sampvals", "head(sampvals)", 
        "", "# combine the class information with extracted values", 
        "sampdata <- data.frame(classvalue = samp2011@data$______, # Get the Landcover land cover classes identities from the samp2011 object.", 
        "                       ________[, -1] # The extracted data.frame with the hyperspectral bands in `landsat5` minus the ID column", 
        "                       )", "# Explore the resulting data.frame using the head() function.", 
        "________(________)"), out.width.px = 624, out.height.px = 384, 
        params.src = "HiprSpcDta, exercise=TRUE, exercise.lines=20", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-CART1-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-CART1-code-editor`)), session)
output$`tutorial-exercise-CART1-output` <- renderUI({
  `tutorial-exercise-CART1-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "CART1", global_setup = structure(c("#Load packages", 
"library(raster)", "library(rpart)", "library(dismo)", "library(learnr)", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Load the data", 
"# Land Cover", "nlcd <- stack(\"Data/nlcd-L1_Sml.tif\")", "names(nlcd) <- c(\"nlcd2001\", \"nlcd2011\")", 
"# Only 2011 data", "nlcd2011 <- nlcd[[2]] # OR nlcd[[\"nlcd2011\"]]", 
"", "#table of classes", "classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.", 
"                      nlcdclass = c(\"Water\", \"Developed\", \"Barren\", \"Forest\", \"Shrubland\", \"Herbaceous\", \"Planted/Cultivated\", \"Wetlands\"), # Class Name.", 
"                      classcolor = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\", \"#D1D182\", \"#FBF65D\", \"#C8E6F8\") # # Hex codes of colours.", 
"                      )", "# Satellite images", "landsat5 <- stack(\"Data/centralvalley-2011LT5_Sml.tif\")", 
"names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')", 
"", "# Stratified sampling", "samp2011 <- sampleStratified(x = nlcd2011,size = 200,na.rm = TRUE, sp = TRUE)", 
"# data for modelling", "sampdata <- data.frame(classvalue = samp2011@data$nlcd2011,", 
"                       extract(x = landsat5,y = samp2011,df = TRUE)[-1])", 
"# CART model", "cartMod <- rpart(formula = as.factor(classvalue)~.,data = sampdata,method = 'class',cp = 0.01,minsplit = 5)", 
"# K-fold data ", "k.foldDta <- kfold(sampdata, k = 5, by = sampdata$classvalue)", 
"# Prediction", "CART.pr2011 <- predict(object = landsat5, model = cartMod, type = 'class')", 
"", "", "# Kfold Validation for the CART model", "CART.Kfold.List <- lapply(1:5, function(k){", 
"  train <- sampdata[k.foldDta!= k, ]", "  test <- sampdata[k.foldDta == k, ]", 
"  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~.,data = train, method = 'class', cp = 0.01, minsplit = 5)", 
"  pclass <- predict(object = cartMod.kfold.Mod, newdata = test, type = \"class\")", 
"  cbind(Observed = test$classvalue,", "        Predicted = as.numeric(as.vector(pclass)))", 
"  })", "CART.Kfold <- do.call(\"rbind\",CART.Kfold.List)", "CART.Kfold <- data.frame(CART.Kfold)", 
"colnames(CART.Kfold) <- c('observed', 'predicted')", "CART.conmat <- table(CART.Kfold)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "CART1", code = "# Train the model\ncartMod <- rpart(formula = as.factor(________)~., # Define a formula linking the response (land cover classes) to the predictors (bands in Landsat5) - remember to Define the Land cover class as a factor\n              data = ________, # Define the object with the response/predictors data!\n              method = '________', # Define the Type of model you are building.\n              cp = 0.01, # Define the minimum level of increase in the complexity parameter\n              minsplit = 5 #Define the minimum number of observations that must exist in a node in order for a split to be attempted\n              )\n\n# Show the contents of the classification model you just built using the\ncartMod", 
        opts = list(label = "\"CART1\"", exercise = "TRUE", exercise.lines = "20"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = structure("grade_code()", chunk_opts = list(label = "CART1-check")), 
    solution = structure(c("# Train the model", "cartMod <- rpart(formula = as.factor(classvalue)~., # Define a formula linking the response (land cover classes) to the predictors (bands in Landsat5) - remember to Define the Land cover class as a factor", 
    "              data = sampdata, # Define the object with the response/predictors data!", 
    "              method = 'class', # Define the Type of model you are building.", 
    "              cp = 0.01, # Define the minimum level of increase in the complexity parameter", 
    "              minsplit = 5 #Define the minimum number of observations that must exist in a node in order for a split to be attempted", 
    "              )", "", "# Show the contents of the classification model you just built using the", 
    "cartMod"), chunk_opts = list(label = "CART1-solution", exercise.reveal_solution = F)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_RegressionTrees_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_RegressionTrees_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "CART1", exercise = TRUE, 
        exercise.lines = 20, code = c("# Train the model", "cartMod <- rpart(formula = as.factor(________)~., # Define a formula linking the response (land cover classes) to the predictors (bands in Landsat5) - remember to Define the Land cover class as a factor", 
        "              data = ________, # Define the object with the response/predictors data!", 
        "              method = '________', # Define the Type of model you are building.", 
        "              cp = 0.01, # Define the minimum level of increase in the complexity parameter", 
        "              minsplit = 5 #Define the minimum number of observations that must exist in a node in order for a split to be attempted", 
        "              )", "", "# Show the contents of the classification model you just built using the", 
        "cartMod"), out.width.px = 624, out.height.px = 384, 
        params.src = "CART1, exercise=TRUE, exercise.lines=20", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-CARTplt-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-CARTplt-code-editor`)), session)
output$`tutorial-exercise-CARTplt-output` <- renderUI({
  `tutorial-exercise-CARTplt-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "CARTplt", global_setup = structure(c("#Load packages", 
"library(raster)", "library(rpart)", "library(dismo)", "library(learnr)", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Load the data", 
"# Land Cover", "nlcd <- stack(\"Data/nlcd-L1_Sml.tif\")", "names(nlcd) <- c(\"nlcd2001\", \"nlcd2011\")", 
"# Only 2011 data", "nlcd2011 <- nlcd[[2]] # OR nlcd[[\"nlcd2011\"]]", 
"", "#table of classes", "classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.", 
"                      nlcdclass = c(\"Water\", \"Developed\", \"Barren\", \"Forest\", \"Shrubland\", \"Herbaceous\", \"Planted/Cultivated\", \"Wetlands\"), # Class Name.", 
"                      classcolor = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\", \"#D1D182\", \"#FBF65D\", \"#C8E6F8\") # # Hex codes of colours.", 
"                      )", "# Satellite images", "landsat5 <- stack(\"Data/centralvalley-2011LT5_Sml.tif\")", 
"names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')", 
"", "# Stratified sampling", "samp2011 <- sampleStratified(x = nlcd2011,size = 200,na.rm = TRUE, sp = TRUE)", 
"# data for modelling", "sampdata <- data.frame(classvalue = samp2011@data$nlcd2011,", 
"                       extract(x = landsat5,y = samp2011,df = TRUE)[-1])", 
"# CART model", "cartMod <- rpart(formula = as.factor(classvalue)~.,data = sampdata,method = 'class',cp = 0.01,minsplit = 5)", 
"# K-fold data ", "k.foldDta <- kfold(sampdata, k = 5, by = sampdata$classvalue)", 
"# Prediction", "CART.pr2011 <- predict(object = landsat5, model = cartMod, type = 'class')", 
"", "", "# Kfold Validation for the CART model", "CART.Kfold.List <- lapply(1:5, function(k){", 
"  train <- sampdata[k.foldDta!= k, ]", "  test <- sampdata[k.foldDta == k, ]", 
"  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~.,data = train, method = 'class', cp = 0.01, minsplit = 5)", 
"  pclass <- predict(object = cartMod.kfold.Mod, newdata = test, type = \"class\")", 
"  cbind(Observed = test$classvalue,", "        Predicted = as.numeric(as.vector(pclass)))", 
"  })", "CART.Kfold <- do.call(\"rbind\",CART.Kfold.List)", "CART.Kfold <- data.frame(CART.Kfold)", 
"colnames(CART.Kfold) <- c('observed', 'predicted')", "CART.conmat <- table(CART.Kfold)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "CARTplt", code = "# Plot the trained classification tree\nplot(x = _______, # Define the classification/regression tree to plot.\n     uniform = TRUE, # Use a uniform vertical spacing of the nodes?\n     main = \"Classification Tree\" # Figure main title\n     )\n\n# Place the leaves Names on the dendrogram Plot\ntext(x = _______, # Define the classification/regression tree to plot,\n     cex = 0.8 # Size of the text\n     )", 
        opts = list(label = "\"CARTplt\"", exercise = "TRUE", 
            exercise.lines = "15"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "CARTplt-check")), solution = structure(c("# Plot the trained classification tree", 
    "plot(x = cartMod, # Define the classification/regression tree to plot.", 
    "     uniform = TRUE, # Use a uniform vertical spacing of the nodes?", 
    "     main = \"Classification Tree\" # Figure main title", 
    "     )", "", "# Place the leaf’s Names on the dendrogram Plot", 
    "text(x = cartMod, # Define the classification/regression tree to plot,", 
    "     cex = 0.8 # Size of the text", "     )"), chunk_opts = list(
        label = "CARTplt-solution", exercise.reveal_solution = F)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_RegressionTrees_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_RegressionTrees_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "CARTplt", exercise = TRUE, 
        exercise.lines = 15, code = c("# Plot the trained classification tree", 
        "plot(x = _______, # Define the classification/regression tree to plot.", 
        "     uniform = TRUE, # Use a uniform vertical spacing of the nodes?", 
        "     main = \"Classification Tree\" # Figure main title", 
        "     )", "", "# Place the leaves Names on the dendrogram Plot", 
        "text(x = _______, # Define the classification/regression tree to plot,", 
        "     cex = 0.8 # Size of the text", "     )"), out.width.px = 624, 
        out.height.px = 384, params.src = "CARTplt, exercise=TRUE, exercise.lines=15", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-CompParPrint-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-CompParPrint-code-editor`)), session)
output$`tutorial-exercise-CompParPrint-output` <- renderUI({
  `tutorial-exercise-CompParPrint-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "CompParPrint", global_setup = structure(c("#Load packages", 
"library(raster)", "library(rpart)", "library(dismo)", "library(learnr)", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Load the data", 
"# Land Cover", "nlcd <- stack(\"Data/nlcd-L1_Sml.tif\")", "names(nlcd) <- c(\"nlcd2001\", \"nlcd2011\")", 
"# Only 2011 data", "nlcd2011 <- nlcd[[2]] # OR nlcd[[\"nlcd2011\"]]", 
"", "#table of classes", "classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.", 
"                      nlcdclass = c(\"Water\", \"Developed\", \"Barren\", \"Forest\", \"Shrubland\", \"Herbaceous\", \"Planted/Cultivated\", \"Wetlands\"), # Class Name.", 
"                      classcolor = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\", \"#D1D182\", \"#FBF65D\", \"#C8E6F8\") # # Hex codes of colours.", 
"                      )", "# Satellite images", "landsat5 <- stack(\"Data/centralvalley-2011LT5_Sml.tif\")", 
"names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')", 
"", "# Stratified sampling", "samp2011 <- sampleStratified(x = nlcd2011,size = 200,na.rm = TRUE, sp = TRUE)", 
"# data for modelling", "sampdata <- data.frame(classvalue = samp2011@data$nlcd2011,", 
"                       extract(x = landsat5,y = samp2011,df = TRUE)[-1])", 
"# CART model", "cartMod <- rpart(formula = as.factor(classvalue)~.,data = sampdata,method = 'class',cp = 0.01,minsplit = 5)", 
"# K-fold data ", "k.foldDta <- kfold(sampdata, k = 5, by = sampdata$classvalue)", 
"# Prediction", "CART.pr2011 <- predict(object = landsat5, model = cartMod, type = 'class')", 
"", "", "# Kfold Validation for the CART model", "CART.Kfold.List <- lapply(1:5, function(k){", 
"  train <- sampdata[k.foldDta!= k, ]", "  test <- sampdata[k.foldDta == k, ]", 
"  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~.,data = train, method = 'class', cp = 0.01, minsplit = 5)", 
"  pclass <- predict(object = cartMod.kfold.Mod, newdata = test, type = \"class\")", 
"  cbind(Observed = test$classvalue,", "        Predicted = as.numeric(as.vector(pclass)))", 
"  })", "CART.Kfold <- do.call(\"rbind\",CART.Kfold.List)", "CART.Kfold <- data.frame(CART.Kfold)", 
"colnames(CART.Kfold) <- c('observed', 'predicted')", "CART.conmat <- table(CART.Kfold)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "CompParPrint", code = "# Print the Complexity Parameter Table for a rpart Fit\n_______(_______)\n\n# Plot a Complexity Parameter Table for a rpart Fit. Here, note the dashed line, which shows the 1-SE of the minimum cp.\n_______(_______)", 
        opts = list(label = "\"CompParPrint\"", exercise = "TRUE"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = structure("grade_code()", chunk_opts = list(label = "CompParPrint-check")), 
    solution = structure(c("# print the Complexity Parameter Table for a rpart Fit", 
    "printcp(cartMod)", "", "# Plot a Complexity Parameter Table for a rpart Fit. Here note the dashed line, which shows the 1-SE of the minimum cp.", 
    "plotcp(cartMod)"), chunk_opts = list(label = "CompParPrint-solution", 
        exercise.reveal_solution = F)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_RegressionTrees_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_RegressionTrees_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "CompParPrint", exercise = TRUE, 
        code = c("# Print the Complexity Parameter Table for a rpart Fit", 
        "_______(_______)", "", "# Plot a Complexity Parameter Table for a rpart Fit. Here, note the dashed line, which shows the 1-SE of the minimum cp.", 
        "_______(_______)"), out.width.px = 624, out.height.px = 384, 
        params.src = "CompParPrint, exercise=TRUE", fig.num = 0, 
        exercise.df_print = "paged"), engine = "r", version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-CARTprune1-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-CARTprune1-code-editor`)), session)
output$`tutorial-exercise-CARTprune1-output` <- renderUI({
  `tutorial-exercise-CARTprune1-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "CARTprune1", global_setup = structure(c("#Load packages", 
"library(raster)", "library(rpart)", "library(dismo)", "library(learnr)", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Load the data", 
"# Land Cover", "nlcd <- stack(\"Data/nlcd-L1_Sml.tif\")", "names(nlcd) <- c(\"nlcd2001\", \"nlcd2011\")", 
"# Only 2011 data", "nlcd2011 <- nlcd[[2]] # OR nlcd[[\"nlcd2011\"]]", 
"", "#table of classes", "classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.", 
"                      nlcdclass = c(\"Water\", \"Developed\", \"Barren\", \"Forest\", \"Shrubland\", \"Herbaceous\", \"Planted/Cultivated\", \"Wetlands\"), # Class Name.", 
"                      classcolor = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\", \"#D1D182\", \"#FBF65D\", \"#C8E6F8\") # # Hex codes of colours.", 
"                      )", "# Satellite images", "landsat5 <- stack(\"Data/centralvalley-2011LT5_Sml.tif\")", 
"names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')", 
"", "# Stratified sampling", "samp2011 <- sampleStratified(x = nlcd2011,size = 200,na.rm = TRUE, sp = TRUE)", 
"# data for modelling", "sampdata <- data.frame(classvalue = samp2011@data$nlcd2011,", 
"                       extract(x = landsat5,y = samp2011,df = TRUE)[-1])", 
"# CART model", "cartMod <- rpart(formula = as.factor(classvalue)~.,data = sampdata,method = 'class',cp = 0.01,minsplit = 5)", 
"# K-fold data ", "k.foldDta <- kfold(sampdata, k = 5, by = sampdata$classvalue)", 
"# Prediction", "CART.pr2011 <- predict(object = landsat5, model = cartMod, type = 'class')", 
"", "", "# Kfold Validation for the CART model", "CART.Kfold.List <- lapply(1:5, function(k){", 
"  train <- sampdata[k.foldDta!= k, ]", "  test <- sampdata[k.foldDta == k, ]", 
"  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~.,data = train, method = 'class', cp = 0.01, minsplit = 5)", 
"  pclass <- predict(object = cartMod.kfold.Mod, newdata = test, type = \"class\")", 
"  cbind(Observed = test$classvalue,", "        Predicted = as.numeric(as.vector(pclass)))", 
"  })", "CART.Kfold <- do.call(\"rbind\",CART.Kfold.List)", "CART.Kfold <- data.frame(CART.Kfold)", 
"colnames(CART.Kfold) <- c('observed', 'predicted')", "CART.conmat <- table(CART.Kfold)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "CARTprune1", code = "# Save the Complexity Parameter Table for Fitted rpart Object\nprintcpSumm <- as.data.frame(printcp(_______))\n\n# Pruning based on the minimum criteria\n# Extract the complexity parameter where xerror is the lowest\nCPVal.Min <- printcpSumm[which.min(printcpSumm$_______), \"CP\"]\n\n# Pruning based on the minimum criteria  \ncartMod.pruned.1 <- prune(_______, # Define the CART model to prune.\n                       cp = _______ # Define the CP value at which the CART model will be pruned\n                       )\n\n# Plot the Pruned tree\nplot(x = _______, # Define the classification/regression tree to plot.\n     uniform = TRUE, # Use a uniform vertical spacing of the nodes?\n     main = \"Classification Tree - min criteria\" # Figure main title\n     )\n# Place the leaf’s Names on the dendrogram Plot\ntext(x = _______, # Define the classification/regression tree to plot,\n     cex = 0.8, # Size of the text\n     xpd = NA)", 
        opts = list(label = "\"CARTprune1\"", exercise = "TRUE", 
            exercise.lines = "25"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "CARTprune1-check")), solution = structure(c("# Save the Complexity Parameter Table for Fitted rpart Object", 
    "printcpSumm <- as.data.frame(printcp(cartMod))", "", "# Pruning based on the minimum criteria", 
    "# Extract the complexity parameter where xerror is the lowest", 
    "CPVal.Min <- printcpSumm[which.min(printcpSumm$xerror), \"CP\"]", 
    "", "# Pruning based on the minimum criteria  ", "cartMod.pruned.1 <- prune(cartMod, # Define the CART model to prune.", 
    "                       cp = CPVal.Min # Define the CP value at which the CART model will be pruned", 
    "                       )", "", "# Plot the Pruned tree", 
    "plot(x = cartMod.pruned.1, # Define the classification/regression tree to plot.", 
    "     uniform = TRUE, # Use a uniform vertical spacing of the nodes?", 
    "     main = \"Classification Tree - min criteria\" # Figure main title", 
    "     )", "# Place the leaf’s Names on the dendrogram Plot", 
    "text(x = cartMod.pruned.1, # Define the classification/regression tree to plot,", 
    "     cex = 0.8, # Size of the text", "     xpd = NA)"), chunk_opts = list(
        label = "CARTprune1-solution", exercise.reveal_solution = F)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_RegressionTrees_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_RegressionTrees_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "CARTprune1", exercise = TRUE, 
        exercise.lines = 25, code = c("# Save the Complexity Parameter Table for Fitted rpart Object", 
        "printcpSumm <- as.data.frame(printcp(_______))", "", 
        "# Pruning based on the minimum criteria", "# Extract the complexity parameter where xerror is the lowest", 
        "CPVal.Min <- printcpSumm[which.min(printcpSumm$_______), \"CP\"]", 
        "", "# Pruning based on the minimum criteria  ", "cartMod.pruned.1 <- prune(_______, # Define the CART model to prune.", 
        "                       cp = _______ # Define the CP value at which the CART model will be pruned", 
        "                       )", "", "# Plot the Pruned tree", 
        "plot(x = _______, # Define the classification/regression tree to plot.", 
        "     uniform = TRUE, # Use a uniform vertical spacing of the nodes?", 
        "     main = \"Classification Tree - min criteria\" # Figure main title", 
        "     )", "# Place the leaf’s Names on the dendrogram Plot", 
        "text(x = _______, # Define the classification/regression tree to plot,", 
        "     cex = 0.8, # Size of the text", "     xpd = NA)"
        ), out.width.px = 624, out.height.px = 384, params.src = "CARTprune1, exercise=TRUE, exercise.lines=25", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-CARTprune2-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-CARTprune2-code-editor`)), session)
output$`tutorial-exercise-CARTprune2-output` <- renderUI({
  `tutorial-exercise-CARTprune2-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "CARTprune2", global_setup = structure(c("#Load packages", 
"library(raster)", "library(rpart)", "library(dismo)", "library(learnr)", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Load the data", 
"# Land Cover", "nlcd <- stack(\"Data/nlcd-L1_Sml.tif\")", "names(nlcd) <- c(\"nlcd2001\", \"nlcd2011\")", 
"# Only 2011 data", "nlcd2011 <- nlcd[[2]] # OR nlcd[[\"nlcd2011\"]]", 
"", "#table of classes", "classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.", 
"                      nlcdclass = c(\"Water\", \"Developed\", \"Barren\", \"Forest\", \"Shrubland\", \"Herbaceous\", \"Planted/Cultivated\", \"Wetlands\"), # Class Name.", 
"                      classcolor = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\", \"#D1D182\", \"#FBF65D\", \"#C8E6F8\") # # Hex codes of colours.", 
"                      )", "# Satellite images", "landsat5 <- stack(\"Data/centralvalley-2011LT5_Sml.tif\")", 
"names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')", 
"", "# Stratified sampling", "samp2011 <- sampleStratified(x = nlcd2011,size = 200,na.rm = TRUE, sp = TRUE)", 
"# data for modelling", "sampdata <- data.frame(classvalue = samp2011@data$nlcd2011,", 
"                       extract(x = landsat5,y = samp2011,df = TRUE)[-1])", 
"# CART model", "cartMod <- rpart(formula = as.factor(classvalue)~.,data = sampdata,method = 'class',cp = 0.01,minsplit = 5)", 
"# K-fold data ", "k.foldDta <- kfold(sampdata, k = 5, by = sampdata$classvalue)", 
"# Prediction", "CART.pr2011 <- predict(object = landsat5, model = cartMod, type = 'class')", 
"", "", "# Kfold Validation for the CART model", "CART.Kfold.List <- lapply(1:5, function(k){", 
"  train <- sampdata[k.foldDta!= k, ]", "  test <- sampdata[k.foldDta == k, ]", 
"  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~.,data = train, method = 'class', cp = 0.01, minsplit = 5)", 
"  pclass <- predict(object = cartMod.kfold.Mod, newdata = test, type = \"class\")", 
"  cbind(Observed = test$classvalue,", "        Predicted = as.numeric(as.vector(pclass)))", 
"  })", "CART.Kfold <- do.call(\"rbind\",CART.Kfold.List)", "CART.Kfold <- data.frame(CART.Kfold)", 
"colnames(CART.Kfold) <- c('observed', 'predicted')", "CART.conmat <- table(CART.Kfold)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "CARTprune2", code = "# Pruning based on the ±1 xstd criteria\n# Save the Complexity Parameter Table for Fitted rpart Object\nprintcpSumm <- as.data.frame(_______(_______))\n\n# What is the upper boundary of the min-xerror\nMinxerrorUp <- sum(printcpSumm[which.min(printcpSumm$_______),c(\"xerror\",\"xstd\")])\n\n# What is the lower boundary of each xerror\nLowxerror <- _______$xerror - _______$xstd\n\n# Which number of splits is the first were Lowxerror <= MinxerrorUp\nCrit.Split <-  min(which(_______ <= _______))\n  \n# Extract the complexity parameter using the ±1 xstd range of min(error) criteria\nCPVal.xstd <- printcpSumm$_______[_______]\n\n# Pruning based on the ±1 xstd criteria\ncartMod.pruned.2 <- prune(_______, # Define the CART model to prune.\n                          cp = _______ # Define the CP value at which the CART model will be pruned\n                       )\n# Plot the Pruned tree\nplot(x = _______, # Define the classification/regression tree to plot.\n     uniform = TRUE, # Use a uniform vertical spacing of the nodes?\n     main = \"Classification Tree - ±1 xstd criteria\" # Figure main title\n     )\n# Place the leaf’s Names on the dendrogram Plot\ntext(x = _______, # Define the classification/regression tree to plot,\n     cex = 0.8, # Size of the text\n     xpd = NA)", 
        opts = list(label = "\"CARTprune2\"", exercise = "TRUE", 
            exercise.lines = "30"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "CARTprune2-check")), solution = structure(c("# Pruning based on the ±1 xstd criteria", 
    "# Save the Complexity Parameter Table for Fitted rpart Object", 
    "printcpSumm <- as.data.frame(printcp(cartMod))", "", "# What is the upper boundary of the min-xerror", 
    "MinxerrorUp <- sum(printcpSumm[which.min(printcpSumm$xerror),c(\"xerror\",\"xstd\")])", 
    "", "# What is the lower boundary of each xerror", "Lowxerror <- printcpSumm$xerror-printcpSumm$xstd", 
    "", "# Which number of splits is the first were Lowxerror <= MinxerrorUp", 
    "Crit.Split <-  min(which(Lowxerror <= MinxerrorUp))", "  ", 
    "# Extract the complexity parameter using the ±1 xstd range of min(error) criteria", 
    "CPVal.xstd <- printcpSumm$CP[Crit.Split]", "", "# Pruning based on the ±1 xstd criteria", 
    "cartMod.pruned.2 <- prune(cartMod, # Define the CART model to prune.", 
    "                       cp = CPVal.xstd # Define the CP value at which the CART model will be pruned", 
    "                       )", "# Plot the Pruned tree", "plot(x = cartMod.pruned.2, # Define the classification/regression tree to plot.", 
    "     uniform = TRUE, # Use a uniform vertical spacing of the nodes?", 
    "     main = \"Classification Tree - ±1 xstd criteria\" # Figure main title", 
    "     )", "# Place the leaf’s Names on the dendrogram Plot", 
    "text(x = cartMod.pruned.2, # Define the classification/regression tree to plot,", 
    "     cex = 0.8, # Size of the text", "     xpd = NA)"), chunk_opts = list(
        label = "CARTprune2-solution", exercise.reveal_solution = F)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_RegressionTrees_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_RegressionTrees_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "CARTprune2", exercise = TRUE, 
        exercise.lines = 30, code = c("# Pruning based on the ±1 xstd criteria", 
        "# Save the Complexity Parameter Table for Fitted rpart Object", 
        "printcpSumm <- as.data.frame(_______(_______))", "", 
        "# What is the upper boundary of the min-xerror", "MinxerrorUp <- sum(printcpSumm[which.min(printcpSumm$_______),c(\"xerror\",\"xstd\")])", 
        "", "# What is the lower boundary of each xerror", "Lowxerror <- _______$xerror - _______$xstd", 
        "", "# Which number of splits is the first were Lowxerror <= MinxerrorUp", 
        "Crit.Split <-  min(which(_______ <= _______))", "  ", 
        "# Extract the complexity parameter using the ±1 xstd range of min(error) criteria", 
        "CPVal.xstd <- printcpSumm$_______[_______]", "", "# Pruning based on the ±1 xstd criteria", 
        "cartMod.pruned.2 <- prune(_______, # Define the CART model to prune.", 
        "                          cp = _______ # Define the CP value at which the CART model will be pruned", 
        "                       )", "# Plot the Pruned tree", 
        "plot(x = _______, # Define the classification/regression tree to plot.", 
        "     uniform = TRUE, # Use a uniform vertical spacing of the nodes?", 
        "     main = \"Classification Tree - ±1 xstd criteria\" # Figure main title", 
        "     )", "# Place the leaf’s Names on the dendrogram Plot", 
        "text(x = _______, # Define the classification/regression tree to plot,", 
        "     cex = 0.8, # Size of the text", "     xpd = NA)"
        ), out.width.px = 624, out.height.px = 384, params.src = "CARTprune2, exercise=TRUE, exercise.lines=30", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-KFold-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-KFold-code-editor`)), session)
output$`tutorial-exercise-KFold-output` <- renderUI({
  `tutorial-exercise-KFold-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "KFold", global_setup = structure(c("#Load packages", 
"library(raster)", "library(rpart)", "library(dismo)", "library(learnr)", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Load the data", 
"# Land Cover", "nlcd <- stack(\"Data/nlcd-L1_Sml.tif\")", "names(nlcd) <- c(\"nlcd2001\", \"nlcd2011\")", 
"# Only 2011 data", "nlcd2011 <- nlcd[[2]] # OR nlcd[[\"nlcd2011\"]]", 
"", "#table of classes", "classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.", 
"                      nlcdclass = c(\"Water\", \"Developed\", \"Barren\", \"Forest\", \"Shrubland\", \"Herbaceous\", \"Planted/Cultivated\", \"Wetlands\"), # Class Name.", 
"                      classcolor = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\", \"#D1D182\", \"#FBF65D\", \"#C8E6F8\") # # Hex codes of colours.", 
"                      )", "# Satellite images", "landsat5 <- stack(\"Data/centralvalley-2011LT5_Sml.tif\")", 
"names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')", 
"", "# Stratified sampling", "samp2011 <- sampleStratified(x = nlcd2011,size = 200,na.rm = TRUE, sp = TRUE)", 
"# data for modelling", "sampdata <- data.frame(classvalue = samp2011@data$nlcd2011,", 
"                       extract(x = landsat5,y = samp2011,df = TRUE)[-1])", 
"# CART model", "cartMod <- rpart(formula = as.factor(classvalue)~.,data = sampdata,method = 'class',cp = 0.01,minsplit = 5)", 
"# K-fold data ", "k.foldDta <- kfold(sampdata, k = 5, by = sampdata$classvalue)", 
"# Prediction", "CART.pr2011 <- predict(object = landsat5, model = cartMod, type = 'class')", 
"", "", "# Kfold Validation for the CART model", "CART.Kfold.List <- lapply(1:5, function(k){", 
"  train <- sampdata[k.foldDta!= k, ]", "  test <- sampdata[k.foldDta == k, ]", 
"  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~.,data = train, method = 'class', cp = 0.01, minsplit = 5)", 
"  pclass <- predict(object = cartMod.kfold.Mod, newdata = test, type = \"class\")", 
"  cbind(Observed = test$classvalue,", "        Predicted = as.numeric(as.vector(pclass)))", 
"  })", "CART.Kfold <- do.call(\"rbind\",CART.Kfold.List)", "CART.Kfold <- data.frame(CART.Kfold)", 
"colnames(CART.Kfold) <- c('observed', 'predicted')", "CART.conmat <- table(CART.Kfold)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "KFold", code = "# set the random seed for reproducibility\nset.seed(99)\n\n# Do a k-fold partitioning of the training dataset\nk.foldDta <- kfold(_______, # the source data to use\n                   k = _______, # number of Folds (here you use 5)\n                   by = sampdata$_______) # define how to stratify the folds\n\n# Tabulate the k-fold partitioning dataset by the Land Cover Class to see the number of samples per land cover class to be used in each fold.\ntable(_______,\n      sampdata$_______)", 
        opts = list(label = "\"KFold\"", exercise = "TRUE", exercise.lines = "15"), 
        engine = "r")), code_check = NULL, error_check = NULL, 
    check = structure("grade_code()", chunk_opts = list(label = "KFold-check")), 
    solution = structure(c("# set the random seed for reproducibility", 
    "set.seed(99)", "", "# Do a k-fold partitioning of the training dataset", 
    "k.foldDta <- kfold(sampdata, # the source data to use", 
    "                   k = 5, # number of Folds (here you use 5)", 
    "                   by = sampdata$classvalue) # define how to stratify the folds", 
    "", "# Tabulate the k-fold partitioning dataset by the Land Cover Class to see the number of samples per land cover class to be used in each fold.", 
    "table(k.foldDta,", "      sampdata$classvalue)"), chunk_opts = list(
        label = "KFold-solution", exercise.reveal_solution = F)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_RegressionTrees_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_RegressionTrees_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "KFold", exercise = TRUE, 
        exercise.lines = 15, code = c("# set the random seed for reproducibility", 
        "set.seed(99)", "", "# Do a k-fold partitioning of the training dataset", 
        "k.foldDta <- kfold(_______, # the source data to use", 
        "                   k = _______, # number of Folds (here you use 5)", 
        "                   by = sampdata$_______) # define how to stratify the folds", 
        "", "# Tabulate the k-fold partitioning dataset by the Land Cover Class to see the number of samples per land cover class to be used in each fold.", 
        "table(_______,", "      sampdata$_______)"), out.width.px = 624, 
        out.height.px = 384, params.src = "KFold, exercise=TRUE, exercise.lines=15", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-CARTKfold-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-CARTKfold-code-editor`)), session)
output$`tutorial-exercise-CARTKfold-output` <- renderUI({
  `tutorial-exercise-CARTKfold-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "CARTKfold", global_setup = structure(c("#Load packages", 
"library(raster)", "library(rpart)", "library(dismo)", "library(learnr)", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Load the data", 
"# Land Cover", "nlcd <- stack(\"Data/nlcd-L1_Sml.tif\")", "names(nlcd) <- c(\"nlcd2001\", \"nlcd2011\")", 
"# Only 2011 data", "nlcd2011 <- nlcd[[2]] # OR nlcd[[\"nlcd2011\"]]", 
"", "#table of classes", "classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.", 
"                      nlcdclass = c(\"Water\", \"Developed\", \"Barren\", \"Forest\", \"Shrubland\", \"Herbaceous\", \"Planted/Cultivated\", \"Wetlands\"), # Class Name.", 
"                      classcolor = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\", \"#D1D182\", \"#FBF65D\", \"#C8E6F8\") # # Hex codes of colours.", 
"                      )", "# Satellite images", "landsat5 <- stack(\"Data/centralvalley-2011LT5_Sml.tif\")", 
"names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')", 
"", "# Stratified sampling", "samp2011 <- sampleStratified(x = nlcd2011,size = 200,na.rm = TRUE, sp = TRUE)", 
"# data for modelling", "sampdata <- data.frame(classvalue = samp2011@data$nlcd2011,", 
"                       extract(x = landsat5,y = samp2011,df = TRUE)[-1])", 
"# CART model", "cartMod <- rpart(formula = as.factor(classvalue)~.,data = sampdata,method = 'class',cp = 0.01,minsplit = 5)", 
"# K-fold data ", "k.foldDta <- kfold(sampdata, k = 5, by = sampdata$classvalue)", 
"# Prediction", "CART.pr2011 <- predict(object = landsat5, model = cartMod, type = 'class')", 
"", "", "# Kfold Validation for the CART model", "CART.Kfold.List <- lapply(1:5, function(k){", 
"  train <- sampdata[k.foldDta!= k, ]", "  test <- sampdata[k.foldDta == k, ]", 
"  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~.,data = train, method = 'class', cp = 0.01, minsplit = 5)", 
"  pclass <- predict(object = cartMod.kfold.Mod, newdata = test, type = \"class\")", 
"  cbind(Observed = test$classvalue,", "        Predicted = as.numeric(as.vector(pclass)))", 
"  })", "CART.Kfold <- do.call(\"rbind\",CART.Kfold.List)", "CART.Kfold <- data.frame(CART.Kfold)", 
"colnames(CART.Kfold) <- c('observed', 'predicted')", "CART.conmat <- table(CART.Kfold)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "CARTKfold", code = "# Kfold Validation for the CART model\nCART.Kfold.List <- lapply(1:5, function(k){\n# Define the Training data.frame - Observations NOT selected in the k-fold.\n  train <- sampdata[_________!= k, ]\n# Define the test data.frame - Observations selected in the k-fold.\n  test <- _________[k.foldDta == k, ]\n\n# Build a new CART model using the Train dataset\n  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~., # Define a formula linking the response (land cover classes) to the predictors (bands in Landsat5) - remember to Define the Land cover class as a factor\n                             data = _________, # Define the object with the response/predictors data -  here is the training data.\n                             method = 'class', # Define the Type of model you are building.\n                             cp = 0.01, # Define the minimum level of increase in the complexity parameter\n                             minsplit = 5 #Define the minimum number of observations that must exist in a node for a split to be attempted\n                             )\n\n# Predict the k-fold model on the test data.frame\n  pclass <- predict(object = _________, # Define the randomForest with the model.\n                    newdata = _________, # Define data.frame used to make the prediction - here is the test data.\n                    type = \"class\" # indicating the type of output\n                    )\n# create a table to compare the test-data and the prediction\n  cbind(Observed = _________$classvalue,\n        Predicted = as.numeric(as.vector(pclass)))\n  })\n\n# Confusion matrix for CART model the kfold validation\n# Merge the tables in the list row-wise\nCART.Kfold <- do.call(\"rbind\",\n                      CART.Kfold.List)\n# Make the matrix a data.frame\nCART.Kfold <- data.frame(CART.Kfold)\n\n# Set the column names for the data.frame.\ncolnames(CART.Kfold) <- c('observed', 'predicted')\n\n# Tabulate the (miss)matches between the observed  and predicted test datasets\nCART.conmat <- table(_________)\n\n# Change the name of the classes in the tabulation.\ncolnames(CART.conmat) <- classdf[match(colnames(CART.conmat),classdf$classvalue1),\"nlcdclass\"]\nrownames(CART.conmat) <- classdf[match(rownames(CART.conmat),classdf$classvalue1),\"nlcdclass\"]\n\n# Print the confusion matrix\nCART.conmat/200", 
        opts = list(label = "\"CARTKfold\"", exercise = "TRUE", 
            exercise.lines = "30"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "CARTKfold-check")), solution = structure(c("# Kfold Validation for the CART model", 
    "CART.Kfold.List <- lapply(1:5, function(k){", "# Define the Training data.frame - Observations NOT selected in the k-fold.", 
    "  train <- sampdata[k.foldDta!= k, ]", "# Define the test data.frame - Observations selected in the k-fold.", 
    "  test <- sampdata[k.foldDta == k, ]", "", "# Build a new CART model using the Train dataset", 
    "  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~., # Define a formula linking the response (land cover classes) to the predictors (bands in Landsat5) - remember to Define the Land cover class as a factor", 
    "                             data = train, , # Define the object with the response/predictors data -  here is the training data.", 
    "                             method = 'class', # Define the Type of model you are building.", 
    "                             cp = 0.01, # Define the minimum level of increase in the complexity parameter", 
    "                             minsplit = 5 #Define the minimum number of observations that must exist in a node for a split to be attempted", 
    "                             )", "", "# Predict the k-fold model on the test data.frame", 
    "  pclass <- predict(object = cartMod.kfold.Mod, # Define the randomForest with the model.", 
    "                    newdata = test, # Define data.frame used to make the prediction - here is the test data.", 
    "                    type = \"class\" # indicating the type of output", 
    "                    )", "# create a table to compare the test-data and the prediction", 
    "  cbind(Observed = test$classvalue,", "        Predicted = as.numeric(as.vector(pclass)))", 
    "  })", "", "# Confusion matrix for CART model the kfold validation", 
    "# Merge the tables in the list row-wise", "CART.Kfold <- do.call(\"rbind\",", 
    "                      CART.Kfold.List)", "# Make the matrix a data.frame", 
    "CART.Kfold <- data.frame(CART.Kfold)", "", "# Set the column names for the data.frame.", 
    "colnames(CART.Kfold) <- c('observed', 'predicted')", "", 
    "# Tabulate the (miss)matches between the observed  and predicted test datasets", 
    "CART.conmat <- table(CART.Kfold)", "", "# Change the name of the classes in the tabulation.", 
    "colnames(CART.conmat) <- classdf[match(colnames(CART.conmat),classdf$classvalue1),\"nlcdclass\"]", 
    "rownames(CART.conmat) <- classdf[match(rownames(CART.conmat),classdf$classvalue1),\"nlcdclass\"]", 
    "# Print the confusion matrix", "CART.conmat/200"), chunk_opts = list(
        label = "CARTKfold-solution", exercise.reveal_solution = F)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_RegressionTrees_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_RegressionTrees_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "CARTKfold", exercise = TRUE, 
        exercise.lines = 30, code = c("# Kfold Validation for the CART model", 
        "CART.Kfold.List <- lapply(1:5, function(k){", "# Define the Training data.frame - Observations NOT selected in the k-fold.", 
        "  train <- sampdata[_________!= k, ]", "# Define the test data.frame - Observations selected in the k-fold.", 
        "  test <- _________[k.foldDta == k, ]", "", "# Build a new CART model using the Train dataset", 
        "  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~., # Define a formula linking the response (land cover classes) to the predictors (bands in Landsat5) - remember to Define the Land cover class as a factor", 
        "                             data = _________, # Define the object with the response/predictors data -  here is the training data.", 
        "                             method = 'class', # Define the Type of model you are building.", 
        "                             cp = 0.01, # Define the minimum level of increase in the complexity parameter", 
        "                             minsplit = 5 #Define the minimum number of observations that must exist in a node for a split to be attempted", 
        "                             )", "", "# Predict the k-fold model on the test data.frame", 
        "  pclass <- predict(object = _________, # Define the randomForest with the model.", 
        "                    newdata = _________, # Define data.frame used to make the prediction - here is the test data.", 
        "                    type = \"class\" # indicating the type of output", 
        "                    )", "# create a table to compare the test-data and the prediction", 
        "  cbind(Observed = _________$classvalue,", "        Predicted = as.numeric(as.vector(pclass)))", 
        "  })", "", "# Confusion matrix for CART model the kfold validation", 
        "# Merge the tables in the list row-wise", "CART.Kfold <- do.call(\"rbind\",", 
        "                      CART.Kfold.List)", "# Make the matrix a data.frame", 
        "CART.Kfold <- data.frame(CART.Kfold)", "", "# Set the column names for the data.frame.", 
        "colnames(CART.Kfold) <- c('observed', 'predicted')", 
        "", "# Tabulate the (miss)matches between the observed  and predicted test datasets", 
        "CART.conmat <- table(_________)", "", "# Change the name of the classes in the tabulation.", 
        "colnames(CART.conmat) <- classdf[match(colnames(CART.conmat),classdf$classvalue1),\"nlcdclass\"]", 
        "rownames(CART.conmat) <- classdf[match(rownames(CART.conmat),classdf$classvalue1),\"nlcdclass\"]", 
        "", "# Print the confusion matrix", "CART.conmat/200"
        ), out.width.px = 624, out.height.px = 384, params.src = "CARTKfold, exercise=TRUE, exercise.lines=30", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-MissClasRte-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-MissClasRte-code-editor`)), session)
output$`tutorial-exercise-MissClasRte-output` <- renderUI({
  `tutorial-exercise-MissClasRte-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "MissClasRte", global_setup = structure(c("#Load packages", 
"library(raster)", "library(rpart)", "library(dismo)", "library(learnr)", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Load the data", 
"# Land Cover", "nlcd <- stack(\"Data/nlcd-L1_Sml.tif\")", "names(nlcd) <- c(\"nlcd2001\", \"nlcd2011\")", 
"# Only 2011 data", "nlcd2011 <- nlcd[[2]] # OR nlcd[[\"nlcd2011\"]]", 
"", "#table of classes", "classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.", 
"                      nlcdclass = c(\"Water\", \"Developed\", \"Barren\", \"Forest\", \"Shrubland\", \"Herbaceous\", \"Planted/Cultivated\", \"Wetlands\"), # Class Name.", 
"                      classcolor = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\", \"#D1D182\", \"#FBF65D\", \"#C8E6F8\") # # Hex codes of colours.", 
"                      )", "# Satellite images", "landsat5 <- stack(\"Data/centralvalley-2011LT5_Sml.tif\")", 
"names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')", 
"", "# Stratified sampling", "samp2011 <- sampleStratified(x = nlcd2011,size = 200,na.rm = TRUE, sp = TRUE)", 
"# data for modelling", "sampdata <- data.frame(classvalue = samp2011@data$nlcd2011,", 
"                       extract(x = landsat5,y = samp2011,df = TRUE)[-1])", 
"# CART model", "cartMod <- rpart(formula = as.factor(classvalue)~.,data = sampdata,method = 'class',cp = 0.01,minsplit = 5)", 
"# K-fold data ", "k.foldDta <- kfold(sampdata, k = 5, by = sampdata$classvalue)", 
"# Prediction", "CART.pr2011 <- predict(object = landsat5, model = cartMod, type = 'class')", 
"", "", "# Kfold Validation for the CART model", "CART.Kfold.List <- lapply(1:5, function(k){", 
"  train <- sampdata[k.foldDta!= k, ]", "  test <- sampdata[k.foldDta == k, ]", 
"  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~.,data = train, method = 'class', cp = 0.01, minsplit = 5)", 
"  pclass <- predict(object = cartMod.kfold.Mod, newdata = test, type = \"class\")", 
"  cbind(Observed = test$classvalue,", "        Predicted = as.numeric(as.vector(pclass)))", 
"  })", "CART.Kfold <- do.call(\"rbind\",CART.Kfold.List)", "CART.Kfold <- data.frame(CART.Kfold)", 
"colnames(CART.Kfold) <- c('observed', 'predicted')", "CART.conmat <- table(CART.Kfold)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "MissClasRte", code = "### Miss classification of the CART model\nCART.class.error <- sapply(colnames(_______), # The cross-validation confusion matrix \n                           function(i){\n                             sum(_______[i, !colnames(_______)%in%i])\n                             })/apply(_______, 1, sum)\n\n# Print the miss-classification of the RF model\nCART.class.error\n\n# Make a barplot of the miss-classification of the RF model\nbarplot(_______,\n        main = \" CART model k-fold miss-classification rate\",\n        ylim =c(0,1))\n", 
        opts = list(label = "\"MissClasRte\"", exercise = "TRUE", 
            exercise.lines = "15"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "MissClasRte-check")), solution = structure(c("### Miss classification of the CART model", 
    "CART.class.error <- sapply(colnames(CART.conmat),", "                           function(i){", 
    "                             sum(CART.conmat[i, !colnames(CART.conmat)%in%i])", 
    "                             })/apply(CART.conmat, 1, sum)", 
    "", "# Print the miss-classification of the RF model", "CART.class.error", 
    "", "# Make a barplot of the miss-classification of the RF model", 
    "barplot(CART.class.error,", "        main = \" CART model k-fold miss-classification rate\",", 
    "        ylim =c(0,1))", ""), chunk_opts = list(label = "MissClasRte-solution", 
        exercise.reveal_solution = F)), tests = NULL, options = list(
        eval = FALSE, echo = TRUE, results = "markup", tidy = FALSE, 
        tidy.opts = NULL, collapse = FALSE, prompt = FALSE, comment = NA, 
        highlight = FALSE, size = "normalsize", background = "#F7F7F7", 
        strip.white = TRUE, cache = 0, cache.path = "StatGeoMod_RegressionTrees_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_RegressionTrees_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "MissClasRte", exercise = TRUE, 
        exercise.lines = 15, code = c("### Miss classification of the CART model", 
        "CART.class.error <- sapply(colnames(_______), # The cross-validation confusion matrix ", 
        "                           function(i){", "                             sum(_______[i, !colnames(_______)%in%i])", 
        "                             })/apply(_______, 1, sum)", 
        "", "# Print the miss-classification of the RF model", 
        "CART.class.error", "", "# Make a barplot of the miss-classification of the RF model", 
        "barplot(_______,", "        main = \" CART model k-fold miss-classification rate\",", 
        "        ylim =c(0,1))", ""), out.width.px = 624, out.height.px = 384, 
        params.src = "MissClasRte, exercise=TRUE, exercise.lines=15", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-GlobMod-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-GlobMod-code-editor`)), session)
output$`tutorial-exercise-GlobMod-output` <- renderUI({
  `tutorial-exercise-GlobMod-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "GlobMod", global_setup = structure(c("#Load packages", 
"library(raster)", "library(rpart)", "library(dismo)", "library(learnr)", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Load the data", 
"# Land Cover", "nlcd <- stack(\"Data/nlcd-L1_Sml.tif\")", "names(nlcd) <- c(\"nlcd2001\", \"nlcd2011\")", 
"# Only 2011 data", "nlcd2011 <- nlcd[[2]] # OR nlcd[[\"nlcd2011\"]]", 
"", "#table of classes", "classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.", 
"                      nlcdclass = c(\"Water\", \"Developed\", \"Barren\", \"Forest\", \"Shrubland\", \"Herbaceous\", \"Planted/Cultivated\", \"Wetlands\"), # Class Name.", 
"                      classcolor = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\", \"#D1D182\", \"#FBF65D\", \"#C8E6F8\") # # Hex codes of colours.", 
"                      )", "# Satellite images", "landsat5 <- stack(\"Data/centralvalley-2011LT5_Sml.tif\")", 
"names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')", 
"", "# Stratified sampling", "samp2011 <- sampleStratified(x = nlcd2011,size = 200,na.rm = TRUE, sp = TRUE)", 
"# data for modelling", "sampdata <- data.frame(classvalue = samp2011@data$nlcd2011,", 
"                       extract(x = landsat5,y = samp2011,df = TRUE)[-1])", 
"# CART model", "cartMod <- rpart(formula = as.factor(classvalue)~.,data = sampdata,method = 'class',cp = 0.01,minsplit = 5)", 
"# K-fold data ", "k.foldDta <- kfold(sampdata, k = 5, by = sampdata$classvalue)", 
"# Prediction", "CART.pr2011 <- predict(object = landsat5, model = cartMod, type = 'class')", 
"", "", "# Kfold Validation for the CART model", "CART.Kfold.List <- lapply(1:5, function(k){", 
"  train <- sampdata[k.foldDta!= k, ]", "  test <- sampdata[k.foldDta == k, ]", 
"  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~.,data = train, method = 'class', cp = 0.01, minsplit = 5)", 
"  pclass <- predict(object = cartMod.kfold.Mod, newdata = test, type = \"class\")", 
"  cbind(Observed = test$classvalue,", "        Predicted = as.numeric(as.vector(pclass)))", 
"  })", "CART.Kfold <- do.call(\"rbind\",CART.Kfold.List)", "CART.Kfold <- data.frame(CART.Kfold)", 
"colnames(CART.Kfold) <- c('observed', 'predicted')", "CART.conmat <- table(CART.Kfold)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "GlobMod", code = "# Use the predict function (as implemented for raster objects and the CART model to generate predictors of land Cover classes for 2011.\nCART.pr2011 <- predict(object = _______, # Define the raster used to make the predictions.\n                       model = _______, # Define the model used to make the predictions..\n                       type = 'class' # Define the type of predicted value returned  \n                       )\n\n# Plot the CART model PREDICTED map using the image() function and the HEX colours in classdf - remember that there is no class 6 in classdf, and so it does not have a colour.\nimage(_______,\n     main = \"CART Predicted Land cover classification 2011\", # Give the Name\n     col = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\",NA, \"#D1D182\", \"#FBF65D\", \"#C8E6F8\"))\n\n# Add a legend linking land cover class names to the colours.\nlegend(\"topright\", # Define the position the legend.\n       inset = c(-0.24,0), # Define inset distance(s) from the margins.\n       fill = classdf$_______, # Define the colours of each land cover class.\n       legend  = classdf$_______, # Define each land cover class name.\n       cex = 0.7, # Define the text size\n       xpd=NA) # Plot outside the Figure region\n", 
        opts = list(label = "\"GlobMod\"", exercise = "TRUE", 
            exercise.lines = "20"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "GlobMod-check")), solution = structure(c("# Use the predict function (as implemented for raster objects and the CART model to generate predictors of land cover classes for 2011.", 
    "CART.pr2011 <- predict(object = landsat5, # Define the raster used to make the predictions.", 
    "                       model = cartMod, # Define the model used to make the predictions..", 
    "                       type = 'class' # Define the type of predicted value returned  ", 
    "                       )", "", "# Plot the CART model PREDICTED map using the image() function and the HEX colours in classdf - remember that there is no class 6 in classdf, and so it does not have a colour.", 
    "image(CART.pr2011,", "     main = \"CART Predicted Land cover classification 2011\", # Give the Name", 
    "     col = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\",NA, \"#D1D182\", \"#FBF65D\", \"#C8E6F8\"))", 
    "", "# Add a legend linking land cover class names to the colours.", 
    "legend(\"topright\", # Define the position the legend.", 
    "       inset = c(-0.24,0), # Define inset distance(s) from the margins.", 
    "       fill = classdf$classcolor, # Define the colours of each land cover class.", 
    "       legend  = classdf$nlcdclass, # Define each land cover class name.", 
    "       cex = 0.7, # Define the text size", "       xpd=NA) # Plot outside the Figure region", 
    ""), chunk_opts = list(label = "GlobMod-solution", exercise.reveal_solution = F)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_RegressionTrees_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_RegressionTrees_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "GlobMod", exercise = TRUE, 
        exercise.lines = 20, code = c("# Use the predict function (as implemented for raster objects and the CART model to generate predictors of land Cover classes for 2011.", 
        "CART.pr2011 <- predict(object = _______, # Define the raster used to make the predictions.", 
        "                       model = _______, # Define the model used to make the predictions..", 
        "                       type = 'class' # Define the type of predicted value returned  ", 
        "                       )", "", "# Plot the CART model PREDICTED map using the image() function and the HEX colours in classdf - remember that there is no class 6 in classdf, and so it does not have a colour.", 
        "image(_______,", "     main = \"CART Predicted Land cover classification 2011\", # Give the Name", 
        "     col = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\",NA, \"#D1D182\", \"#FBF65D\", \"#C8E6F8\"))", 
        "", "# Add a legend linking land cover class names to the colours.", 
        "legend(\"topright\", # Define the position the legend.", 
        "       inset = c(-0.24,0), # Define inset distance(s) from the margins.", 
        "       fill = classdf$_______, # Define the colours of each land cover class.", 
        "       legend  = classdf$_______, # Define each land cover class name.", 
        "       cex = 0.7, # Define the text size", "       xpd=NA) # Plot outside the Figure region", 
        ""), out.width.px = 624, out.height.px = 384, params.src = "GlobMod, exercise=TRUE, exercise.lines=20", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-ClasErr-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-ClasErr-code-editor`)), session)
output$`tutorial-exercise-ClasErr-output` <- renderUI({
  `tutorial-exercise-ClasErr-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "ClasErr", global_setup = structure(c("#Load packages", 
"library(raster)", "library(rpart)", "library(dismo)", "library(learnr)", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Load the data", 
"# Land Cover", "nlcd <- stack(\"Data/nlcd-L1_Sml.tif\")", "names(nlcd) <- c(\"nlcd2001\", \"nlcd2011\")", 
"# Only 2011 data", "nlcd2011 <- nlcd[[2]] # OR nlcd[[\"nlcd2011\"]]", 
"", "#table of classes", "classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.", 
"                      nlcdclass = c(\"Water\", \"Developed\", \"Barren\", \"Forest\", \"Shrubland\", \"Herbaceous\", \"Planted/Cultivated\", \"Wetlands\"), # Class Name.", 
"                      classcolor = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\", \"#D1D182\", \"#FBF65D\", \"#C8E6F8\") # # Hex codes of colours.", 
"                      )", "# Satellite images", "landsat5 <- stack(\"Data/centralvalley-2011LT5_Sml.tif\")", 
"names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')", 
"", "# Stratified sampling", "samp2011 <- sampleStratified(x = nlcd2011,size = 200,na.rm = TRUE, sp = TRUE)", 
"# data for modelling", "sampdata <- data.frame(classvalue = samp2011@data$nlcd2011,", 
"                       extract(x = landsat5,y = samp2011,df = TRUE)[-1])", 
"# CART model", "cartMod <- rpart(formula = as.factor(classvalue)~.,data = sampdata,method = 'class',cp = 0.01,minsplit = 5)", 
"# K-fold data ", "k.foldDta <- kfold(sampdata, k = 5, by = sampdata$classvalue)", 
"# Prediction", "CART.pr2011 <- predict(object = landsat5, model = cartMod, type = 'class')", 
"", "", "# Kfold Validation for the CART model", "CART.Kfold.List <- lapply(1:5, function(k){", 
"  train <- sampdata[k.foldDta!= k, ]", "  test <- sampdata[k.foldDta == k, ]", 
"  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~.,data = train, method = 'class', cp = 0.01, minsplit = 5)", 
"  pclass <- predict(object = cartMod.kfold.Mod, newdata = test, type = \"class\")", 
"  cbind(Observed = test$classvalue,", "        Predicted = as.numeric(as.vector(pclass)))", 
"  })", "CART.Kfold <- do.call(\"rbind\",CART.Kfold.List)", "CART.Kfold <- data.frame(CART.Kfold)", 
"colnames(CART.Kfold) <- c('observed', 'predicted')", "CART.conmat <- table(CART.Kfold)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "ClasErr", code = "# Use the image function to show the cells that are misclassified (Predicted != Observed) and classified correctly (Predicted == Observed) based on the CART model\nimage(_______ == _______, # Which cells are correctly classified (Predicted == Observed)\n      main = \"CART misclassified cells\",\n      col = c(\"red\", \"blue\")) ## red is for areas misclassified\n\n# Estimate the proportion of misclassified cells (Predicted != Observed)/Ncells for the CART model.\nsum((_______!= _______)[])/ncell(nlcd2011) # sum of miss-classified cells (Predicted != Observed)\n", 
        opts = list(label = "\"ClasErr\"", exercise = "TRUE", 
            exercise.lines = "10"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "ClasErr-check")), solution = structure(c("# Use the image function to show the cells that are misclassified (Predicted != Observed) and classified correctly (Predicted == Observed) based on the CART model", 
    "image(CART.pr2011 == nlcd2011, # Which cells are correctly classified (Predicted == Observed)", 
    "      main = \"CART misclassified cells\",", "      col = c(\"red\", \"blue\")) ## red is for areas misclassified", 
    "", "# Estimate the proportion of misclassified cells (Predicted != Observed)/Ncells for the CART model.", 
    "sum((CART.pr2011!= nlcd2011)[])/ncell(nlcd2011) # sum of miss-classified cells (Predicted != Observed)", 
    ""), chunk_opts = list(label = "ClasErr-solution", exercise.reveal_solution = F)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_RegressionTrees_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_RegressionTrees_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "ClasErr", exercise = TRUE, 
        exercise.lines = 10, code = c("# Use the image function to show the cells that are misclassified (Predicted != Observed) and classified correctly (Predicted == Observed) based on the CART model", 
        "image(_______ == _______, # Which cells are correctly classified (Predicted == Observed)", 
        "      main = \"CART misclassified cells\",", "      col = c(\"red\", \"blue\")) ## red is for areas misclassified", 
        "", "# Estimate the proportion of misclassified cells (Predicted != Observed)/Ncells for the CART model.", 
        "sum((_______!= _______)[])/ncell(nlcd2011) # sum of miss-classified cells (Predicted != Observed)", 
        ""), out.width.px = 624, out.height.px = 384, params.src = "ClasErr, exercise=TRUE, exercise.lines=10", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
 
<script type="application/shiny-prerendered" data-context="server">
`tutorial-exercise-FullRAstAcc-result` <- learnr:::setup_exercise_handler(reactive(req(input$`tutorial-exercise-FullRAstAcc-code-editor`)), session)
output$`tutorial-exercise-FullRAstAcc-output` <- renderUI({
  `tutorial-exercise-FullRAstAcc-result`()
})
</script>


<script type="application/shiny-prerendered" data-context="server">
learnr:::store_exercise_cache(structure(list(label = "FullRAstAcc", global_setup = structure(c("#Load packages", 
"library(raster)", "library(rpart)", "library(dismo)", "library(learnr)", 
"# Setup", "knitr::opts_chunk$set(echo = FALSE,", "                      message = FALSE,", 
"                      warning = FALSE)", "gradethis::gradethis_setup()", 
"tutorial_options(exercise.blanks = TRUE)", "", "# Load the data", 
"# Land Cover", "nlcd <- stack(\"Data/nlcd-L1_Sml.tif\")", "names(nlcd) <- c(\"nlcd2001\", \"nlcd2011\")", 
"# Only 2011 data", "nlcd2011 <- nlcd[[2]] # OR nlcd[[\"nlcd2011\"]]", 
"", "#table of classes", "classdf <- data.frame(classvalue1 = c(1, 2, 3, 4, 5, 7, 8, 9), # Class Number.", 
"                      nlcdclass = c(\"Water\", \"Developed\", \"Barren\", \"Forest\", \"Shrubland\", \"Herbaceous\", \"Planted/Cultivated\", \"Wetlands\"), # Class Name.", 
"                      classcolor = c(\"#5475A8\", \"#B50000\", \"#D2CDC0\", \"#38814E\", \"#AF963C\", \"#D1D182\", \"#FBF65D\", \"#C8E6F8\") # # Hex codes of colours.", 
"                      )", "# Satellite images", "landsat5 <- stack(\"Data/centralvalley-2011LT5_Sml.tif\")", 
"names(landsat5) <- c('blue', 'green', 'red', 'NIR', 'SWIR1', 'SWIR2')", 
"", "# Stratified sampling", "samp2011 <- sampleStratified(x = nlcd2011,size = 200,na.rm = TRUE, sp = TRUE)", 
"# data for modelling", "sampdata <- data.frame(classvalue = samp2011@data$nlcd2011,", 
"                       extract(x = landsat5,y = samp2011,df = TRUE)[-1])", 
"# CART model", "cartMod <- rpart(formula = as.factor(classvalue)~.,data = sampdata,method = 'class',cp = 0.01,minsplit = 5)", 
"# K-fold data ", "k.foldDta <- kfold(sampdata, k = 5, by = sampdata$classvalue)", 
"# Prediction", "CART.pr2011 <- predict(object = landsat5, model = cartMod, type = 'class')", 
"", "", "# Kfold Validation for the CART model", "CART.Kfold.List <- lapply(1:5, function(k){", 
"  train <- sampdata[k.foldDta!= k, ]", "  test <- sampdata[k.foldDta == k, ]", 
"  cartMod.kfold.Mod <- rpart(formula = as.factor(classvalue)~.,data = train, method = 'class', cp = 0.01, minsplit = 5)", 
"  pclass <- predict(object = cartMod.kfold.Mod, newdata = test, type = \"class\")", 
"  cbind(Observed = test$classvalue,", "        Predicted = as.numeric(as.vector(pclass)))", 
"  })", "CART.Kfold <- do.call(\"rbind\",CART.Kfold.List)", "CART.Kfold <- data.frame(CART.Kfold)", 
"colnames(CART.Kfold) <- c('observed', 'predicted')", "CART.conmat <- table(CART.Kfold)"
), chunk_opts = list(label = "setup", include = FALSE)), setup = NULL, 
    chunks = list(list(label = "FullRAstAcc", code = "# Use the table() function to estimate the confusion matrix for the CART model\n# The table is based on names and not numeric codes\nCART.ConfMtx <- table(classdf$nlcdclass[match(_________[], classdf$classvalue1)], # Names for each cell in the Observed raster\n                      classdf$nlcdclass[match(_________[], classdf$classvalue1)] # Names for each cell in the Predicted raster\n                      )\n\n# Define the per-class error rate [proportion of the cells for a given land cover class correctly classified]\nCARTclass.error <- sapply(colnames(_________), # Do this by column manes in `CART.ConfMtx`\n                          function(i){\n                            sum(_________[i, !colnames(_________)%in%i]) # total of correctly classified per class\n                            }) \n\nCARTclass.error/apply(_________, 1, sum) #Proportion of all observation in a class correctly classified", 
        opts = list(label = "\"FullRAstAcc\"", exercise = "TRUE", 
            exercise.lines = "15"), engine = "r")), code_check = NULL, 
    error_check = NULL, check = structure("grade_code()", chunk_opts = list(
        label = "FullRAstAcc-check")), solution = structure(c("# Use the table() function to estimate the confusion matrix for the CART model", 
    "# The table is based on names and not numeric codes", "CART.ConfMtx <- table(classdf$nlcdclass[match(nlcd2011[], classdf$classvalue1)], # Names for each cell in the Observed raster", 
    "                      classdf$nlcdclass[match(CART.pr2011[], classdf$classvalue1)] # Names for each cell in the Predicted raster", 
    "                      )", "", "# Define the per-class error rate [proportion of the cells for a given land cover class correctly classified]", 
    "CARTclass.error <- sapply(colnames(CART.ConfMtx), # Do this by column manes in `CART.ConfMtx`", 
    "                          function(i){", "                            sum(CART.ConfMtx[i, !colnames(CART.ConfMtx)%in%i]) # total of correctly classified per class", 
    "                            }) ", "", "CARTclass.error/apply(CART.ConfMtx, 1, sum) #Proportion of all observation in a class correctly classified"
    ), chunk_opts = list(label = "FullRAstAcc-solution", exercise.reveal_solution = F)), 
    tests = NULL, options = list(eval = FALSE, echo = TRUE, results = "markup", 
        tidy = FALSE, tidy.opts = NULL, collapse = FALSE, prompt = FALSE, 
        comment = NA, highlight = FALSE, size = "normalsize", 
        background = "#F7F7F7", strip.white = TRUE, cache = 0, 
        cache.path = "StatGeoMod_RegressionTrees_cache/html/", 
        cache.vars = NULL, cache.lazy = TRUE, dependson = NULL, 
        autodep = FALSE, cache.rebuild = FALSE, fig.keep = "high", 
        fig.show = "asis", fig.align = "default", fig.path = "StatGeoMod_RegressionTrees_files/figure-html/", 
        dev = "png", dev.args = NULL, dpi = 192, fig.ext = "png", 
        fig.width = 6.5, fig.height = 4, fig.env = "figure", 
        fig.cap = NULL, fig.scap = NULL, fig.lp = "fig:", fig.subcap = NULL, 
        fig.pos = "", out.width = 624, out.height = NULL, out.extra = NULL, 
        fig.retina = 2, external = TRUE, sanitize = FALSE, interval = 1, 
        aniopts = "controls,loop", warning = FALSE, error = FALSE, 
        message = FALSE, render = NULL, ref.label = NULL, child = NULL, 
        engine = "r", split = FALSE, include = TRUE, purl = TRUE, 
        max.print = 1000, exercise.timelimit = 60, exercise.checker = "function (label = NULL, solution_code = NULL, user_code = NULL, \n    check_code = NULL, envir_result = NULL, evaluate_result = NULL, \n    envir_prep = NULL, last_value = NULL, stage = NULL, ...) \n{\n    (utils::getFromNamespace(\"check_exercise\", \"gradethis\"))(label = label, \n        solution_code = solution_code, user_code = user_code, \n        check_code = check_code, envir_result = envir_result, \n        evaluate_result = evaluate_result, envir_prep = envir_prep, \n        last_value = last_value, stage = stage, ...)\n}", 
        exercise.error.check.code = "gradethis_error_checker()", 
        exercise.blanks = TRUE, label = "FullRAstAcc", exercise = TRUE, 
        exercise.lines = 15, code = c("# Use the table() function to estimate the confusion matrix for the CART model", 
        "# The table is based on names and not numeric codes", 
        "CART.ConfMtx <- table(classdf$nlcdclass[match(_________[], classdf$classvalue1)], # Names for each cell in the Observed raster", 
        "                      classdf$nlcdclass[match(_________[], classdf$classvalue1)] # Names for each cell in the Predicted raster", 
        "                      )", "", "# Define the per-class error rate [proportion of the cells for a given land cover class correctly classified]", 
        "CARTclass.error <- sapply(colnames(_________), # Do this by column manes in `CART.ConfMtx`", 
        "                          function(i){", "                            sum(_________[i, !colnames(_________)%in%i]) # total of correctly classified per class", 
        "                            }) ", "", "CARTclass.error/apply(_________, 1, sum) #Proportion of all observation in a class correctly classified"
        ), out.width.px = 624, out.height.px = 384, params.src = "FullRAstAcc, exercise=TRUE, exercise.lines=15", 
        fig.num = 0, exercise.df_print = "paged"), engine = "r", 
    version = "3"), class = "tutorial_exercise"))
</script>
</p>
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="dependencies">
{"type":"list","attributes":{},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["header-attrs"]},{"type":"character","attributes":{},"value":["2.17"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pandoc"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["header-attrs.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.17"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootstrap"]},{"type":"character","attributes":{},"value":["3.3.5"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/bootstrap"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["viewport"]}},"value":[{"type":"character","attributes":{},"value":["width=device-width, initial-scale=1"]}]},{"type":"character","attributes":{},"value":["js/bootstrap.min.js","shim/html5shiv.min.js","shim/respond.min.js"]},{"type":"character","attributes":{},"value":["css/cerulean.min.css"]},{"type":"character","attributes":{},"value":["<style>h1 {font-size: 34px;}\n       h1.title {font-size: 38px;}\n       h2 {font-size: 30px;}\n       h3 {font-size: 24px;}\n       h4 {font-size: 18px;}\n       h5 {font-size: 16px;}\n       h6 {font-size: 12px;}\n       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}\n       pre:not([class]) { background-color: white }<\/style>"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.17"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["pagedtable"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/pagedtable-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["js/pagedtable.js"]},{"type":"character","attributes":{},"value":["css/pagedtable.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.17"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["textmate.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.17"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.10.5.9000"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["i18n"]},{"type":"character","attributes":{},"value":["21.6.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/i18n"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["i18next.min.js","tutorial-i18n-init.js"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["<script id=\"i18n-cstm-trns\" type=\"application/json\">{\"language\":\"en\",\"resources\":{\"en\":{\"translation\":{\"button\":{\"runcode\":\"Run Code\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Hint\",\"hint_plural\":\"Hints\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Next Hint\",\"hintprev\":\"Previous Hint\",\"solution\":\"Solution\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copy to Clipboard\",\"startover\":\"Start Over\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continue\",\"submitanswer\":\"Submit Answer\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Previous Topic\",\"nexttopic\":\"Next Topic\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Try Again\"},\"text\":{\"startover\":\"Start Over\",\"areyousure\":\"Are you sure you want to start over? (all exercise progress will be reset)\",\"youmustcomplete\":\"You must complete the\",\"exercise\":\"exercise\",\"exercise_plural\":\"exercises\",\"inthissection\":\"in this section before continuing.\",\"code\":\"Code\",\"enginecap\":\"{{engine}} $t(text.code)\",\"quiz\":\"Quiz\",\"blank\":\"blank\",\"blank_plural\":\"blanks\",\"exercisecontainsblank\":\"This exercise contains {{count}} $t(text.blank).\",\"pleasereplaceblank\":\"Please replace {{blank}} with valid code.\",\"unparsable\":\"It looks like this might not be valid R code. R cannot determine how to turn your text into a complete command. You may have forgotten to fill in a blank, to remove an underscore, to include a comma between arguments, or to close an opening <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> or <code>{<\\/code> with a matching <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code> or <code>}<\\/code>.\\n\",\"unparsablequotes\":\"<p>It looks like your R code contains specially formatted quotation marks or &quot;curly&quot; quotes (<code>{{character}}<\\/code>) around character strings, making your code invalid. R requires character values to be contained in straight quotation marks (<code>&quot;<\\/code> or <code>'<\\/code>).<\\/p> {{code}} <p>Don't worry, this is a common source of errors when you copy code from another app that applies its own formatting to text. You can try replacing the code on that line with the following. There may be other places that need to be fixed, too.<\\/p> {{suggestion}}\\n\",\"unparsableunicode\":\"<p>It looks like your R code contains an unexpected special character (<code>{{character}}<\\/code>) that makes your code invalid.<\\/p> {{code}} <p>Sometimes your code may contain a special character that looks like a regular character, especially if you copy and paste the code from another app. Try deleting the special character from your code and retyping it manually.<\\/p>\\n\",\"unparsableunicodesuggestion\":\"<p>It looks like your R code contains an unexpected special character (<code>{{character}}<\\/code>) that makes your code invalid.<\\/p> {{code}} <p>Sometimes your code may contain a special character that looks like a regular character, especially if you copy and paste the code from another app. You can try replacing the code on that line with the following. There may be other places that need to be fixed, too.<\\/p> {{suggestion}}\\n\",\"and\":\"and\",\"or\":\"or\",\"listcomma\":\", \",\"oxfordcomma\":\",\"}}},\"fr\":{\"translation\":{\"button\":{\"runcode\":\"Lancer le Code\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Indication\",\"hint_plural\":\"Indications\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Indication Suivante\",\"hintprev\":\"Indication Précédente\",\"solution\":\"Solution\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copier dans le Presse-papier\",\"startover\":\"Recommencer\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuer\",\"submitanswer\":\"Soumettre\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Chapitre Précédent\",\"nexttopic\":\"Chapitre Suivant\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Réessayer\"},\"text\":{\"startover\":\"Recommencer\",\"areyousure\":\"Êtes-vous certains de vouloir recommencer? (La progression sera remise à zéro)\",\"youmustcomplete\":\"Vous devez d'abord compléter\",\"exercise\":\"l'exercice\",\"exercise_plural\":\"des exercices\",\"inthissection\":\"de cette section avec de continuer.\",\"code\":\"Code\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"and\":\"et\",\"or\":\"ou\",\"oxfordcomma\":\"\"}}},\"es\":{\"translation\":{\"button\":{\"runcode\":\"Ejecutar código\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Pista\",\"hint_plural\":\"Pistas\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Siguiente pista\",\"hintprev\":\"Pista anterior\",\"solution\":\"Solución\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copiar al portapapeles\",\"startover\":\"Reiniciar\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuar\",\"submitanswer\":\"Enviar respuesta\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Tema anterior\",\"nexttopic\":\"Tema siguiente\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Volver a intentar\"},\"text\":{\"startover\":\"Reiniciar\",\"areyousure\":\"¿De verdad quieres empezar de nuevo? (todo el progreso del ejercicio se perderá)\",\"youmustcomplete\":\"Debes completar\",\"exercise\":\"el ejercicio\",\"exercise_plural\":\"los ejercicios\",\"inthissection\":\"en esta sección antes de continuar.\",\"code\":\"Código\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Cuestionario\",\"and\":\"y\",\"or\":\"o\",\"oxfordcomma\":\"\"}}},\"pt\":{\"translation\":{\"button\":{\"runcode\":\"Executar código\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Dica\",\"hint_plural\":\"Dicas\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Próxima dica\",\"hintprev\":\"Dica anterior\",\"solution\":\"Solução\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Copiar para a área de transferência\",\"startover\":\"Reiniciar\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Continuar\",\"submitanswer\":\"Enviar resposta\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Tópico anterior\",\"nexttopic\":\"Próximo tópico\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Tentar novamente\"},\"text\":{\"startover\":\"Reiniciar\",\"areyousure\":\"Tem certeza que deseja começar novamente? (todo o progresso feito será perdido)\",\"youmustcomplete\":\"Você deve completar\",\"exercise\":\"o exercício\",\"exercise_plural\":\"os exercícios\",\"inthissection\":\"nesta seção antes de continuar.\",\"code\":\"Código\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"and\":\"e\",\"or\":\"ou\",\"oxfordcomma\":\"\"}}},\"tr\":{\"translation\":{\"button\":{\"runcode\":\"Çalıştırma Kodu\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Ipucu\",\"hint_plural\":\"İpuçları\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Sonraki İpucu\",\"hintprev\":\"Önceki İpucu\",\"solution\":\"Çözüm\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Pano'ya Kopyala\",\"startover\":\"Baştan Başlamak\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Devam et\",\"submitanswer\":\"Cevabı onayla\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Önceki Konu\",\"nexttopic\":\"Sonraki Konu\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Tekrar Deneyin\"},\"text\":{\"startover\":\"Baştan Başlamak\",\"areyousure\":\"Baştan başlamak istediğinizden emin misiniz? (tüm egzersiz ilerlemesi kaybolacak)\",\"youmustcomplete\":\"Tamamlamalısın\",\"exercise\":\"egzersiz\",\"exercise_plural\":\"egzersizler\",\"inthissection\":\"devam etmeden önce bu bölümde\",\"code\":\"Kod\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Sınav\",\"oxfordcomma\":\"\"}}},\"emo\":{\"translation\":{\"button\":{\"runcode\":\"🏃\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"💡\",\"hint_plural\":\"$t(button.hint)\",\"hinttitle\":\"$t(button.hint)\",\"solution\":\"🎯\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"📋\",\"startover\":\"⏮\",\"startovertitle\":\"Start Over\",\"continue\":\"✅\",\"submitanswer\":\"🆗\",\"submitanswertitle\":\"Submit Answer\",\"previoustopic\":\"⬅\",\"nexttopic\":\"➡\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"🔁\"},\"text\":{\"startover\":\"⏮\",\"areyousure\":\"🤔\",\"youmustcomplete\":\"⚠️ 👉 🧑‍💻\",\"exercise\":\"\",\"exercise_plural\":\"\",\"inthissection\":\"\",\"code\":\"💻\",\"enginecap\":\"$t(text.code) {{engine}}\",\"oxfordcomma\":\"\"}}},\"eu\":{\"translation\":{\"button\":{\"runcode\":\"Kodea egikaritu\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Laguntza\",\"hint_plural\":\"Laguntza\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Aurreko laguntza\",\"hintprev\":\"Hurrengo laguntza\",\"solution\":\"Ebazpena\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Arbelean kopiatu\",\"startover\":\"Berrabiarazi\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Jarraitu\",\"submitanswer\":\"Erantzuna bidali\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Aurreko atala\",\"nexttopic\":\"Hurrengo atala\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Berriro saiatu\"},\"text\":{\"startover\":\"Berrabiarazi\",\"areyousure\":\"Berriro hasi nahi duzu? (egindako lana galdu egingo da)\",\"youmustcomplete\":\"Aurrera egin baino lehen atal honetako\",\"exercise\":\"ariketa egin behar duzu.\",\"exercise_plural\":\"ariketak egin behar dituzu.\",\"inthissection\":\"\",\"code\":\"Kodea\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Galdetegia\",\"oxfordcomma\":\"\"}}},\"de\":{\"translation\":{\"button\":{\"runcode\":\"Code ausführen\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Tipp\",\"hint_plural\":\"Tipps\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Nächster Tipp\",\"hintprev\":\"Vorheriger Tipp\",\"solution\":\"Lösung\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"In die Zwischenablage kopieren\",\"startover\":\"Neustart\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Weiter\",\"submitanswer\":\"Antwort einreichen\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Vorheriges Kapitel\",\"nexttopic\":\"Nächstes Kapitel\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Nochmal versuchen\"},\"text\":{\"startover\":\"Neustart\",\"areyousure\":\"Bist du sicher, dass du neustarten willst? (der gesamte Lernfortschritt wird gelöscht)\",\"youmustcomplete\":\"Vervollstädinge\",\"exercise\":\"die Übung\",\"exercise_plural\":\"die Übungen\",\"inthissection\":\"in diesem Kapitel, bevor du fortfährst.\",\"code\":\"Code\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"blank\":\"Lücke\",\"blank_plural\":\"Lücken\",\"pleasereplaceblank\":\"Bitte ersetze {{blank}} mit gültigem Code.\",\"unparsable\":\"Dies scheint kein gültiger R Code zu sein. R kann deinen Text nicht in einen gültigen Befehl übersetzen. Du hast vielleicht vergessen, die Lücke zu füllen, einen Unterstrich zu entfernen, ein Komma zwischen Argumente zu setzen oder ein eröffnendes <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> oder <code>{<\\/code> mit einem zugehörigen <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code> oder <code>}<\\/code> zu schließen.\\n\",\"and\":\"und\",\"or\":\"oder\",\"listcomma\":\", \",\"oxfordcomma\":\",\"}}},\"ko\":{\"translation\":{\"button\":{\"runcode\":\"코드 실행\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"힌트\",\"hint_plural\":\"힌트들\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"다음 힌트\",\"hintprev\":\"이전 힌트\",\"solution\":\"솔루션\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"클립보드에 복사\",\"startover\":\"재학습\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"다음 학습으로\",\"submitanswer\":\"정답 제출\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"이전 토픽\",\"nexttopic\":\"다음 토픽\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"재시도\"},\"text\":{\"startover\":\"재학습\",\"areyousure\":\"다시 시작 하시겠습니까? (모든 예제의 진행 정보가 재설정됩니다)\",\"youmustcomplete\":\"당신은 완료해야 합니다\",\"exercise\":\"연습문제\",\"exercise_plural\":\"연습문제들\",\"inthissection\":\"이 섹션을 실행하기 전에\",\"code\":\"코드\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"퀴즈\",\"blank\":\"공백\",\"blank_plural\":\"공백들\",\"exercisecontainsblank\":\"이 연습문제에는 {{count}}개의 $t(text.blank)이 포함되어 있습니다.\",\"pleasereplaceblank\":\"{{blank}}를 유효한 코드로 바꾸십시오.\",\"unparsable\":\"이것은 유효한 R 코드가 아닐 수 있습니다. R은 텍스트를 완전한 명령으로 변환하는 방법을 결정할 수 없습니다. 당신은 공백이나 밑줄을 대체하여 채우기, 인수를 컴마로 구분하기, 또는 <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> , <code>{<\\/code>로 시작하는 구문을 닫는 <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code>, <code>}<\\/code>을 잊었을 수도 있습니다.\\n\",\"and\":\"그리고\",\"or\":\"혹은\",\"listcomma\":\", \",\"oxfordcomma\":\"\"}}},\"zh\":{\"translation\":{\"button\":{\"runcode\":\"运行代码\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"提示\",\"hint_plural\":\"提示\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"下一个提示\",\"hintprev\":\"上一个提示\",\"solution\":\"答案\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"复制到剪切板\",\"startover\":\"重新开始\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"继续\",\"submitanswer\":\"提交答案\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"上一专题\",\"nexttopic\":\"下一专题\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"再试一次\"},\"text\":{\"startover\":\"重置\",\"areyousure\":\"你确定要重新开始吗? (所有当前进度将被重置)\",\"youmustcomplete\":\"你必须完成\",\"exercise\":\"练习\",\"exercise_plural\":\"练习\",\"inthissection\":\"在进行本节之前\",\"code\":\"代码\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"测试\",\"blank\":\"空\",\"blank_plural\":\"空\",\"exercisecontainsblank\":\"本练习包含{{count}}个$t(text.blank)\",\"pleasereplaceblank\":\"请在{{blank}}内填写恰当的代码\",\"unparsable\":\"这似乎不是有效的R代码。 R不知道如何将您的文本转换为完整的命令。 您是否忘了填空，忘了删除下划线，忘了在参数之间包含逗号，或者是忘了用<code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code>,<code>}<\\/code>来封闭<code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code>。 or <code>{<\\/code>。\\n\",\"unparsablequotes\":\"<p>您的R代码中似乎含有特殊格式的引号，或者弯引号(<code>{{character}}<\\/code>) 在字符串前后，在R中字符串应该被直引号(<code>&quot;<\\/code> 或者 <code>'<\\/code>)包裹。<\\/p> {{code}} <p>别担心，该错误经常在复制粘贴包含格式的代码时遇到， 您可以尝试将该行中的代码替换为以下代码，也许还有其他地方需要修改。<\\/p> {{suggestion}}\\n\",\"unparsableunicode\":\"<p>您的代码中似乎包含有异常字符(<code>{{character}}<\\/code>),导致代码无效。<\\/p> {{code}} <p>有时候你的代码可能含有看似正常字符的特殊字符，特别是当你复制粘贴其他来源代码的时候。 请试着删除这些特殊字符,重新输入<\\/p>\\n\",\"unparsableunicodesuggestion\":\"<p>您的代码中似乎包含有异常字符(<code>{{character}}<\\/code>),导致代码无效。<\\/p> {{code}} <p>有时候你的代码可能含有看似正常字符的特殊字符，特别是当你复制粘贴其他来源代码的时候。 请试着删除这些特殊字符,重新输入<\\/p>\\n\",\"and\":\"且\",\"or\":\"或\",\"listcomma\":\",\",\"oxfordcomma\":\",\"}}},\"pl\":{\"translation\":{\"button\":{\"runcode\":\"Uruchom kod\",\"runcodetitle\":\"$t(button.runcode) ({{kbd}})\",\"hint\":\"Podpowiedź\",\"hint_plural\":\"Podpowiedzi\",\"hinttitle\":\"$t(button.hint)\",\"hintnext\":\"Następna podpowiedź\",\"hintprev\":\"Poprzednia podpowiedź\",\"solution\":\"Rozwiązanie\",\"solutiontitle\":\"$t(button.solution)\",\"copyclipboard\":\"Kopiuj do schowka\",\"startover\":\"Zacznij od początku\",\"startovertitle\":\"$t(button.startover)\",\"continue\":\"Kontynuuj\",\"submitanswer\":\"Wyślij\",\"submitanswertitle\":\"$t(button.submitanswer)\",\"previoustopic\":\"Poprzednia sekcja\",\"nexttopic\":\"Następna sekcja\",\"questionsubmit\":\"$t(button.submitanswer)\",\"questiontryagain\":\"Spróbuj ponownie\"},\"text\":{\"startover\":\"Zacznij od początku\",\"areyousure\":\"Czy na pewno chcesz zacząć od początku? (cały postęp w zadaniu zostanie utracony)\",\"youmustcomplete\":\"Musisz ukończyć\",\"exercise\":\"ćwiczenie\",\"exercise_plural\":\"ćwiczenia\",\"inthissection\":\"w tej sekcji przed kontynuowaniem\",\"code\":\"Kod\",\"enginecap\":\"$t(text.code) {{engine}}\",\"quiz\":\"Quiz\",\"blank\":\"luka\",\"blank_plural\":\"luk(i)\",\"exercisecontainsblank\":\"To ćwiczenie zawiera {{count}} $t(text.blank).\",\"pleasereplaceblank\":\"Proszę uzupełnić {{blank}} prawidłowym kodem.\",\"unparsable\":\"Wygląda na to, że może to nie być prawidłowy kod R. R nie jest w stanie przetworzyć Twojego tekstu na polecenie. Mogłeś(-aś) zapomnieć wypełnić luki, usunąć podkreślnik, umieścić przecinka między argumentami, lub zamknąć znak <code>&quot;<\\/code>, <code>'<\\/code>, <code>(<\\/code> lub <code>{<\\/code> odpowiadającym <code>&quot;<\\/code>, <code>'<\\/code>, <code>)<\\/code> lub <code>}<\\/code>.\\n\",\"unparsablequotes\":\"<p>Wygląda na to, że Twój kod zawiera szczególnie sformatowane cudzysłowy lub cudzysłowy typograficzne (<code>{{character}}<\\/code>) przy ciągach znaków, co sprawia, że kod jest niepoprawny. R wymaga cudzysłowów prostych (<code>&quot;<\\/code> albo <code>'<\\/code>).<\\/p> {{code}} <p>Nie martw się, to powszechne źródło błędów, gdy kopiuje się kod z innego programu, który sam formatuje teskt. Możesz spróbować zastąpić swój kod następującym kodem. Mogą być też inne miejsca, które wymagają poprawienia.<\\/p> {{suggestion}}\\n\",\"unparsableunicode\":\"<p>Wygląda na to, że Twój kod zawiera niespodziewany znak specjalny (<code>{{character}}<\\/code>), co sprawia, że kod jest niepoprawny.<\\/p> {{code}} <p>Czasami Twój kod może zawierać znak specjalny, który wygląda jak zwykły znak, zwłaszcza jeśli kopiujesz kod z innego programu. Spróbuj usunąć znak specjalny i wpisać do ponownie ręcznie.<\\/p>\\n\",\"unparsableunicodesuggestion\":\"<p>Wygląda na to, że Twój kod zawiera niespodziewany znak specjalny (<code>{{character}}<\\/code>), co sprawia, że kod jest niepoprawny.<\\/p> {{code}} <p>Czasami Twój kod może zawierać znak specjalny, który wygląda jak zwykły znak, zwłaszcza jeśli kopiujesz kod z innego programu. Możesz spróbować zastąpić swój kod następującym kodem. Mogą być też inne miejsca, które wymagają poprawienia.<\\/p> {{suggestion}}\\n\",\"and\":\"i\",\"or\":\"lub\",\"listcomma\":\", \",\"oxfordcomma\":\"\"}}}}}<\/script>"]},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial-format"]},{"type":"character","attributes":{},"value":["0.10.5.9000"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmarkdown/templates/tutorial/resources"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial-format.js"]},{"type":"character","attributes":{},"value":["tutorial-format.css","rstudio-theme.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["navigation"]},{"type":"character","attributes":{},"value":["1.1"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/navigation-1.1"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tabsets.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.17"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["highlightjs"]},{"type":"character","attributes":{},"value":["9.12.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/highlightjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["highlight.js"]},{"type":"character","attributes":{},"value":["default.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.17"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["jquery"]},{"type":"character","attributes":{},"value":["3.6.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/3.6.0"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquery-3.6.0.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["jquerylib"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.1.4"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["font-awesome"]},{"type":"character","attributes":{},"value":["5.1.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["rmd/h/fontawesome"]}]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["css/all.css","css/v4-shims.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["rmarkdown"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["2.17"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["bootbox"]},{"type":"character","attributes":{},"value":["5.5.2"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/bootbox"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["bootbox.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["idb-keyvalue"]},{"type":"character","attributes":{},"value":["3.2.0"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/idb-keyval"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["idb-keyval-iife-compat.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[false]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["tutorial"]},{"type":"character","attributes":{},"value":["0.10.5.9000"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/tutorial"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["tutorial.js"]},{"type":"character","attributes":{},"value":["tutorial.css"]},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["ace"]},{"type":"character","attributes":{},"value":["1.4.14"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/ace"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["ace.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["name","version","src","meta","script","stylesheet","head","attachment","package","all_files","pkgVersion"]},"class":{"type":"character","attributes":{},"value":["html_dependency"]}},"value":[{"type":"character","attributes":{},"value":["clipboardjs"]},{"type":"character","attributes":{},"value":["2.0.10"]},{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["file"]}},"value":[{"type":"character","attributes":{},"value":["lib/clipboardjs"]}]},{"type":"NULL"},{"type":"character","attributes":{},"value":["clipboard.min.js"]},{"type":"NULL"},{"type":"NULL"},{"type":"NULL"},{"type":"character","attributes":{},"value":["learnr"]},{"type":"logical","attributes":{},"value":[true]},{"type":"character","attributes":{},"value":["0.10.5.9000"]}]}]}
</script>
<!--/html_preserve-->
<!--html_preserve-->
<script type="application/shiny-prerendered" data-context="execution_dependencies">
{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages"]}},"value":[{"type":"list","attributes":{"names":{"type":"character","attributes":{},"value":["packages","version"]},"class":{"type":"character","attributes":{},"value":["data.frame"]},"row.names":{"type":"integer","attributes":{},"value":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56]}},"value":[{"type":"character","attributes":{},"value":["backports","base","bslib","cachem","checkmate","cli","codetools","compiler","curl","datasets","digest","dismo","ellipsis","evaluate","fastmap","gradethis","graphics","grDevices","grid","htmltools","htmlwidgets","httpuv","jquerylib","jsonlite","knitr","later","lattice","learnr","lifecycle","magrittr","markdown","methods","mime","promises","R6","raster","Rcpp","rgdal","rlang","rmarkdown","rpart","rprojroot","rstudioapi","sass","shiny","sp","stats","stringi","stringr","terra","tools","utils","withr","xfun","xtable","yaml"]},{"type":"character","attributes":{},"value":["1.4.1","4.2.1","0.4.0","1.0.6","2.1.0","3.4.1","0.2-18","4.2.1","4.3.3","4.2.1","0.6.29","1.3-9","0.3.2","0.17","1.1.0","0.2.8.9000","4.2.1","4.2.1","4.2.1","0.5.3","1.5.4","1.6.6","0.1.4","1.8.2","1.40","1.3.0","0.20-45","0.10.5.9000","1.0.3","2.0.3","1.1","4.2.1","0.12","1.2.0.1","2.5.1","3.6-3","1.0.9","1.5-32","1.0.6","2.17","4.1.16","2.0.3","0.14","0.4.2","1.7.2","1.5-0","4.2.1","1.7.8","1.4.1","1.6-17","4.2.1","4.2.1","2.5.0","0.33","1.8-4","2.3.5"]}]}]}
</script>
<!--/html_preserve-->
</div>

</article> <!-- topics -->

<div class="topicsContainer">
<div class="topicsPositioner">
<div class="band">
<div class="bandContent topicsListContainer">

<!-- begin doc-metadata -->
<div id="doc-metadata">
<h1 class="title toc-ignore" style="display:none;">Classification and
Regression Trees</h1>
</div>
<!-- end doc-metadata -->

</div> <!-- bandContent.topicsListContainer -->
</div> <!-- band -->
</div> <!-- topicsPositioner -->
</div> <!-- topicsContainer -->


</main> <!-- bandContent page -->
</div> <!-- pageContent band -->



<!-- Build Tabsets -->
<script>
$(document).ready(function () {
  window.buildTabsets("section-TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<script>
// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});
</script>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>


</body>

</html>
